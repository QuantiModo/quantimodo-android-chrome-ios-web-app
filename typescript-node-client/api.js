"use strict";
/**
 * quantimodo
 * We make it easy to retrieve and analyze normalized user data from a wide array of devices and applications. Check out our [docs and sdk's](https://github.com/QuantiModo/docs) or [contact us](https://help.quantimo.do).
 *
 * OpenAPI spec version: 5.8.112511
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var localVarRequest = require("request");
var defaultBasePath = 'https://app.quantimo.do/api';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
var primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
var ObjectSerializer = /** @class */ (function () {
    function ObjectSerializer() {
    }
    ObjectSerializer.findCorrectType = function (data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            var discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    };
    ObjectSerializer.serialize = function (data, type) {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            var subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            var transformedData = [];
            for (var index in data) {
                var date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return data.toString();
        }
        else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            // get the map for the correct type.
            var attributeTypes = typeMap[type].getAttributeTypeMap();
            var instance = {};
            for (var index in attributeTypes) {
                var attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    };
    ObjectSerializer.deserialize = function (data, type) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            var subType = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            var transformedData = [];
            for (var index in data) {
                var date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap[type]) { // is Enum
                return data;
            }
            if (!typeMap[type]) { // dont know the type
                return data;
            }
            var instance = new typeMap[type]();
            var attributeTypes = typeMap[type].getAttributeTypeMap();
            for (var index in attributeTypes) {
                var attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    };
    return ObjectSerializer;
}());
var ActivitiesResponse = /** @class */ (function () {
    function ActivitiesResponse() {
    }
    ActivitiesResponse.getAttributeTypeMap = function () {
        return ActivitiesResponse.attributeTypeMap;
    };
    ActivitiesResponse.discriminator = undefined;
    ActivitiesResponse.attributeTypeMap = [
        {
            "name": "activities",
            "baseName": "activities",
            "type": "Array<Activity>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return ActivitiesResponse;
}());
exports.ActivitiesResponse = ActivitiesResponse;
var Activity = /** @class */ (function () {
    function Activity() {
    }
    Activity.getAttributeTypeMap = function () {
        return Activity.attributeTypeMap;
    };
    Activity.discriminator = undefined;
    Activity.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "component",
            "baseName": "component",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "primaryLink",
            "baseName": "primaryLink",
            "type": "string"
        },
        {
            "name": "itemId",
            "baseName": "itemId",
            "type": "number"
        },
        {
            "name": "secondaryItemId",
            "baseName": "secondaryItemId",
            "type": "number"
        },
        {
            "name": "dateRecorded",
            "baseName": "dateRecorded",
            "type": "string"
        },
        {
            "name": "hideSitewide",
            "baseName": "hideSitewide",
            "type": "number"
        },
        {
            "name": "mpttLeft",
            "baseName": "mpttLeft",
            "type": "number"
        },
        {
            "name": "mpttRight",
            "baseName": "mpttRight",
            "type": "number"
        },
        {
            "name": "isSpam",
            "baseName": "isSpam",
            "type": "number"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return Activity;
}());
exports.Activity = Activity;
var AppSettings = /** @class */ (function () {
    function AppSettings() {
    }
    AppSettings.getAttributeTypeMap = function () {
        return AppSettings.attributeTypeMap;
    };
    AppSettings.discriminator = undefined;
    AppSettings.attributeTypeMap = [
        {
            "name": "additionalSettings",
            "baseName": "additionalSettings",
            "type": "any"
        },
        {
            "name": "appDescription",
            "baseName": "appDescription",
            "type": "string"
        },
        {
            "name": "appDesign",
            "baseName": "appDesign",
            "type": "any"
        },
        {
            "name": "appDisplayName",
            "baseName": "appDisplayName",
            "type": "string"
        },
        {
            "name": "appStatus",
            "baseName": "appStatus",
            "type": "any"
        },
        {
            "name": "appType",
            "baseName": "appType",
            "type": "string"
        },
        {
            "name": "buildEnabled",
            "baseName": "buildEnabled",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "clientSecret",
            "baseName": "clientSecret",
            "type": "string"
        },
        {
            "name": "collaborators",
            "baseName": "collaborators",
            "type": "Array<User>"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<User>"
        },
        {
            "name": "redirectUri",
            "baseName": "redirectUri",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "homepageUrl",
            "baseName": "homepageUrl",
            "type": "string"
        },
        {
            "name": "iconUrl",
            "baseName": "iconUrl",
            "type": "string"
        },
        {
            "name": "longDescription",
            "baseName": "longDescription",
            "type": "string"
        },
        {
            "name": "splashScreen",
            "baseName": "splashScreen",
            "type": "string"
        },
        {
            "name": "textLogo",
            "baseName": "textLogo",
            "type": "string"
        }
    ];
    return AppSettings;
}());
exports.AppSettings = AppSettings;
var AppSettingsResponse = /** @class */ (function () {
    function AppSettingsResponse() {
    }
    AppSettingsResponse.getAttributeTypeMap = function () {
        return AppSettingsResponse.attributeTypeMap;
    };
    AppSettingsResponse.discriminator = undefined;
    AppSettingsResponse.attributeTypeMap = [
        {
            "name": "appSettings",
            "baseName": "appSettings",
            "type": "AppSettings"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return AppSettingsResponse;
}());
exports.AppSettingsResponse = AppSettingsResponse;
var AuthorizedClients = /** @class */ (function () {
    function AuthorizedClients() {
    }
    AuthorizedClients.getAttributeTypeMap = function () {
        return AuthorizedClients.attributeTypeMap;
    };
    AuthorizedClients.discriminator = undefined;
    AuthorizedClients.attributeTypeMap = [
        {
            "name": "apps",
            "baseName": "apps",
            "type": "Array<AppSettings>"
        },
        {
            "name": "individuals",
            "baseName": "individuals",
            "type": "Array<AppSettings>"
        },
        {
            "name": "studies",
            "baseName": "studies",
            "type": "Array<AppSettings>"
        }
    ];
    return AuthorizedClients;
}());
exports.AuthorizedClients = AuthorizedClients;
var Button = /** @class */ (function () {
    function Button() {
    }
    Button.getAttributeTypeMap = function () {
        return Button.attributeTypeMap;
    };
    Button.discriminator = undefined;
    Button.attributeTypeMap = [
        {
            "name": "accessibilityText",
            "baseName": "accessibilityText",
            "type": "string"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "any"
        },
        {
            "name": "additionalInformation",
            "baseName": "additionalInformation",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "confirmationText",
            "baseName": "confirmationText",
            "type": "string"
        },
        {
            "name": "functionName",
            "baseName": "functionName",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "any"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "stateName",
            "baseName": "stateName",
            "type": "string"
        },
        {
            "name": "stateParams",
            "baseName": "stateParams",
            "type": "any"
        },
        {
            "name": "successToastText",
            "baseName": "successToastText",
            "type": "string"
        },
        {
            "name": "successAlertTitle",
            "baseName": "successAlertTitle",
            "type": "string"
        },
        {
            "name": "successAlertBody",
            "baseName": "successAlertBody",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "tooltip",
            "baseName": "tooltip",
            "type": "string"
        },
        {
            "name": "webhookUrl",
            "baseName": "webhookUrl",
            "type": "string"
        }
    ];
    return Button;
}());
exports.Button = Button;
var Card = /** @class */ (function () {
    function Card() {
    }
    Card.getAttributeTypeMap = function () {
        return Card.attributeTypeMap;
    };
    Card.discriminator = undefined;
    Card.attributeTypeMap = [
        {
            "name": "actionSheetButtons",
            "baseName": "actionSheetButtons",
            "type": "Array<Button>"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "avatarCircular",
            "baseName": "avatarCircular",
            "type": "string"
        },
        {
            "name": "backgroundColor",
            "baseName": "backgroundColor",
            "type": "string"
        },
        {
            "name": "buttons",
            "baseName": "buttons",
            "type": "Array<Button>"
        },
        {
            "name": "buttonsSecondary",
            "baseName": "buttonsSecondary",
            "type": "Array<Button>"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "headerTitle",
            "baseName": "headerTitle",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "htmlContent",
            "baseName": "htmlContent",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "inputFields",
            "baseName": "inputFields",
            "type": "Array<InputField>"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "any"
        },
        {
            "name": "relatedCards",
            "baseName": "relatedCards",
            "type": "Array<Card>"
        },
        {
            "name": "selectedButton",
            "baseName": "selectedButton",
            "type": "Button"
        },
        {
            "name": "sharingBody",
            "baseName": "sharingBody",
            "type": "string"
        },
        {
            "name": "sharingButtons",
            "baseName": "sharingButtons",
            "type": "Array<Button>"
        },
        {
            "name": "sharingTitle",
            "baseName": "sharingTitle",
            "type": "string"
        },
        {
            "name": "subHeader",
            "baseName": "subHeader",
            "type": "string"
        },
        {
            "name": "subTitle",
            "baseName": "subTitle",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }
    ];
    return Card;
}());
exports.Card = Card;
var Chart = /** @class */ (function () {
    function Chart() {
    }
    Chart.getAttributeTypeMap = function () {
        return Chart.attributeTypeMap;
    };
    Chart.discriminator = undefined;
    Chart.attributeTypeMap = [
        {
            "name": "highchartConfig",
            "baseName": "highchartConfig",
            "type": "any"
        },
        {
            "name": "chartId",
            "baseName": "chartId",
            "type": "string"
        },
        {
            "name": "chartTitle",
            "baseName": "chartTitle",
            "type": "string"
        },
        {
            "name": "explanation",
            "baseName": "explanation",
            "type": "string"
        },
        {
            "name": "svgUrl",
            "baseName": "svgUrl",
            "type": "string"
        },
        {
            "name": "svg",
            "baseName": "svg",
            "type": "string"
        }
    ];
    return Chart;
}());
exports.Chart = Chart;
var CommonResponse = /** @class */ (function () {
    function CommonResponse() {
    }
    CommonResponse.getAttributeTypeMap = function () {
        return CommonResponse.attributeTypeMap;
    };
    CommonResponse.discriminator = undefined;
    CommonResponse.attributeTypeMap = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return CommonResponse;
}());
exports.CommonResponse = CommonResponse;
var ConnectInstructions = /** @class */ (function () {
    function ConnectInstructions() {
    }
    ConnectInstructions.getAttributeTypeMap = function () {
        return ConnectInstructions.attributeTypeMap;
    };
    ConnectInstructions.discriminator = undefined;
    ConnectInstructions.attributeTypeMap = [
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "Array<any>"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "usePopup",
            "baseName": "usePopup",
            "type": "boolean"
        }
    ];
    return ConnectInstructions;
}());
exports.ConnectInstructions = ConnectInstructions;
var ConversionStep = /** @class */ (function () {
    function ConversionStep() {
    }
    ConversionStep.getAttributeTypeMap = function () {
        return ConversionStep.attributeTypeMap;
    };
    ConversionStep.discriminator = undefined;
    ConversionStep.attributeTypeMap = [
        {
            "name": "operation",
            "baseName": "operation",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }
    ];
    return ConversionStep;
}());
exports.ConversionStep = ConversionStep;
var Correlation = /** @class */ (function () {
    function Correlation() {
    }
    Correlation.getAttributeTypeMap = function () {
        return Correlation.attributeTypeMap;
    };
    Correlation.discriminator = undefined;
    Correlation.attributeTypeMap = [
        {
            "name": "averageDailyHighCause",
            "baseName": "averageDailyHighCause",
            "type": "number"
        },
        {
            "name": "averageDailyLowCause",
            "baseName": "averageDailyLowCause",
            "type": "number"
        },
        {
            "name": "averageEffect",
            "baseName": "averageEffect",
            "type": "number"
        },
        {
            "name": "averageEffectFollowingHighCause",
            "baseName": "averageEffectFollowingHighCause",
            "type": "number"
        },
        {
            "name": "averageEffectFollowingLowCause",
            "baseName": "averageEffectFollowingLowCause",
            "type": "number"
        },
        {
            "name": "averageForwardPearsonCorrelationOverOnsetDelays",
            "baseName": "averageForwardPearsonCorrelationOverOnsetDelays",
            "type": "number"
        },
        {
            "name": "averageReversePearsonCorrelationOverOnsetDelays",
            "baseName": "averageReversePearsonCorrelationOverOnsetDelays",
            "type": "number"
        },
        {
            "name": "averageVote",
            "baseName": "averageVote",
            "type": "number"
        },
        {
            "name": "causeChanges",
            "baseName": "causeChanges",
            "type": "number"
        },
        {
            "name": "causeDataSource",
            "baseName": "causeDataSource",
            "type": "DataSource"
        },
        {
            "name": "causeUserVariableShareUserMeasurements",
            "baseName": "causeUserVariableShareUserMeasurements",
            "type": "number"
        },
        {
            "name": "causeVariableCategoryId",
            "baseName": "causeVariableCategoryId",
            "type": "number"
        },
        {
            "name": "causeVariableCategoryName",
            "baseName": "causeVariableCategoryName",
            "type": "string"
        },
        {
            "name": "causeVariableCombinationOperation",
            "baseName": "causeVariableCombinationOperation",
            "type": "string"
        },
        {
            "name": "causeVariableUnitAbbreviatedName",
            "baseName": "causeVariableUnitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "causeVariableId",
            "baseName": "causeVariableId",
            "type": "number"
        },
        {
            "name": "causeVariableMostCommonConnectorId",
            "baseName": "causeVariableMostCommonConnectorId",
            "type": "number"
        },
        {
            "name": "causeVariableName",
            "baseName": "causeVariableName",
            "type": "string"
        },
        {
            "name": "confidenceInterval",
            "baseName": "confidenceInterval",
            "type": "number"
        },
        {
            "name": "confidenceLevel",
            "baseName": "confidenceLevel",
            "type": "string"
        },
        {
            "name": "correlationCoefficient",
            "baseName": "correlationCoefficient",
            "type": "number"
        },
        {
            "name": "correlationIsContradictoryToOptimalValues",
            "baseName": "correlationIsContradictoryToOptimalValues",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "criticalTValue",
            "baseName": "criticalTValue",
            "type": "number"
        },
        {
            "name": "direction",
            "baseName": "direction",
            "type": "string"
        },
        {
            "name": "durationOfAction",
            "baseName": "durationOfAction",
            "type": "number"
        },
        {
            "name": "durationOfActionInHours",
            "baseName": "durationOfActionInHours",
            "type": "number"
        },
        {
            "name": "degreesOfFreedom",
            "baseName": "degreesOfFreedom",
            "type": "number"
        },
        {
            "name": "effectNumberOfProcessedDailyMeasurements",
            "baseName": "effectNumberOfProcessedDailyMeasurements",
            "type": "number"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "effectChanges",
            "baseName": "effectChanges",
            "type": "number"
        },
        {
            "name": "effectDataSource",
            "baseName": "effectDataSource",
            "type": "DataSource"
        },
        {
            "name": "effectSize",
            "baseName": "effectSize",
            "type": "string"
        },
        {
            "name": "effectUnit",
            "baseName": "effectUnit",
            "type": "string"
        },
        {
            "name": "effectUserVariableShareUserMeasurements",
            "baseName": "effectUserVariableShareUserMeasurements",
            "type": "number"
        },
        {
            "name": "effectVariableCategoryId",
            "baseName": "effectVariableCategoryId",
            "type": "number"
        },
        {
            "name": "effectVariableCategoryName",
            "baseName": "effectVariableCategoryName",
            "type": "string"
        },
        {
            "name": "effectVariableCombinationOperation",
            "baseName": "effectVariableCombinationOperation",
            "type": "string"
        },
        {
            "name": "effectVariableCommonAlias",
            "baseName": "effectVariableCommonAlias",
            "type": "string"
        },
        {
            "name": "effectVariableUnitAbbreviatedName",
            "baseName": "effectVariableUnitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "effectVariableUnitId",
            "baseName": "effectVariableUnitId",
            "type": "number"
        },
        {
            "name": "effectVariableUnitName",
            "baseName": "effectVariableUnitName",
            "type": "string"
        },
        {
            "name": "effectVariableId",
            "baseName": "effectVariableId",
            "type": "number"
        },
        {
            "name": "effectVariableMostCommonConnectorId",
            "baseName": "effectVariableMostCommonConnectorId",
            "type": "number"
        },
        {
            "name": "effectVariableName",
            "baseName": "effectVariableName",
            "type": "string"
        },
        {
            "name": "experimentEndTime",
            "baseName": "experimentEndTime",
            "type": "string"
        },
        {
            "name": "experimentStartTime",
            "baseName": "experimentStartTime",
            "type": "string"
        },
        {
            "name": "forwardSpearmanCorrelationCoefficient",
            "baseName": "forwardSpearmanCorrelationCoefficient",
            "type": "number"
        },
        {
            "name": "numberOfPairs",
            "baseName": "numberOfPairs",
            "type": "number"
        },
        {
            "name": "onsetDelay",
            "baseName": "onsetDelay",
            "type": "number"
        },
        {
            "name": "onsetDelayInHours",
            "baseName": "onsetDelayInHours",
            "type": "number"
        },
        {
            "name": "onsetDelayWithStrongestPearsonCorrelation",
            "baseName": "onsetDelayWithStrongestPearsonCorrelation",
            "type": "number"
        },
        {
            "name": "onsetDelayWithStrongestPearsonCorrelationInHours",
            "baseName": "onsetDelayWithStrongestPearsonCorrelationInHours",
            "type": "number"
        },
        {
            "name": "optimalPearsonProduct",
            "baseName": "optimalPearsonProduct",
            "type": "number"
        },
        {
            "name": "outcomeFillingValue",
            "baseName": "outcomeFillingValue",
            "type": "number"
        },
        {
            "name": "outcomeMaximumAllowedValue",
            "baseName": "outcomeMaximumAllowedValue",
            "type": "number"
        },
        {
            "name": "outcomeMinimumAllowedValue",
            "baseName": "outcomeMinimumAllowedValue",
            "type": "number"
        },
        {
            "name": "pearsonCorrelationWithNoOnsetDelay",
            "baseName": "pearsonCorrelationWithNoOnsetDelay",
            "type": "number"
        },
        {
            "name": "predictivePearsonCorrelation",
            "baseName": "predictivePearsonCorrelation",
            "type": "number"
        },
        {
            "name": "predictivePearsonCorrelationCoefficient",
            "baseName": "predictivePearsonCorrelationCoefficient",
            "type": "number"
        },
        {
            "name": "predictorDataSources",
            "baseName": "predictorDataSources",
            "type": "string"
        },
        {
            "name": "predictorFillingValue",
            "baseName": "predictorFillingValue",
            "type": "number"
        },
        {
            "name": "predictorMaximumAllowedValue",
            "baseName": "predictorMaximumAllowedValue",
            "type": "number"
        },
        {
            "name": "predictorMinimumAllowedValue",
            "baseName": "predictorMinimumAllowedValue",
            "type": "number"
        },
        {
            "name": "predictsHighEffectChange",
            "baseName": "predictsHighEffectChange",
            "type": "number"
        },
        {
            "name": "predictsLowEffectChange",
            "baseName": "predictsLowEffectChange",
            "type": "number"
        },
        {
            "name": "pValue",
            "baseName": "pValue",
            "type": "number"
        },
        {
            "name": "qmScore",
            "baseName": "qmScore",
            "type": "number"
        },
        {
            "name": "reversePearsonCorrelationCoefficient",
            "baseName": "reversePearsonCorrelationCoefficient",
            "type": "number"
        },
        {
            "name": "shareUserMeasurements",
            "baseName": "shareUserMeasurements",
            "type": "boolean"
        },
        {
            "name": "sharingDescription",
            "baseName": "sharingDescription",
            "type": "string"
        },
        {
            "name": "sharingTitle",
            "baseName": "sharingTitle",
            "type": "string"
        },
        {
            "name": "significantDifference",
            "baseName": "significantDifference",
            "type": "boolean"
        },
        {
            "name": "statisticalSignificance",
            "baseName": "statisticalSignificance",
            "type": "number"
        },
        {
            "name": "strengthLevel",
            "baseName": "strengthLevel",
            "type": "string"
        },
        {
            "name": "strongestPearsonCorrelationCoefficient",
            "baseName": "strongestPearsonCorrelationCoefficient",
            "type": "number"
        },
        {
            "name": "studyHtml",
            "baseName": "studyHtml",
            "type": "StudyHtml"
        },
        {
            "name": "studyImages",
            "baseName": "studyImages",
            "type": "StudyImages"
        },
        {
            "name": "studyLinks",
            "baseName": "studyLinks",
            "type": "StudyLinks"
        },
        {
            "name": "studyText",
            "baseName": "studyText",
            "type": "StudyText"
        },
        {
            "name": "tValue",
            "baseName": "tValue",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "userVote",
            "baseName": "userVote",
            "type": "number"
        },
        {
            "name": "valuePredictingHighOutcome",
            "baseName": "valuePredictingHighOutcome",
            "type": "number"
        },
        {
            "name": "valuePredictingLowOutcome",
            "baseName": "valuePredictingLowOutcome",
            "type": "number"
        },
        {
            "name": "outcomeDataSources",
            "baseName": "outcomeDataSources",
            "type": "string"
        },
        {
            "name": "principalInvestigator",
            "baseName": "principalInvestigator",
            "type": "string"
        },
        {
            "name": "reverseCorrelation",
            "baseName": "reverseCorrelation",
            "type": "number"
        },
        {
            "name": "averagePearsonCorrelationCoefficientOverOnsetDelays",
            "baseName": "averagePearsonCorrelationCoefficientOverOnsetDelays",
            "type": "number"
        },
        {
            "name": "causeNumberOfRawMeasurements",
            "baseName": "causeNumberOfRawMeasurements",
            "type": "number"
        },
        {
            "name": "correlationsOverDurationsOfAction",
            "baseName": "correlationsOverDurationsOfAction",
            "type": "Array<Correlation>"
        },
        {
            "name": "correlationsOverOnsetDelays",
            "baseName": "correlationsOverOnsetDelays",
            "type": "Array<Correlation>"
        },
        {
            "name": "correlationsOverDurationsOfActionChartConfig",
            "baseName": "correlationsOverDurationsOfActionChartConfig",
            "type": "any"
        },
        {
            "name": "correlationsOverOnsetDelaysChartConfig",
            "baseName": "correlationsOverOnsetDelaysChartConfig",
            "type": "any"
        },
        {
            "name": "numberOfUsers",
            "baseName": "numberOfUsers",
            "type": "number"
        },
        {
            "name": "rawCauseMeasurementSignificance",
            "baseName": "rawCauseMeasurementSignificance",
            "type": "number"
        },
        {
            "name": "rawEffectMeasurementSignificance",
            "baseName": "rawEffectMeasurementSignificance",
            "type": "number"
        },
        {
            "name": "reversePairsCount",
            "baseName": "reversePairsCount",
            "type": "string"
        },
        {
            "name": "voteStatisticalSignificance",
            "baseName": "voteStatisticalSignificance",
            "type": "number"
        },
        {
            "name": "aggregateQMScore",
            "baseName": "aggregateQMScore",
            "type": "number"
        },
        {
            "name": "forwardPearsonCorrelationCoefficient",
            "baseName": "forwardPearsonCorrelationCoefficient",
            "type": "number"
        },
        {
            "name": "numberOfCorrelations",
            "baseName": "numberOfCorrelations",
            "type": "number"
        },
        {
            "name": "vote",
            "baseName": "vote",
            "type": "number"
        }
    ];
    return Correlation;
}());
exports.Correlation = Correlation;
var DataSource = /** @class */ (function () {
    function DataSource() {
    }
    DataSource.getAttributeTypeMap = function () {
        return DataSource.attributeTypeMap;
    };
    DataSource.discriminator = undefined;
    DataSource.attributeTypeMap = [
        {
            "name": "affiliate",
            "baseName": "affiliate",
            "type": "boolean"
        },
        {
            "name": "backgroundColor",
            "baseName": "backgroundColor",
            "type": "string"
        },
        {
            "name": "buttons",
            "baseName": "buttons",
            "type": "Array<Button>"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "connected",
            "baseName": "connected",
            "type": "boolean"
        },
        {
            "name": "connectError",
            "baseName": "connectError",
            "type": "string"
        },
        {
            "name": "connectInstructions",
            "baseName": "connectInstructions",
            "type": "ConnectInstructions"
        },
        {
            "name": "connectorId",
            "baseName": "connectorId",
            "type": "number"
        },
        {
            "name": "connectStatus",
            "baseName": "connectStatus",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "connectorClientId",
            "baseName": "connectorClientId",
            "type": "string"
        },
        {
            "name": "defaultVariableCategoryName",
            "baseName": "defaultVariableCategoryName",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "number"
        },
        {
            "name": "getItUrl",
            "baseName": "getItUrl",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "imageHtml",
            "baseName": "imageHtml",
            "type": "string"
        },
        {
            "name": "lastSuccessfulUpdatedAt",
            "baseName": "lastSuccessfulUpdatedAt",
            "type": "string"
        },
        {
            "name": "lastUpdate",
            "baseName": "lastUpdate",
            "type": "number"
        },
        {
            "name": "linkedDisplayNameHtml",
            "baseName": "linkedDisplayNameHtml",
            "type": "string"
        },
        {
            "name": "longDescription",
            "baseName": "longDescription",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "mobileConnectMethod",
            "baseName": "mobileConnectMethod",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "platforms",
            "baseName": "platforms",
            "type": "Array<string>"
        },
        {
            "name": "premium",
            "baseName": "premium",
            "type": "boolean"
        },
        {
            "name": "scopes",
            "baseName": "scopes",
            "type": "Array<string>"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "spreadsheetUploadLink",
            "baseName": "spreadsheetUploadLink",
            "type": "string"
        },
        {
            "name": "totalMeasurementsInLastUpdate",
            "baseName": "totalMeasurementsInLastUpdate",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "string"
        },
        {
            "name": "updateRequestedAt",
            "baseName": "updateRequestedAt",
            "type": "string"
        },
        {
            "name": "updateStatus",
            "baseName": "updateStatus",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        }
    ];
    return DataSource;
}());
exports.DataSource = DataSource;
var DeviceToken = /** @class */ (function () {
    function DeviceToken() {
    }
    DeviceToken.getAttributeTypeMap = function () {
        return DeviceToken.attributeTypeMap;
    };
    DeviceToken.discriminator = undefined;
    DeviceToken.attributeTypeMap = [
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "platform",
            "baseName": "platform",
            "type": "string"
        },
        {
            "name": "deviceToken",
            "baseName": "deviceToken",
            "type": "string"
        }
    ];
    return DeviceToken;
}());
exports.DeviceToken = DeviceToken;
var Explanation = /** @class */ (function () {
    function Explanation() {
    }
    Explanation.getAttributeTypeMap = function () {
        return Explanation.attributeTypeMap;
    };
    Explanation.discriminator = undefined;
    Explanation.attributeTypeMap = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "startTracking",
            "baseName": "startTracking",
            "type": "ExplanationStartTracking"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        }
    ];
    return Explanation;
}());
exports.Explanation = Explanation;
var ExplanationStartTracking = /** @class */ (function () {
    function ExplanationStartTracking() {
    }
    ExplanationStartTracking.getAttributeTypeMap = function () {
        return ExplanationStartTracking.attributeTypeMap;
    };
    ExplanationStartTracking.discriminator = undefined;
    ExplanationStartTracking.attributeTypeMap = [
        {
            "name": "button",
            "baseName": "button",
            "type": "Button"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }
    ];
    return ExplanationStartTracking;
}());
exports.ExplanationStartTracking = ExplanationStartTracking;
var FeedResponse = /** @class */ (function () {
    function FeedResponse() {
    }
    FeedResponse.getAttributeTypeMap = function () {
        return FeedResponse.attributeTypeMap;
    };
    FeedResponse.discriminator = undefined;
    FeedResponse.attributeTypeMap = [
        {
            "name": "cards",
            "baseName": "cards",
            "type": "Array<Card>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return FeedResponse;
}());
exports.FeedResponse = FeedResponse;
var Friend = /** @class */ (function () {
    function Friend() {
    }
    Friend.getAttributeTypeMap = function () {
        return Friend.attributeTypeMap;
    };
    Friend.discriminator = undefined;
    Friend.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "initiatorUserId",
            "baseName": "initiatorUserId",
            "type": "number"
        },
        {
            "name": "friendUserId",
            "baseName": "friendUserId",
            "type": "number"
        },
        {
            "name": "isConfirmed",
            "baseName": "isConfirmed",
            "type": "number"
        },
        {
            "name": "isLimited",
            "baseName": "isLimited",
            "type": "number"
        },
        {
            "name": "dateCreated",
            "baseName": "dateCreated",
            "type": "string"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return Friend;
}());
exports.Friend = Friend;
var FriendsResponse = /** @class */ (function () {
    function FriendsResponse() {
    }
    FriendsResponse.getAttributeTypeMap = function () {
        return FriendsResponse.attributeTypeMap;
    };
    FriendsResponse.discriminator = undefined;
    FriendsResponse.attributeTypeMap = [
        {
            "name": "friends",
            "baseName": "friends",
            "type": "Array<Friend>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return FriendsResponse;
}());
exports.FriendsResponse = FriendsResponse;
var GetConnectorsResponse = /** @class */ (function () {
    function GetConnectorsResponse() {
    }
    GetConnectorsResponse.getAttributeTypeMap = function () {
        return GetConnectorsResponse.attributeTypeMap;
    };
    GetConnectorsResponse.discriminator = undefined;
    GetConnectorsResponse.attributeTypeMap = [
        {
            "name": "connectors",
            "baseName": "connectors",
            "type": "Array<DataSource>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return GetConnectorsResponse;
}());
exports.GetConnectorsResponse = GetConnectorsResponse;
var GetCorrelationsDataResponse = /** @class */ (function () {
    function GetCorrelationsDataResponse() {
    }
    GetCorrelationsDataResponse.getAttributeTypeMap = function () {
        return GetCorrelationsDataResponse.attributeTypeMap;
    };
    GetCorrelationsDataResponse.discriminator = undefined;
    GetCorrelationsDataResponse.attributeTypeMap = [
        {
            "name": "correlations",
            "baseName": "correlations",
            "type": "Array<Correlation>"
        },
        {
            "name": "explanation",
            "baseName": "explanation",
            "type": "Explanation"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return GetCorrelationsDataResponse;
}());
exports.GetCorrelationsDataResponse = GetCorrelationsDataResponse;
var GetCorrelationsResponse = /** @class */ (function () {
    function GetCorrelationsResponse() {
    }
    GetCorrelationsResponse.getAttributeTypeMap = function () {
        return GetCorrelationsResponse.attributeTypeMap;
    };
    GetCorrelationsResponse.discriminator = undefined;
    GetCorrelationsResponse.attributeTypeMap = [
        {
            "name": "data",
            "baseName": "data",
            "type": "GetCorrelationsDataResponse"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return GetCorrelationsResponse;
}());
exports.GetCorrelationsResponse = GetCorrelationsResponse;
var GetSharesResponse = /** @class */ (function () {
    function GetSharesResponse() {
    }
    GetSharesResponse.getAttributeTypeMap = function () {
        return GetSharesResponse.attributeTypeMap;
    };
    GetSharesResponse.discriminator = undefined;
    GetSharesResponse.attributeTypeMap = [
        {
            "name": "authorizedClients",
            "baseName": "authorizedClients",
            "type": "AuthorizedClients"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return GetSharesResponse;
}());
exports.GetSharesResponse = GetSharesResponse;
var GetStudiesResponse = /** @class */ (function () {
    function GetStudiesResponse() {
    }
    GetStudiesResponse.getAttributeTypeMap = function () {
        return GetStudiesResponse.attributeTypeMap;
    };
    GetStudiesResponse.discriminator = undefined;
    GetStudiesResponse.attributeTypeMap = [
        {
            "name": "studies",
            "baseName": "studies",
            "type": "Array<Study>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "startTracking",
            "baseName": "startTracking",
            "type": "ExplanationStartTracking"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        }
    ];
    return GetStudiesResponse;
}());
exports.GetStudiesResponse = GetStudiesResponse;
var GetTrackingReminderNotificationsResponse = /** @class */ (function () {
    function GetTrackingReminderNotificationsResponse() {
    }
    GetTrackingReminderNotificationsResponse.getAttributeTypeMap = function () {
        return GetTrackingReminderNotificationsResponse.attributeTypeMap;
    };
    GetTrackingReminderNotificationsResponse.discriminator = undefined;
    GetTrackingReminderNotificationsResponse.attributeTypeMap = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<TrackingReminderNotification>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return GetTrackingReminderNotificationsResponse;
}());
exports.GetTrackingReminderNotificationsResponse = GetTrackingReminderNotificationsResponse;
var Group = /** @class */ (function () {
    function Group() {
    }
    Group.getAttributeTypeMap = function () {
        return Group.attributeTypeMap;
    };
    Group.discriminator = undefined;
    Group.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "creatorId",
            "baseName": "creatorId",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "slug",
            "baseName": "slug",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "number"
        },
        {
            "name": "enableForum",
            "baseName": "enableForum",
            "type": "number"
        },
        {
            "name": "dateCreated",
            "baseName": "dateCreated",
            "type": "string"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return Group;
}());
exports.Group = Group;
var GroupsMember = /** @class */ (function () {
    function GroupsMember() {
    }
    GroupsMember.getAttributeTypeMap = function () {
        return GroupsMember.attributeTypeMap;
    };
    GroupsMember.discriminator = undefined;
    GroupsMember.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "inviterId",
            "baseName": "inviterId",
            "type": "number"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "number"
        },
        {
            "name": "isMod",
            "baseName": "isMod",
            "type": "number"
        },
        {
            "name": "userTitle",
            "baseName": "userTitle",
            "type": "string"
        },
        {
            "name": "dateModified",
            "baseName": "dateModified",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "isConfirmed",
            "baseName": "isConfirmed",
            "type": "number"
        },
        {
            "name": "isBanned",
            "baseName": "isBanned",
            "type": "number"
        },
        {
            "name": "inviteSent",
            "baseName": "inviteSent",
            "type": "number"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return GroupsMember;
}());
exports.GroupsMember = GroupsMember;
var GroupsMembersResponse = /** @class */ (function () {
    function GroupsMembersResponse() {
    }
    GroupsMembersResponse.getAttributeTypeMap = function () {
        return GroupsMembersResponse.attributeTypeMap;
    };
    GroupsMembersResponse.discriminator = undefined;
    GroupsMembersResponse.attributeTypeMap = [
        {
            "name": "groupsMembers",
            "baseName": "groupsMembers",
            "type": "Array<GroupsMember>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return GroupsMembersResponse;
}());
exports.GroupsMembersResponse = GroupsMembersResponse;
var GroupsResponse = /** @class */ (function () {
    function GroupsResponse() {
    }
    GroupsResponse.getAttributeTypeMap = function () {
        return GroupsResponse.attributeTypeMap;
    };
    GroupsResponse.discriminator = undefined;
    GroupsResponse.attributeTypeMap = [
        {
            "name": "groups",
            "baseName": "groups",
            "type": "Array<Group>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return GroupsResponse;
}());
exports.GroupsResponse = GroupsResponse;
var Image = /** @class */ (function () {
    function Image() {
    }
    Image.getAttributeTypeMap = function () {
        return Image.attributeTypeMap;
    };
    Image.discriminator = undefined;
    Image.attributeTypeMap = [
        {
            "name": "height",
            "baseName": "height",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "string"
        }
    ];
    return Image;
}());
exports.Image = Image;
var InputField = /** @class */ (function () {
    function InputField() {
    }
    InputField.getAttributeTypeMap = function () {
        return InputField.attributeTypeMap;
    };
    InputField.discriminator = undefined;
    InputField.attributeTypeMap = [
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "helpText",
            "baseName": "helpText",
            "type": "string"
        },
        {
            "name": "hint",
            "baseName": "hint",
            "type": "string"
        },
        {
            "name": "icon",
            "baseName": "icon",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "labelLeft",
            "baseName": "labelLeft",
            "type": "string"
        },
        {
            "name": "labelRight",
            "baseName": "labelRight",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "maxLength",
            "baseName": "maxLength",
            "type": "number"
        },
        {
            "name": "maxValue",
            "baseName": "maxValue",
            "type": "number"
        },
        {
            "name": "minLength",
            "baseName": "minLength",
            "type": "number"
        },
        {
            "name": "minValue",
            "baseName": "minValue",
            "type": "number"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<string>"
        },
        {
            "name": "placeholder",
            "baseName": "placeholder",
            "type": "string"
        },
        {
            "name": "postUrl",
            "baseName": "postUrl",
            "type": "string"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "show",
            "baseName": "show",
            "type": "boolean"
        },
        {
            "name": "submitButton",
            "baseName": "submitButton",
            "type": "Button"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "validationPattern",
            "baseName": "validationPattern",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }
    ];
    return InputField;
}());
exports.InputField = InputField;
var JsonErrorResponse = /** @class */ (function () {
    function JsonErrorResponse() {
    }
    JsonErrorResponse.getAttributeTypeMap = function () {
        return JsonErrorResponse.attributeTypeMap;
    };
    JsonErrorResponse.discriminator = undefined;
    JsonErrorResponse.attributeTypeMap = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return JsonErrorResponse;
}());
exports.JsonErrorResponse = JsonErrorResponse;
var Measurement = /** @class */ (function () {
    function Measurement() {
    }
    Measurement.getAttributeTypeMap = function () {
        return Measurement.attributeTypeMap;
    };
    Measurement.discriminator = undefined;
    Measurement.attributeTypeMap = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "connectorId",
            "baseName": "connectorId",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "displayValueAndUnitString",
            "baseName": "displayValueAndUnitString",
            "type": "string"
        },
        {
            "name": "iconIcon",
            "baseName": "iconIcon",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "inputType",
            "baseName": "inputType",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "manualTracking",
            "baseName": "manualTracking",
            "type": "boolean"
        },
        {
            "name": "maximumAllowedValue",
            "baseName": "maximumAllowedValue",
            "type": "number"
        },
        {
            "name": "minimumAllowedValue",
            "baseName": "minimumAllowedValue",
            "type": "number"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "noteObject",
            "baseName": "noteObject",
            "type": "any"
        },
        {
            "name": "noteHtml",
            "baseName": "noteHtml",
            "type": "any"
        },
        {
            "name": "originalUnitId",
            "baseName": "originalUnitId",
            "type": "number"
        },
        {
            "name": "originalValue",
            "baseName": "originalValue",
            "type": "number"
        },
        {
            "name": "pngPath",
            "baseName": "pngPath",
            "type": "string"
        },
        {
            "name": "pngUrl",
            "baseName": "pngUrl",
            "type": "string"
        },
        {
            "name": "productUrl",
            "baseName": "productUrl",
            "type": "string"
        },
        {
            "name": "sourceName",
            "baseName": "sourceName",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "string"
        },
        {
            "name": "startTimeEpoch",
            "baseName": "startTimeEpoch",
            "type": "number"
        },
        {
            "name": "startTimeString",
            "baseName": "startTimeString",
            "type": "string"
        },
        {
            "name": "svgUrl",
            "baseName": "svgUrl",
            "type": "string"
        },
        {
            "name": "unitAbbreviatedName",
            "baseName": "unitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "unitCategoryId",
            "baseName": "unitCategoryId",
            "type": "number"
        },
        {
            "name": "unitCategoryName",
            "baseName": "unitCategoryName",
            "type": "string"
        },
        {
            "name": "unitId",
            "baseName": "unitId",
            "type": "number"
        },
        {
            "name": "unitName",
            "baseName": "unitName",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "userVariableUnitAbbreviatedName",
            "baseName": "userVariableUnitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "userVariableUnitCategoryId",
            "baseName": "userVariableUnitCategoryId",
            "type": "number"
        },
        {
            "name": "userVariableUnitCategoryName",
            "baseName": "userVariableUnitCategoryName",
            "type": "string"
        },
        {
            "name": "userVariableUnitId",
            "baseName": "userVariableUnitId",
            "type": "number"
        },
        {
            "name": "userVariableUnitName",
            "baseName": "userVariableUnitName",
            "type": "string"
        },
        {
            "name": "userVariableVariableCategoryId",
            "baseName": "userVariableVariableCategoryId",
            "type": "number"
        },
        {
            "name": "userVariableVariableCategoryName",
            "baseName": "userVariableVariableCategoryName",
            "type": "string"
        },
        {
            "name": "valence",
            "baseName": "valence",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "variableCategoryId",
            "baseName": "variableCategoryId",
            "type": "number"
        },
        {
            "name": "variableCategoryImageUrl",
            "baseName": "variableCategoryImageUrl",
            "type": "string"
        },
        {
            "name": "variableCategoryName",
            "baseName": "variableCategoryName",
            "type": "string"
        },
        {
            "name": "variableDescription",
            "baseName": "variableDescription",
            "type": "string"
        },
        {
            "name": "variableId",
            "baseName": "variableId",
            "type": "number"
        },
        {
            "name": "variableName",
            "baseName": "variableName",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        }
    ];
    return Measurement;
}());
exports.Measurement = Measurement;
var MeasurementDelete = /** @class */ (function () {
    function MeasurementDelete() {
    }
    MeasurementDelete.getAttributeTypeMap = function () {
        return MeasurementDelete.attributeTypeMap;
    };
    MeasurementDelete.discriminator = undefined;
    MeasurementDelete.attributeTypeMap = [
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "number"
        },
        {
            "name": "variableId",
            "baseName": "variableId",
            "type": "number"
        },
        {
            "name": "connectorName",
            "baseName": "connectorName",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        }
    ];
    return MeasurementDelete;
}());
exports.MeasurementDelete = MeasurementDelete;
var MeasurementItem = /** @class */ (function () {
    function MeasurementItem() {
    }
    MeasurementItem.getAttributeTypeMap = function () {
        return MeasurementItem.attributeTypeMap;
    };
    MeasurementItem.discriminator = undefined;
    MeasurementItem.attributeTypeMap = [
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }
    ];
    return MeasurementItem;
}());
exports.MeasurementItem = MeasurementItem;
var MeasurementSet = /** @class */ (function () {
    function MeasurementSet() {
    }
    MeasurementSet.getAttributeTypeMap = function () {
        return MeasurementSet.attributeTypeMap;
    };
    MeasurementSet.discriminator = undefined;
    MeasurementSet.attributeTypeMap = [
        {
            "name": "combinationOperation",
            "baseName": "combinationOperation",
            "type": "string"
        },
        {
            "name": "measurementItems",
            "baseName": "measurementItems",
            "type": "Array<MeasurementItem>"
        },
        {
            "name": "sourceName",
            "baseName": "sourceName",
            "type": "string"
        },
        {
            "name": "unitAbbreviatedName",
            "baseName": "unitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "variableCategoryName",
            "baseName": "variableCategoryName",
            "type": "string"
        },
        {
            "name": "variableName",
            "baseName": "variableName",
            "type": "string"
        },
        {
            "name": "upc",
            "baseName": "upc",
            "type": "string"
        }
    ];
    return MeasurementSet;
}());
exports.MeasurementSet = MeasurementSet;
var MeasurementUpdate = /** @class */ (function () {
    function MeasurementUpdate() {
    }
    MeasurementUpdate.getAttributeTypeMap = function () {
        return MeasurementUpdate.attributeTypeMap;
    };
    MeasurementUpdate.discriminator = undefined;
    MeasurementUpdate.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        }
    ];
    return MeasurementUpdate;
}());
exports.MeasurementUpdate = MeasurementUpdate;
var MessagesMessage = /** @class */ (function () {
    function MessagesMessage() {
    }
    MessagesMessage.getAttributeTypeMap = function () {
        return MessagesMessage.attributeTypeMap;
    };
    MessagesMessage.discriminator = undefined;
    MessagesMessage.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "threadId",
            "baseName": "threadId",
            "type": "number"
        },
        {
            "name": "senderId",
            "baseName": "senderId",
            "type": "number"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "dateSent",
            "baseName": "dateSent",
            "type": "string"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return MessagesMessage;
}());
exports.MessagesMessage = MessagesMessage;
var MessagesMessagesResponse = /** @class */ (function () {
    function MessagesMessagesResponse() {
    }
    MessagesMessagesResponse.getAttributeTypeMap = function () {
        return MessagesMessagesResponse.attributeTypeMap;
    };
    MessagesMessagesResponse.discriminator = undefined;
    MessagesMessagesResponse.attributeTypeMap = [
        {
            "name": "messagesMessages",
            "baseName": "messagesMessages",
            "type": "Array<MessagesMessage>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return MessagesMessagesResponse;
}());
exports.MessagesMessagesResponse = MessagesMessagesResponse;
var MessagesNotice = /** @class */ (function () {
    function MessagesNotice() {
    }
    MessagesNotice.getAttributeTypeMap = function () {
        return MessagesNotice.attributeTypeMap;
    };
    MessagesNotice.discriminator = undefined;
    MessagesNotice.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "dateSent",
            "baseName": "dateSent",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "number"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return MessagesNotice;
}());
exports.MessagesNotice = MessagesNotice;
var MessagesNoticesResponse = /** @class */ (function () {
    function MessagesNoticesResponse() {
    }
    MessagesNoticesResponse.getAttributeTypeMap = function () {
        return MessagesNoticesResponse.attributeTypeMap;
    };
    MessagesNoticesResponse.discriminator = undefined;
    MessagesNoticesResponse.attributeTypeMap = [
        {
            "name": "messagesNotices",
            "baseName": "messagesNotices",
            "type": "Array<MessagesNotice>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "errorMessage",
            "baseName": "errorMessage",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return MessagesNoticesResponse;
}());
exports.MessagesNoticesResponse = MessagesNoticesResponse;
var MessagesRecipient = /** @class */ (function () {
    function MessagesRecipient() {
    }
    MessagesRecipient.getAttributeTypeMap = function () {
        return MessagesRecipient.attributeTypeMap;
    };
    MessagesRecipient.discriminator = undefined;
    MessagesRecipient.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "threadId",
            "baseName": "threadId",
            "type": "number"
        },
        {
            "name": "unreadCount",
            "baseName": "unreadCount",
            "type": "number"
        },
        {
            "name": "senderOnly",
            "baseName": "senderOnly",
            "type": "number"
        },
        {
            "name": "isDeleted",
            "baseName": "isDeleted",
            "type": "number"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return MessagesRecipient;
}());
exports.MessagesRecipient = MessagesRecipient;
var MessagesRecipientsResponse = /** @class */ (function () {
    function MessagesRecipientsResponse() {
    }
    MessagesRecipientsResponse.getAttributeTypeMap = function () {
        return MessagesRecipientsResponse.attributeTypeMap;
    };
    MessagesRecipientsResponse.discriminator = undefined;
    MessagesRecipientsResponse.attributeTypeMap = [
        {
            "name": "messagesRecipients",
            "baseName": "messagesRecipients",
            "type": "Array<MessagesRecipient>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return MessagesRecipientsResponse;
}());
exports.MessagesRecipientsResponse = MessagesRecipientsResponse;
var ModelError = /** @class */ (function () {
    function ModelError() {
    }
    ModelError.getAttributeTypeMap = function () {
        return ModelError.attributeTypeMap;
    };
    ModelError.discriminator = undefined;
    ModelError.attributeTypeMap = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }
    ];
    return ModelError;
}());
exports.ModelError = ModelError;
var Notification = /** @class */ (function () {
    function Notification() {
    }
    Notification.getAttributeTypeMap = function () {
        return Notification.attributeTypeMap;
    };
    Notification.discriminator = undefined;
    Notification.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "itemId",
            "baseName": "itemId",
            "type": "number"
        },
        {
            "name": "secondaryItemId",
            "baseName": "secondaryItemId",
            "type": "number"
        },
        {
            "name": "componentName",
            "baseName": "componentName",
            "type": "string"
        },
        {
            "name": "componentAction",
            "baseName": "componentAction",
            "type": "string"
        },
        {
            "name": "dateNotified",
            "baseName": "dateNotified",
            "type": "string"
        },
        {
            "name": "isNew",
            "baseName": "isNew",
            "type": "number"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return Notification;
}());
exports.Notification = Notification;
var NotificationsResponse = /** @class */ (function () {
    function NotificationsResponse() {
    }
    NotificationsResponse.getAttributeTypeMap = function () {
        return NotificationsResponse.attributeTypeMap;
    };
    NotificationsResponse.discriminator = undefined;
    NotificationsResponse.attributeTypeMap = [
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "Array<Notification>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return NotificationsResponse;
}());
exports.NotificationsResponse = NotificationsResponse;
var Pair = /** @class */ (function () {
    function Pair() {
    }
    Pair.getAttributeTypeMap = function () {
        return Pair.attributeTypeMap;
    };
    Pair.discriminator = undefined;
    Pair.attributeTypeMap = [
        {
            "name": "causeMeasurement",
            "baseName": "causeMeasurement",
            "type": "number"
        },
        {
            "name": "causeMeasurementValue",
            "baseName": "causeMeasurementValue",
            "type": "number"
        },
        {
            "name": "causeVariableUnitAbbreviatedName",
            "baseName": "causeVariableUnitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "effectMeasurement",
            "baseName": "effectMeasurement",
            "type": "number"
        },
        {
            "name": "effectMeasurementValue",
            "baseName": "effectMeasurementValue",
            "type": "number"
        },
        {
            "name": "effectVariableUnitAbbreviatedName",
            "baseName": "effectVariableUnitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "eventAt",
            "baseName": "eventAt",
            "type": "string"
        },
        {
            "name": "eventAtUnixTime",
            "baseName": "eventAtUnixTime",
            "type": "number"
        },
        {
            "name": "startTimeString",
            "baseName": "startTimeString",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }
    ];
    return Pair;
}());
exports.Pair = Pair;
var ParticipantInstruction = /** @class */ (function () {
    function ParticipantInstruction() {
    }
    ParticipantInstruction.getAttributeTypeMap = function () {
        return ParticipantInstruction.attributeTypeMap;
    };
    ParticipantInstruction.discriminator = undefined;
    ParticipantInstruction.attributeTypeMap = [
        {
            "name": "instructionsForCauseVariable",
            "baseName": "instructionsForCauseVariable",
            "type": "string"
        },
        {
            "name": "instructionsForEffectVariable",
            "baseName": "instructionsForEffectVariable",
            "type": "string"
        }
    ];
    return ParticipantInstruction;
}());
exports.ParticipantInstruction = ParticipantInstruction;
var PostMeasurementsDataResponse = /** @class */ (function () {
    function PostMeasurementsDataResponse() {
    }
    PostMeasurementsDataResponse.getAttributeTypeMap = function () {
        return PostMeasurementsDataResponse.attributeTypeMap;
    };
    PostMeasurementsDataResponse.discriminator = undefined;
    PostMeasurementsDataResponse.attributeTypeMap = [
        {
            "name": "userVariables",
            "baseName": "userVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return PostMeasurementsDataResponse;
}());
exports.PostMeasurementsDataResponse = PostMeasurementsDataResponse;
var PostMeasurementsResponse = /** @class */ (function () {
    function PostMeasurementsResponse() {
    }
    PostMeasurementsResponse.getAttributeTypeMap = function () {
        return PostMeasurementsResponse.attributeTypeMap;
    };
    PostMeasurementsResponse.discriminator = undefined;
    PostMeasurementsResponse.attributeTypeMap = [
        {
            "name": "data",
            "baseName": "data",
            "type": "PostMeasurementsDataResponse"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return PostMeasurementsResponse;
}());
exports.PostMeasurementsResponse = PostMeasurementsResponse;
var PostStudyCreateResponse = /** @class */ (function () {
    function PostStudyCreateResponse() {
    }
    PostStudyCreateResponse.getAttributeTypeMap = function () {
        return PostStudyCreateResponse.attributeTypeMap;
    };
    PostStudyCreateResponse.discriminator = undefined;
    PostStudyCreateResponse.attributeTypeMap = [
        {
            "name": "study",
            "baseName": "study",
            "type": "Study"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return PostStudyCreateResponse;
}());
exports.PostStudyCreateResponse = PostStudyCreateResponse;
var PostStudyPublishResponse = /** @class */ (function () {
    function PostStudyPublishResponse() {
    }
    PostStudyPublishResponse.getAttributeTypeMap = function () {
        return PostStudyPublishResponse.attributeTypeMap;
    };
    PostStudyPublishResponse.discriminator = undefined;
    PostStudyPublishResponse.attributeTypeMap = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return PostStudyPublishResponse;
}());
exports.PostStudyPublishResponse = PostStudyPublishResponse;
var PostTrackingRemindersDataResponse = /** @class */ (function () {
    function PostTrackingRemindersDataResponse() {
    }
    PostTrackingRemindersDataResponse.getAttributeTypeMap = function () {
        return PostTrackingRemindersDataResponse.attributeTypeMap;
    };
    PostTrackingRemindersDataResponse.discriminator = undefined;
    PostTrackingRemindersDataResponse.attributeTypeMap = [
        {
            "name": "trackingReminderNotifications",
            "baseName": "trackingReminderNotifications",
            "type": "Array<TrackingReminderNotification>"
        },
        {
            "name": "trackingReminders",
            "baseName": "trackingReminders",
            "type": "Array<TrackingReminder>"
        },
        {
            "name": "userVariables",
            "baseName": "userVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return PostTrackingRemindersDataResponse;
}());
exports.PostTrackingRemindersDataResponse = PostTrackingRemindersDataResponse;
var PostTrackingRemindersResponse = /** @class */ (function () {
    function PostTrackingRemindersResponse() {
    }
    PostTrackingRemindersResponse.getAttributeTypeMap = function () {
        return PostTrackingRemindersResponse.attributeTypeMap;
    };
    PostTrackingRemindersResponse.discriminator = undefined;
    PostTrackingRemindersResponse.attributeTypeMap = [
        {
            "name": "data",
            "baseName": "data",
            "type": "PostTrackingRemindersDataResponse"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return PostTrackingRemindersResponse;
}());
exports.PostTrackingRemindersResponse = PostTrackingRemindersResponse;
var PostUserSettingsDataResponse = /** @class */ (function () {
    function PostUserSettingsDataResponse() {
    }
    PostUserSettingsDataResponse.getAttributeTypeMap = function () {
        return PostUserSettingsDataResponse.attributeTypeMap;
    };
    PostUserSettingsDataResponse.discriminator = undefined;
    PostUserSettingsDataResponse.attributeTypeMap = [
        {
            "name": "purchaseId",
            "baseName": "purchaseId",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return PostUserSettingsDataResponse;
}());
exports.PostUserSettingsDataResponse = PostUserSettingsDataResponse;
var PostUserSettingsResponse = /** @class */ (function () {
    function PostUserSettingsResponse() {
    }
    PostUserSettingsResponse.getAttributeTypeMap = function () {
        return PostUserSettingsResponse.attributeTypeMap;
    };
    PostUserSettingsResponse.discriminator = undefined;
    PostUserSettingsResponse.attributeTypeMap = [
        {
            "name": "data",
            "baseName": "data",
            "type": "PostUserSettingsDataResponse"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return PostUserSettingsResponse;
}());
exports.PostUserSettingsResponse = PostUserSettingsResponse;
var ShareInvitationBody = /** @class */ (function () {
    function ShareInvitationBody() {
    }
    ShareInvitationBody.getAttributeTypeMap = function () {
        return ShareInvitationBody.attributeTypeMap;
    };
    ShareInvitationBody.discriminator = undefined;
    ShareInvitationBody.attributeTypeMap = [
        {
            "name": "emailAddress",
            "baseName": "emailAddress",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "emailSubject",
            "baseName": "emailSubject",
            "type": "string"
        },
        {
            "name": "emailBody",
            "baseName": "emailBody",
            "type": "string"
        },
        {
            "name": "scopes",
            "baseName": "scopes",
            "type": "string"
        }
    ];
    return ShareInvitationBody;
}());
exports.ShareInvitationBody = ShareInvitationBody;
/**
* A study analyzes the relationship between a predictor variable like gluten-intake and an outcome of interest such as overall mood.
*/
var Study = /** @class */ (function () {
    function Study() {
    }
    Study.getAttributeTypeMap = function () {
        return Study.attributeTypeMap;
    };
    Study.discriminator = undefined;
    Study.attributeTypeMap = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "causeVariable",
            "baseName": "causeVariable",
            "type": "Variable"
        },
        {
            "name": "causeVariableName",
            "baseName": "causeVariableName",
            "type": "string"
        },
        {
            "name": "studyCharts",
            "baseName": "studyCharts",
            "type": "StudyCharts"
        },
        {
            "name": "effectVariable",
            "baseName": "effectVariable",
            "type": "Variable"
        },
        {
            "name": "effectVariableName",
            "baseName": "effectVariableName",
            "type": "string"
        },
        {
            "name": "participantInstructions",
            "baseName": "participantInstructions",
            "type": "ParticipantInstruction"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "Correlation"
        },
        {
            "name": "studyCard",
            "baseName": "studyCard",
            "type": "Card"
        },
        {
            "name": "studyHtml",
            "baseName": "studyHtml",
            "type": "StudyHtml"
        },
        {
            "name": "studyImages",
            "baseName": "studyImages",
            "type": "StudyImages"
        },
        {
            "name": "studyLinks",
            "baseName": "studyLinks",
            "type": "StudyLinks"
        },
        {
            "name": "studySharing",
            "baseName": "studySharing",
            "type": "StudySharing"
        },
        {
            "name": "studyText",
            "baseName": "studyText",
            "type": "StudyText"
        },
        {
            "name": "studyVotes",
            "baseName": "studyVotes",
            "type": "StudyVotes"
        },
        {
            "name": "joined",
            "baseName": "joined",
            "type": "boolean"
        }
    ];
    return Study;
}());
exports.Study = Study;
/**
* An object with various chart properties each property contain and svg and Highcharts configuration
*/
var StudyCharts = /** @class */ (function () {
    function StudyCharts() {
    }
    StudyCharts.getAttributeTypeMap = function () {
        return StudyCharts.attributeTypeMap;
    };
    StudyCharts.discriminator = undefined;
    StudyCharts.attributeTypeMap = [
        {
            "name": "populationTraitScatterPlot",
            "baseName": "populationTraitScatterPlot",
            "type": "Chart"
        },
        {
            "name": "outcomeDistributionColumnChart",
            "baseName": "outcomeDistributionColumnChart",
            "type": "Chart"
        },
        {
            "name": "predictorDistributionColumnChart",
            "baseName": "predictorDistributionColumnChart",
            "type": "Chart"
        },
        {
            "name": "correlationScatterPlot",
            "baseName": "correlationScatterPlot",
            "type": "Chart"
        },
        {
            "name": "pairsOverTimeLineChart",
            "baseName": "pairsOverTimeLineChart",
            "type": "Chart"
        }
    ];
    return StudyCharts;
}());
exports.StudyCharts = StudyCharts;
var StudyCreationBody = /** @class */ (function () {
    function StudyCreationBody() {
    }
    StudyCreationBody.getAttributeTypeMap = function () {
        return StudyCreationBody.attributeTypeMap;
    };
    StudyCreationBody.discriminator = undefined;
    StudyCreationBody.attributeTypeMap = [
        {
            "name": "causeVariableName",
            "baseName": "causeVariableName",
            "type": "string"
        },
        {
            "name": "effectVariableName",
            "baseName": "effectVariableName",
            "type": "string"
        },
        {
            "name": "studyTitle",
            "baseName": "studyTitle",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }
    ];
    return StudyCreationBody;
}());
exports.StudyCreationBody = StudyCreationBody;
var StudyHtml = /** @class */ (function () {
    function StudyHtml() {
    }
    StudyHtml.getAttributeTypeMap = function () {
        return StudyHtml.attributeTypeMap;
    };
    StudyHtml.discriminator = undefined;
    StudyHtml.attributeTypeMap = [
        {
            "name": "chartHtml",
            "baseName": "chartHtml",
            "type": "string"
        },
        {
            "name": "downloadButtonsHtml",
            "baseName": "downloadButtonsHtml",
            "type": "string"
        },
        {
            "name": "fullPageWithHead",
            "baseName": "fullPageWithHead",
            "type": "string"
        },
        {
            "name": "fullStudyHtml",
            "baseName": "fullStudyHtml",
            "type": "string"
        },
        {
            "name": "fullStudyHtmlWithCssStyles",
            "baseName": "fullStudyHtmlWithCssStyles",
            "type": "string"
        },
        {
            "name": "participantInstructionsHtml",
            "baseName": "participantInstructionsHtml",
            "type": "string"
        },
        {
            "name": "statisticsTableHtml",
            "baseName": "statisticsTableHtml",
            "type": "string"
        },
        {
            "name": "studyAbstractHtml",
            "baseName": "studyAbstractHtml",
            "type": "string"
        },
        {
            "name": "studyHeaderHtml",
            "baseName": "studyHeaderHtml",
            "type": "string"
        },
        {
            "name": "studyImageHtml",
            "baseName": "studyImageHtml",
            "type": "string"
        },
        {
            "name": "studyMetaHtml",
            "baseName": "studyMetaHtml",
            "type": "string"
        },
        {
            "name": "studyTextHtml",
            "baseName": "studyTextHtml",
            "type": "string"
        },
        {
            "name": "socialSharingButtonHtml",
            "baseName": "socialSharingButtonHtml",
            "type": "string"
        },
        {
            "name": "studySummaryBoxHtml",
            "baseName": "studySummaryBoxHtml",
            "type": "string"
        }
    ];
    return StudyHtml;
}());
exports.StudyHtml = StudyHtml;
var StudyImages = /** @class */ (function () {
    function StudyImages() {
    }
    StudyImages.getAttributeTypeMap = function () {
        return StudyImages.attributeTypeMap;
    };
    StudyImages.discriminator = undefined;
    StudyImages.attributeTypeMap = [
        {
            "name": "causeVariableImageUrl",
            "baseName": "causeVariableImageUrl",
            "type": "string"
        },
        {
            "name": "causeVariableIonIcon",
            "baseName": "causeVariableIonIcon",
            "type": "string"
        },
        {
            "name": "effectVariableImageUrl",
            "baseName": "effectVariableImageUrl",
            "type": "string"
        },
        {
            "name": "effectVariableIonIcon",
            "baseName": "effectVariableIonIcon",
            "type": "string"
        },
        {
            "name": "gaugeImage",
            "baseName": "gaugeImage",
            "type": "string"
        },
        {
            "name": "gaugeImageSquare",
            "baseName": "gaugeImageSquare",
            "type": "string"
        },
        {
            "name": "gaugeSharingImageUrl",
            "baseName": "gaugeSharingImageUrl",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "robotSharingImageUrl",
            "baseName": "robotSharingImageUrl",
            "type": "string"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        }
    ];
    return StudyImages;
}());
exports.StudyImages = StudyImages;
var StudyJoinResponse = /** @class */ (function () {
    function StudyJoinResponse() {
    }
    StudyJoinResponse.getAttributeTypeMap = function () {
        return StudyJoinResponse.attributeTypeMap;
    };
    StudyJoinResponse.discriminator = undefined;
    StudyJoinResponse.attributeTypeMap = [
        {
            "name": "study",
            "baseName": "study",
            "type": "Study"
        },
        {
            "name": "trackingReminders",
            "baseName": "trackingReminders",
            "type": "Array<TrackingReminder>"
        },
        {
            "name": "trackingReminderNotifications",
            "baseName": "trackingReminderNotifications",
            "type": "Array<TrackingReminderNotification>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return StudyJoinResponse;
}());
exports.StudyJoinResponse = StudyJoinResponse;
var StudyLinks = /** @class */ (function () {
    function StudyLinks() {
    }
    StudyLinks.getAttributeTypeMap = function () {
        return StudyLinks.attributeTypeMap;
    };
    StudyLinks.discriminator = undefined;
    StudyLinks.attributeTypeMap = [
        {
            "name": "studyJoinLink",
            "baseName": "studyJoinLink",
            "type": "string"
        },
        {
            "name": "studyLinkEmail",
            "baseName": "studyLinkEmail",
            "type": "string"
        },
        {
            "name": "studyLinkFacebook",
            "baseName": "studyLinkFacebook",
            "type": "string"
        },
        {
            "name": "studyLinkGoogle",
            "baseName": "studyLinkGoogle",
            "type": "string"
        },
        {
            "name": "studyLinkStatic",
            "baseName": "studyLinkStatic",
            "type": "string"
        },
        {
            "name": "studyLinkDynamic",
            "baseName": "studyLinkDynamic",
            "type": "string"
        },
        {
            "name": "studyLinkTwitter",
            "baseName": "studyLinkTwitter",
            "type": "string"
        }
    ];
    return StudyLinks;
}());
exports.StudyLinks = StudyLinks;
var StudySharing = /** @class */ (function () {
    function StudySharing() {
    }
    StudySharing.getAttributeTypeMap = function () {
        return StudySharing.attributeTypeMap;
    };
    StudySharing.discriminator = undefined;
    StudySharing.attributeTypeMap = [
        {
            "name": "shareUserMeasurements",
            "baseName": "shareUserMeasurements",
            "type": "boolean"
        },
        {
            "name": "sharingDescription",
            "baseName": "sharingDescription",
            "type": "string"
        },
        {
            "name": "sharingTitle",
            "baseName": "sharingTitle",
            "type": "string"
        }
    ];
    return StudySharing;
}());
exports.StudySharing = StudySharing;
var StudyText = /** @class */ (function () {
    function StudyText() {
    }
    StudyText.getAttributeTypeMap = function () {
        return StudyText.attributeTypeMap;
    };
    StudyText.discriminator = undefined;
    StudyText.attributeTypeMap = [
        {
            "name": "averageEffectFollowingHighCauseExplanation",
            "baseName": "averageEffectFollowingHighCauseExplanation",
            "type": "string"
        },
        {
            "name": "averageEffectFollowingLowCauseExplanation",
            "baseName": "averageEffectFollowingLowCauseExplanation",
            "type": "string"
        },
        {
            "name": "valuePredictingHighOutcomeExplanation",
            "baseName": "valuePredictingHighOutcomeExplanation",
            "type": "string"
        },
        {
            "name": "valuePredictingLowOutcomeExplanation",
            "baseName": "valuePredictingLowOutcomeExplanation",
            "type": "string"
        },
        {
            "name": "dataAnalysis",
            "baseName": "dataAnalysis",
            "type": "string"
        },
        {
            "name": "dataSources",
            "baseName": "dataSources",
            "type": "string"
        },
        {
            "name": "dataSourcesParagraphForCause",
            "baseName": "dataSourcesParagraphForCause",
            "type": "string"
        },
        {
            "name": "dataSourcesParagraphForEffect",
            "baseName": "dataSourcesParagraphForEffect",
            "type": "string"
        },
        {
            "name": "lastCauseDailyValueSentenceExtended",
            "baseName": "lastCauseDailyValueSentenceExtended",
            "type": "string"
        },
        {
            "name": "lastCauseAndOptimalValueSentence",
            "baseName": "lastCauseAndOptimalValueSentence",
            "type": "string"
        },
        {
            "name": "lastCauseDailyValueSentence",
            "baseName": "lastCauseDailyValueSentence",
            "type": "string"
        },
        {
            "name": "optimalDailyValueSentence",
            "baseName": "optimalDailyValueSentence",
            "type": "string"
        },
        {
            "name": "participantInstructions",
            "baseName": "participantInstructions",
            "type": "string"
        },
        {
            "name": "predictorExplanation",
            "baseName": "predictorExplanation",
            "type": "string"
        },
        {
            "name": "significanceExplanation",
            "baseName": "significanceExplanation",
            "type": "string"
        },
        {
            "name": "studyAbstract",
            "baseName": "studyAbstract",
            "type": "string"
        },
        {
            "name": "studyDesign",
            "baseName": "studyDesign",
            "type": "string"
        },
        {
            "name": "studyLimitations",
            "baseName": "studyLimitations",
            "type": "string"
        },
        {
            "name": "studyObjective",
            "baseName": "studyObjective",
            "type": "string"
        },
        {
            "name": "studyResults",
            "baseName": "studyResults",
            "type": "string"
        },
        {
            "name": "studyTitle",
            "baseName": "studyTitle",
            "type": "string"
        },
        {
            "name": "studyInvitation",
            "baseName": "studyInvitation",
            "type": "string"
        },
        {
            "name": "studyQuestion",
            "baseName": "studyQuestion",
            "type": "string"
        },
        {
            "name": "studyBackground",
            "baseName": "studyBackground",
            "type": "string"
        }
    ];
    return StudyText;
}());
exports.StudyText = StudyText;
var StudyVotes = /** @class */ (function () {
    function StudyVotes() {
    }
    StudyVotes.getAttributeTypeMap = function () {
        return StudyVotes.attributeTypeMap;
    };
    StudyVotes.discriminator = undefined;
    StudyVotes.attributeTypeMap = [
        {
            "name": "averageVote",
            "baseName": "averageVote",
            "type": "number"
        },
        {
            "name": "userVote",
            "baseName": "userVote",
            "type": "number"
        }
    ];
    return StudyVotes;
}());
exports.StudyVotes = StudyVotes;
var TrackingReminder = /** @class */ (function () {
    function TrackingReminder() {
    }
    TrackingReminder.getAttributeTypeMap = function () {
        return TrackingReminder.attributeTypeMap;
    };
    TrackingReminder.discriminator = undefined;
    TrackingReminder.attributeTypeMap = [
        {
            "name": "actionArray",
            "baseName": "actionArray",
            "type": "Array<TrackingReminderNotificationAction>"
        },
        {
            "name": "availableUnits",
            "baseName": "availableUnits",
            "type": "Array<Unit>"
        },
        {
            "name": "bestStudyLink",
            "baseName": "bestStudyLink",
            "type": "string"
        },
        {
            "name": "bestStudyCard",
            "baseName": "bestStudyCard",
            "type": "Card"
        },
        {
            "name": "bestUserStudyLink",
            "baseName": "bestUserStudyLink",
            "type": "string"
        },
        {
            "name": "bestUserStudyCard",
            "baseName": "bestUserStudyCard",
            "type": "Card"
        },
        {
            "name": "bestPopulationStudyLink",
            "baseName": "bestPopulationStudyLink",
            "type": "string"
        },
        {
            "name": "bestPopulationStudyCard",
            "baseName": "bestPopulationStudyCard",
            "type": "Card"
        },
        {
            "name": "optimalValueMessage",
            "baseName": "optimalValueMessage",
            "type": "string"
        },
        {
            "name": "commonOptimalValueMessage",
            "baseName": "commonOptimalValueMessage",
            "type": "string"
        },
        {
            "name": "userOptimalValueMessage",
            "baseName": "userOptimalValueMessage",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "combinationOperation",
            "baseName": "combinationOperation",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "unitAbbreviatedName",
            "baseName": "unitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "unitCategoryId",
            "baseName": "unitCategoryId",
            "type": "number"
        },
        {
            "name": "unitCategoryName",
            "baseName": "unitCategoryName",
            "type": "string"
        },
        {
            "name": "unitId",
            "baseName": "unitId",
            "type": "number"
        },
        {
            "name": "unitName",
            "baseName": "unitName",
            "type": "string"
        },
        {
            "name": "defaultValue",
            "baseName": "defaultValue",
            "type": "number"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "boolean"
        },
        {
            "name": "errorMessage",
            "baseName": "errorMessage",
            "type": "string"
        },
        {
            "name": "fillingValue",
            "baseName": "fillingValue",
            "type": "number"
        },
        {
            "name": "firstDailyReminderTime",
            "baseName": "firstDailyReminderTime",
            "type": "string"
        },
        {
            "name": "frequencyTextDescription",
            "baseName": "frequencyTextDescription",
            "type": "string"
        },
        {
            "name": "frequencyTextDescriptionWithTime",
            "baseName": "frequencyTextDescriptionWithTime",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "inputType",
            "baseName": "inputType",
            "type": "string"
        },
        {
            "name": "instructions",
            "baseName": "instructions",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "lastTracked",
            "baseName": "lastTracked",
            "type": "string"
        },
        {
            "name": "lastValue",
            "baseName": "lastValue",
            "type": "number"
        },
        {
            "name": "latestTrackingReminderNotificationReminderTime",
            "baseName": "latestTrackingReminderNotificationReminderTime",
            "type": "string"
        },
        {
            "name": "localDailyReminderNotificationTimes",
            "baseName": "localDailyReminderNotificationTimes",
            "type": "Array<string>"
        },
        {
            "name": "localDailyReminderNotificationTimesForAllReminders",
            "baseName": "localDailyReminderNotificationTimesForAllReminders",
            "type": "Array<string>"
        },
        {
            "name": "manualTracking",
            "baseName": "manualTracking",
            "type": "boolean"
        },
        {
            "name": "maximumAllowedValue",
            "baseName": "maximumAllowedValue",
            "type": "number"
        },
        {
            "name": "minimumAllowedValue",
            "baseName": "minimumAllowedValue",
            "type": "number"
        },
        {
            "name": "nextReminderTimeEpochSeconds",
            "baseName": "nextReminderTimeEpochSeconds",
            "type": "number"
        },
        {
            "name": "notificationBar",
            "baseName": "notificationBar",
            "type": "boolean"
        },
        {
            "name": "numberOfRawMeasurements",
            "baseName": "numberOfRawMeasurements",
            "type": "number"
        },
        {
            "name": "numberOfUniqueValues",
            "baseName": "numberOfUniqueValues",
            "type": "number"
        },
        {
            "name": "outcome",
            "baseName": "outcome",
            "type": "boolean"
        },
        {
            "name": "pngPath",
            "baseName": "pngPath",
            "type": "string"
        },
        {
            "name": "pngUrl",
            "baseName": "pngUrl",
            "type": "string"
        },
        {
            "name": "productUrl",
            "baseName": "productUrl",
            "type": "string"
        },
        {
            "name": "popUp",
            "baseName": "popUp",
            "type": "boolean"
        },
        {
            "name": "question",
            "baseName": "question",
            "type": "string"
        },
        {
            "name": "longQuestion",
            "baseName": "longQuestion",
            "type": "string"
        },
        {
            "name": "reminderEndTime",
            "baseName": "reminderEndTime",
            "type": "string"
        },
        {
            "name": "reminderFrequency",
            "baseName": "reminderFrequency",
            "type": "number"
        },
        {
            "name": "reminderSound",
            "baseName": "reminderSound",
            "type": "string"
        },
        {
            "name": "reminderStartEpochSeconds",
            "baseName": "reminderStartEpochSeconds",
            "type": "number"
        },
        {
            "name": "reminderStartTime",
            "baseName": "reminderStartTime",
            "type": "string"
        },
        {
            "name": "reminderStartTimeLocal",
            "baseName": "reminderStartTimeLocal",
            "type": "string"
        },
        {
            "name": "reminderStartTimeLocalHumanFormatted",
            "baseName": "reminderStartTimeLocalHumanFormatted",
            "type": "string"
        },
        {
            "name": "repeating",
            "baseName": "repeating",
            "type": "boolean"
        },
        {
            "name": "secondDailyReminderTime",
            "baseName": "secondDailyReminderTime",
            "type": "string"
        },
        {
            "name": "secondToLastValue",
            "baseName": "secondToLastValue",
            "type": "number"
        },
        {
            "name": "sms",
            "baseName": "sms",
            "type": "boolean"
        },
        {
            "name": "startTrackingDate",
            "baseName": "startTrackingDate",
            "type": "string"
        },
        {
            "name": "stopTrackingDate",
            "baseName": "stopTrackingDate",
            "type": "string"
        },
        {
            "name": "svgUrl",
            "baseName": "svgUrl",
            "type": "string"
        },
        {
            "name": "thirdDailyReminderTime",
            "baseName": "thirdDailyReminderTime",
            "type": "string"
        },
        {
            "name": "thirdToLastValue",
            "baseName": "thirdToLastValue",
            "type": "number"
        },
        {
            "name": "trackingReminderId",
            "baseName": "trackingReminderId",
            "type": "number"
        },
        {
            "name": "trackingReminderImageUrl",
            "baseName": "trackingReminderImageUrl",
            "type": "string"
        },
        {
            "name": "upc",
            "baseName": "upc",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "userVariableUnitAbbreviatedName",
            "baseName": "userVariableUnitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "userVariableUnitCategoryId",
            "baseName": "userVariableUnitCategoryId",
            "type": "number"
        },
        {
            "name": "userVariableUnitCategoryName",
            "baseName": "userVariableUnitCategoryName",
            "type": "string"
        },
        {
            "name": "userVariableUnitId",
            "baseName": "userVariableUnitId",
            "type": "number"
        },
        {
            "name": "userVariableUnitName",
            "baseName": "userVariableUnitName",
            "type": "string"
        },
        {
            "name": "userVariableVariableCategoryId",
            "baseName": "userVariableVariableCategoryId",
            "type": "number"
        },
        {
            "name": "userVariableVariableCategoryName",
            "baseName": "userVariableVariableCategoryName",
            "type": "string"
        },
        {
            "name": "valence",
            "baseName": "valence",
            "type": "string"
        },
        {
            "name": "valueAndFrequencyTextDescription",
            "baseName": "valueAndFrequencyTextDescription",
            "type": "string"
        },
        {
            "name": "valueAndFrequencyTextDescriptionWithTime",
            "baseName": "valueAndFrequencyTextDescriptionWithTime",
            "type": "string"
        },
        {
            "name": "variableCategoryId",
            "baseName": "variableCategoryId",
            "type": "number"
        },
        {
            "name": "variableCategoryImageUrl",
            "baseName": "variableCategoryImageUrl",
            "type": "string"
        },
        {
            "name": "variableCategoryName",
            "baseName": "variableCategoryName",
            "type": "string"
        },
        {
            "name": "variableDescription",
            "baseName": "variableDescription",
            "type": "string"
        },
        {
            "name": "variableId",
            "baseName": "variableId",
            "type": "number"
        },
        {
            "name": "variableName",
            "baseName": "variableName",
            "type": "string"
        }
    ];
    return TrackingReminder;
}());
exports.TrackingReminder = TrackingReminder;
var TrackingReminderDelete = /** @class */ (function () {
    function TrackingReminderDelete() {
    }
    TrackingReminderDelete.getAttributeTypeMap = function () {
        return TrackingReminderDelete.attributeTypeMap;
    };
    TrackingReminderDelete.discriminator = undefined;
    TrackingReminderDelete.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }
    ];
    return TrackingReminderDelete;
}());
exports.TrackingReminderDelete = TrackingReminderDelete;
var TrackingReminderNotification = /** @class */ (function () {
    function TrackingReminderNotification() {
    }
    TrackingReminderNotification.getAttributeTypeMap = function () {
        return TrackingReminderNotification.attributeTypeMap;
    };
    TrackingReminderNotification.discriminator = undefined;
    TrackingReminderNotification.attributeTypeMap = [
        {
            "name": "actionArray",
            "baseName": "actionArray",
            "type": "Array<TrackingReminderNotificationAction>"
        },
        {
            "name": "availableUnits",
            "baseName": "availableUnits",
            "type": "Array<Unit>"
        },
        {
            "name": "bestStudyLink",
            "baseName": "bestStudyLink",
            "type": "string"
        },
        {
            "name": "bestStudyCard",
            "baseName": "bestStudyCard",
            "type": "Card"
        },
        {
            "name": "bestUserStudyLink",
            "baseName": "bestUserStudyLink",
            "type": "string"
        },
        {
            "name": "bestUserStudyCard",
            "baseName": "bestUserStudyCard",
            "type": "Card"
        },
        {
            "name": "bestPopulationStudyLink",
            "baseName": "bestPopulationStudyLink",
            "type": "string"
        },
        {
            "name": "bestPopulationStudyCard",
            "baseName": "bestPopulationStudyCard",
            "type": "Card"
        },
        {
            "name": "optimalValueMessage",
            "baseName": "optimalValueMessage",
            "type": "string"
        },
        {
            "name": "commonOptimalValueMessage",
            "baseName": "commonOptimalValueMessage",
            "type": "string"
        },
        {
            "name": "userOptimalValueMessage",
            "baseName": "userOptimalValueMessage",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "combinationOperation",
            "baseName": "combinationOperation",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "modifiedValue",
            "baseName": "modifiedValue",
            "type": "number"
        },
        {
            "name": "unitAbbreviatedName",
            "baseName": "unitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "unitCategoryId",
            "baseName": "unitCategoryId",
            "type": "number"
        },
        {
            "name": "unitCategoryName",
            "baseName": "unitCategoryName",
            "type": "string"
        },
        {
            "name": "unitId",
            "baseName": "unitId",
            "type": "number"
        },
        {
            "name": "unitName",
            "baseName": "unitName",
            "type": "string"
        },
        {
            "name": "defaultValue",
            "baseName": "defaultValue",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "boolean"
        },
        {
            "name": "fillingValue",
            "baseName": "fillingValue",
            "type": "number"
        },
        {
            "name": "iconIcon",
            "baseName": "iconIcon",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "inputType",
            "baseName": "inputType",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "lastValue",
            "baseName": "lastValue",
            "type": "number"
        },
        {
            "name": "manualTracking",
            "baseName": "manualTracking",
            "type": "boolean"
        },
        {
            "name": "maximumAllowedValue",
            "baseName": "maximumAllowedValue",
            "type": "number"
        },
        {
            "name": "minimumAllowedValue",
            "baseName": "minimumAllowedValue",
            "type": "number"
        },
        {
            "name": "mostCommonValue",
            "baseName": "mostCommonValue",
            "type": "number"
        },
        {
            "name": "notificationBar",
            "baseName": "notificationBar",
            "type": "boolean"
        },
        {
            "name": "notifiedAt",
            "baseName": "notifiedAt",
            "type": "string"
        },
        {
            "name": "numberOfUniqueValues",
            "baseName": "numberOfUniqueValues",
            "type": "number"
        },
        {
            "name": "outcome",
            "baseName": "outcome",
            "type": "boolean"
        },
        {
            "name": "pngPath",
            "baseName": "pngPath",
            "type": "string"
        },
        {
            "name": "pngUrl",
            "baseName": "pngUrl",
            "type": "string"
        },
        {
            "name": "popUp",
            "baseName": "popUp",
            "type": "boolean"
        },
        {
            "name": "productUrl",
            "baseName": "productUrl",
            "type": "string"
        },
        {
            "name": "question",
            "baseName": "question",
            "type": "string"
        },
        {
            "name": "longQuestion",
            "baseName": "longQuestion",
            "type": "string"
        },
        {
            "name": "reminderEndTime",
            "baseName": "reminderEndTime",
            "type": "string"
        },
        {
            "name": "reminderFrequency",
            "baseName": "reminderFrequency",
            "type": "number"
        },
        {
            "name": "reminderSound",
            "baseName": "reminderSound",
            "type": "string"
        },
        {
            "name": "reminderStartTime",
            "baseName": "reminderStartTime",
            "type": "string"
        },
        {
            "name": "reminderTime",
            "baseName": "reminderTime",
            "type": "string"
        },
        {
            "name": "secondMostCommonValue",
            "baseName": "secondMostCommonValue",
            "type": "number"
        },
        {
            "name": "secondToLastValue",
            "baseName": "secondToLastValue",
            "type": "number"
        },
        {
            "name": "sms",
            "baseName": "sms",
            "type": "boolean"
        },
        {
            "name": "svgUrl",
            "baseName": "svgUrl",
            "type": "string"
        },
        {
            "name": "thirdMostCommonValue",
            "baseName": "thirdMostCommonValue",
            "type": "number"
        },
        {
            "name": "thirdToLastValue",
            "baseName": "thirdToLastValue",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "trackAllActions",
            "baseName": "trackAllActions",
            "type": "Array<TrackingReminderNotificationTrackAllAction>"
        },
        {
            "name": "trackingReminderId",
            "baseName": "trackingReminderId",
            "type": "number"
        },
        {
            "name": "trackingReminderImageUrl",
            "baseName": "trackingReminderImageUrl",
            "type": "string"
        },
        {
            "name": "trackingReminderNotificationId",
            "baseName": "trackingReminderNotificationId",
            "type": "number"
        },
        {
            "name": "trackingReminderNotificationTime",
            "baseName": "trackingReminderNotificationTime",
            "type": "string"
        },
        {
            "name": "trackingReminderNotificationTimeEpoch",
            "baseName": "trackingReminderNotificationTimeEpoch",
            "type": "number"
        },
        {
            "name": "trackingReminderNotificationTimeLocal",
            "baseName": "trackingReminderNotificationTimeLocal",
            "type": "string"
        },
        {
            "name": "trackingReminderNotificationTimeLocalHumanString",
            "baseName": "trackingReminderNotificationTimeLocalHumanString",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "userVariableUnitAbbreviatedName",
            "baseName": "userVariableUnitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "userVariableUnitCategoryId",
            "baseName": "userVariableUnitCategoryId",
            "type": "number"
        },
        {
            "name": "userVariableUnitCategoryName",
            "baseName": "userVariableUnitCategoryName",
            "type": "string"
        },
        {
            "name": "userVariableUnitId",
            "baseName": "userVariableUnitId",
            "type": "number"
        },
        {
            "name": "userVariableUnitName",
            "baseName": "userVariableUnitName",
            "type": "string"
        },
        {
            "name": "userVariableVariableCategoryId",
            "baseName": "userVariableVariableCategoryId",
            "type": "number"
        },
        {
            "name": "userVariableVariableCategoryName",
            "baseName": "userVariableVariableCategoryName",
            "type": "string"
        },
        {
            "name": "valence",
            "baseName": "valence",
            "type": "string"
        },
        {
            "name": "variableCategoryId",
            "baseName": "variableCategoryId",
            "type": "number"
        },
        {
            "name": "variableCategoryImageUrl",
            "baseName": "variableCategoryImageUrl",
            "type": "string"
        },
        {
            "name": "variableCategoryName",
            "baseName": "variableCategoryName",
            "type": "string"
        },
        {
            "name": "variableId",
            "baseName": "variableId",
            "type": "number"
        },
        {
            "name": "variableImageUrl",
            "baseName": "variableImageUrl",
            "type": "string"
        },
        {
            "name": "variableName",
            "baseName": "variableName",
            "type": "string"
        }
    ];
    return TrackingReminderNotification;
}());
exports.TrackingReminderNotification = TrackingReminderNotification;
var TrackingReminderNotificationAction = /** @class */ (function () {
    function TrackingReminderNotificationAction() {
    }
    TrackingReminderNotificationAction.getAttributeTypeMap = function () {
        return TrackingReminderNotificationAction.attributeTypeMap;
    };
    TrackingReminderNotificationAction.discriminator = undefined;
    TrackingReminderNotificationAction.attributeTypeMap = [
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "callback",
            "baseName": "callback",
            "type": "string"
        },
        {
            "name": "modifiedValue",
            "baseName": "modifiedValue",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "longTitle",
            "baseName": "longTitle",
            "type": "string"
        },
        {
            "name": "shortTitle",
            "baseName": "shortTitle",
            "type": "string"
        }
    ];
    return TrackingReminderNotificationAction;
}());
exports.TrackingReminderNotificationAction = TrackingReminderNotificationAction;
var TrackingReminderNotificationPost = /** @class */ (function () {
    function TrackingReminderNotificationPost() {
    }
    TrackingReminderNotificationPost.getAttributeTypeMap = function () {
        return TrackingReminderNotificationPost.attributeTypeMap;
    };
    TrackingReminderNotificationPost.discriminator = undefined;
    TrackingReminderNotificationPost.attributeTypeMap = [
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "modifiedValue",
            "baseName": "modifiedValue",
            "type": "number"
        }
    ];
    return TrackingReminderNotificationPost;
}());
exports.TrackingReminderNotificationPost = TrackingReminderNotificationPost;
var TrackingReminderNotificationTrackAllAction = /** @class */ (function () {
    function TrackingReminderNotificationTrackAllAction() {
    }
    TrackingReminderNotificationTrackAllAction.getAttributeTypeMap = function () {
        return TrackingReminderNotificationTrackAllAction.attributeTypeMap;
    };
    TrackingReminderNotificationTrackAllAction.discriminator = undefined;
    TrackingReminderNotificationTrackAllAction.attributeTypeMap = [
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "callback",
            "baseName": "callback",
            "type": "string"
        },
        {
            "name": "modifiedValue",
            "baseName": "modifiedValue",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }
    ];
    return TrackingReminderNotificationTrackAllAction;
}());
exports.TrackingReminderNotificationTrackAllAction = TrackingReminderNotificationTrackAllAction;
var Unit = /** @class */ (function () {
    function Unit() {
    }
    Unit.getAttributeTypeMap = function () {
        return Unit.attributeTypeMap;
    };
    Unit.discriminator = undefined;
    Unit.attributeTypeMap = [
        {
            "name": "abbreviatedName",
            "baseName": "abbreviatedName",
            "type": "string"
        },
        {
            "name": "advanced",
            "baseName": "advanced",
            "type": "number"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "number"
        },
        {
            "name": "categoryName",
            "baseName": "categoryName",
            "type": "string"
        },
        {
            "name": "conversionSteps",
            "baseName": "conversionSteps",
            "type": "Array<ConversionStep>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "manualTracking",
            "baseName": "manualTracking",
            "type": "number"
        },
        {
            "name": "maximumAllowedValue",
            "baseName": "maximumAllowedValue",
            "type": "number"
        },
        {
            "name": "maximumValue",
            "baseName": "maximumValue",
            "type": "number"
        },
        {
            "name": "minimumAllowedValue",
            "baseName": "minimumAllowedValue",
            "type": "number"
        },
        {
            "name": "minimumValue",
            "baseName": "minimumValue",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "unitCategory",
            "baseName": "unitCategory",
            "type": "UnitCategory"
        }
    ];
    return Unit;
}());
exports.Unit = Unit;
var UnitCategory = /** @class */ (function () {
    function UnitCategory() {
    }
    UnitCategory.getAttributeTypeMap = function () {
        return UnitCategory.attributeTypeMap;
    };
    UnitCategory.discriminator = undefined;
    UnitCategory.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "standardUnitAbbreviatedName",
            "baseName": "standardUnitAbbreviatedName",
            "type": "string"
        }
    ];
    return UnitCategory;
}());
exports.UnitCategory = UnitCategory;
var User = /** @class */ (function () {
    function User() {
    }
    User.getAttributeTypeMap = function () {
        return User.attributeTypeMap;
    };
    User.discriminator = undefined;
    User.attributeTypeMap = [
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        },
        {
            "name": "accessTokenExpires",
            "baseName": "accessTokenExpires",
            "type": "string"
        },
        {
            "name": "accessTokenExpiresAtMilliseconds",
            "baseName": "accessTokenExpiresAtMilliseconds",
            "type": "number"
        },
        {
            "name": "administrator",
            "baseName": "administrator",
            "type": "boolean"
        },
        {
            "name": "authorizedClients",
            "baseName": "authorizedClients",
            "type": "AuthorizedClients"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "avatarImage",
            "baseName": "avatarImage",
            "type": "string"
        },
        {
            "name": "capabilities",
            "baseName": "capabilities",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "clientUserId",
            "baseName": "clientUserId",
            "type": "string"
        },
        {
            "name": "combineNotifications",
            "baseName": "combineNotifications",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "earliestReminderTime",
            "baseName": "earliestReminderTime",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "getPreviewBuilds",
            "baseName": "getPreviewBuilds",
            "type": "boolean"
        },
        {
            "name": "hasAndroidApp",
            "baseName": "hasAndroidApp",
            "type": "boolean"
        },
        {
            "name": "hasChromeExtension",
            "baseName": "hasChromeExtension",
            "type": "boolean"
        },
        {
            "name": "hasIosApp",
            "baseName": "hasIosApp",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "lastActive",
            "baseName": "lastActive",
            "type": "string"
        },
        {
            "name": "lastFour",
            "baseName": "lastFour",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "lastSmsTrackingReminderNotificationId",
            "baseName": "lastSmsTrackingReminderNotificationId",
            "type": "string"
        },
        {
            "name": "latestReminderTime",
            "baseName": "latestReminderTime",
            "type": "string"
        },
        {
            "name": "loginName",
            "baseName": "loginName",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "phoneVerificationCode",
            "baseName": "phoneVerificationCode",
            "type": "string"
        },
        {
            "name": "primaryOutcomeVariableId",
            "baseName": "primaryOutcomeVariableId",
            "type": "number"
        },
        {
            "name": "primaryOutcomeVariableName",
            "baseName": "primaryOutcomeVariableName",
            "type": "string"
        },
        {
            "name": "pushNotificationsEnabled",
            "baseName": "pushNotificationsEnabled",
            "type": "boolean"
        },
        {
            "name": "refreshToken",
            "baseName": "refreshToken",
            "type": "string"
        },
        {
            "name": "roles",
            "baseName": "roles",
            "type": "string"
        },
        {
            "name": "sendPredictorEmails",
            "baseName": "sendPredictorEmails",
            "type": "boolean"
        },
        {
            "name": "sendReminderNotificationEmails",
            "baseName": "sendReminderNotificationEmails",
            "type": "boolean"
        },
        {
            "name": "shareAllData",
            "baseName": "shareAllData",
            "type": "boolean"
        },
        {
            "name": "smsNotificationsEnabled",
            "baseName": "smsNotificationsEnabled",
            "type": "boolean"
        },
        {
            "name": "stripeActive",
            "baseName": "stripeActive",
            "type": "boolean"
        },
        {
            "name": "stripeId",
            "baseName": "stripeId",
            "type": "string"
        },
        {
            "name": "stripePlan",
            "baseName": "stripePlan",
            "type": "string"
        },
        {
            "name": "stripeSubscription",
            "baseName": "stripeSubscription",
            "type": "string"
        },
        {
            "name": "subscriptionEndsAt",
            "baseName": "subscriptionEndsAt",
            "type": "string"
        },
        {
            "name": "subscriptionProvider",
            "baseName": "subscriptionProvider",
            "type": "string"
        },
        {
            "name": "timeZoneOffset",
            "baseName": "timeZoneOffset",
            "type": "number"
        },
        {
            "name": "trackLocation",
            "baseName": "trackLocation",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "string"
        },
        {
            "name": "userRegistered",
            "baseName": "userRegistered",
            "type": "string"
        },
        {
            "name": "userUrl",
            "baseName": "userUrl",
            "type": "string"
        }
    ];
    return User;
}());
exports.User = User;
var UserBlog = /** @class */ (function () {
    function UserBlog() {
    }
    UserBlog.getAttributeTypeMap = function () {
        return UserBlog.attributeTypeMap;
    };
    UserBlog.discriminator = undefined;
    UserBlog.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "blogId",
            "baseName": "blogId",
            "type": "number"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return UserBlog;
}());
exports.UserBlog = UserBlog;
var UserBlogsResponse = /** @class */ (function () {
    function UserBlogsResponse() {
    }
    UserBlogsResponse.getAttributeTypeMap = function () {
        return UserBlogsResponse.attributeTypeMap;
    };
    UserBlogsResponse.discriminator = undefined;
    UserBlogsResponse.attributeTypeMap = [
        {
            "name": "userBlogs",
            "baseName": "userBlogs",
            "type": "Array<UserBlog>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return UserBlogsResponse;
}());
exports.UserBlogsResponse = UserBlogsResponse;
var UserTag = /** @class */ (function () {
    function UserTag() {
    }
    UserTag.getAttributeTypeMap = function () {
        return UserTag.attributeTypeMap;
    };
    UserTag.discriminator = undefined;
    UserTag.attributeTypeMap = [
        {
            "name": "conversionFactor",
            "baseName": "conversionFactor",
            "type": "number"
        },
        {
            "name": "taggedVariableId",
            "baseName": "taggedVariableId",
            "type": "number"
        },
        {
            "name": "tagVariableId",
            "baseName": "tagVariableId",
            "type": "number"
        }
    ];
    return UserTag;
}());
exports.UserTag = UserTag;
var UserVariableDelete = /** @class */ (function () {
    function UserVariableDelete() {
    }
    UserVariableDelete.getAttributeTypeMap = function () {
        return UserVariableDelete.attributeTypeMap;
    };
    UserVariableDelete.discriminator = undefined;
    UserVariableDelete.attributeTypeMap = [
        {
            "name": "variableId",
            "baseName": "variableId",
            "type": "number"
        }
    ];
    return UserVariableDelete;
}());
exports.UserVariableDelete = UserVariableDelete;
var UsersResponse = /** @class */ (function () {
    function UsersResponse() {
    }
    UsersResponse.getAttributeTypeMap = function () {
        return UsersResponse.attributeTypeMap;
    };
    UsersResponse.discriminator = undefined;
    UsersResponse.attributeTypeMap = [
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<User>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return UsersResponse;
}());
exports.UsersResponse = UsersResponse;
var Variable = /** @class */ (function () {
    function Variable() {
    }
    Variable.getAttributeTypeMap = function () {
        return Variable.attributeTypeMap;
    };
    Variable.discriminator = undefined;
    Variable.attributeTypeMap = [
        {
            "name": "actionArray",
            "baseName": "actionArray",
            "type": "Array<TrackingReminderNotificationAction>"
        },
        {
            "name": "alias",
            "baseName": "alias",
            "type": "string"
        },
        {
            "name": "availableUnits",
            "baseName": "availableUnits",
            "type": "Array<Unit>"
        },
        {
            "name": "bestStudyLink",
            "baseName": "bestStudyLink",
            "type": "string"
        },
        {
            "name": "bestStudyCard",
            "baseName": "bestStudyCard",
            "type": "Card"
        },
        {
            "name": "bestUserStudyLink",
            "baseName": "bestUserStudyLink",
            "type": "string"
        },
        {
            "name": "bestUserStudyCard",
            "baseName": "bestUserStudyCard",
            "type": "Card"
        },
        {
            "name": "bestPopulationStudyLink",
            "baseName": "bestPopulationStudyLink",
            "type": "string"
        },
        {
            "name": "bestPopulationStudyCard",
            "baseName": "bestPopulationStudyCard",
            "type": "Card"
        },
        {
            "name": "optimalValueMessage",
            "baseName": "optimalValueMessage",
            "type": "string"
        },
        {
            "name": "commonOptimalValueMessage",
            "baseName": "commonOptimalValueMessage",
            "type": "string"
        },
        {
            "name": "userOptimalValueMessage",
            "baseName": "userOptimalValueMessage",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        },
        {
            "name": "causeOnly",
            "baseName": "causeOnly",
            "type": "boolean"
        },
        {
            "name": "charts",
            "baseName": "charts",
            "type": "VariableCharts"
        },
        {
            "name": "chartsLinkDynamic",
            "baseName": "chartsLinkDynamic",
            "type": "string"
        },
        {
            "name": "chartsLinkEmail",
            "baseName": "chartsLinkEmail",
            "type": "string"
        },
        {
            "name": "chartsLinkFacebook",
            "baseName": "chartsLinkFacebook",
            "type": "string"
        },
        {
            "name": "chartsLinkGoogle",
            "baseName": "chartsLinkGoogle",
            "type": "string"
        },
        {
            "name": "chartsLinkStatic",
            "baseName": "chartsLinkStatic",
            "type": "string"
        },
        {
            "name": "chartsLinkTwitter",
            "baseName": "chartsLinkTwitter",
            "type": "string"
        },
        {
            "name": "childCommonTagVariables",
            "baseName": "childCommonTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "childUserTagVariables",
            "baseName": "childUserTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "combinationOperation",
            "baseName": "combinationOperation",
            "type": "string"
        },
        {
            "name": "commonAlias",
            "baseName": "commonAlias",
            "type": "string"
        },
        {
            "name": "commonTaggedVariables",
            "baseName": "commonTaggedVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "commonTagVariables",
            "baseName": "commonTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "dataSourceNames",
            "baseName": "dataSourceNames",
            "type": "string"
        },
        {
            "name": "dataSources",
            "baseName": "dataSources",
            "type": "Array<DataSource>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "durationOfAction",
            "baseName": "durationOfAction",
            "type": "number"
        },
        {
            "name": "durationOfActionInHours",
            "baseName": "durationOfActionInHours",
            "type": "number"
        },
        {
            "name": "earliestFillingTime",
            "baseName": "earliestFillingTime",
            "type": "number"
        },
        {
            "name": "earliestMeasurementTime",
            "baseName": "earliestMeasurementTime",
            "type": "number"
        },
        {
            "name": "earliestSourceTime",
            "baseName": "earliestSourceTime",
            "type": "number"
        },
        {
            "name": "errorMessage",
            "baseName": "errorMessage",
            "type": "string"
        },
        {
            "name": "experimentEndTime",
            "baseName": "experimentEndTime",
            "type": "string"
        },
        {
            "name": "experimentStartTime",
            "baseName": "experimentStartTime",
            "type": "string"
        },
        {
            "name": "fillingType",
            "baseName": "fillingType",
            "type": "string"
        },
        {
            "name": "fillingValue",
            "baseName": "fillingValue",
            "type": "number"
        },
        {
            "name": "iconIcon",
            "baseName": "iconIcon",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "informationalUrl",
            "baseName": "informationalUrl",
            "type": "string"
        },
        {
            "name": "ingredientOfCommonTagVariables",
            "baseName": "ingredientOfCommonTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "ingredientCommonTagVariables",
            "baseName": "ingredientCommonTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "ingredientOfUserTagVariables",
            "baseName": "ingredientOfUserTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "ingredientUserTagVariables",
            "baseName": "ingredientUserTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "inputType",
            "baseName": "inputType",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "joinedCommonTagVariables",
            "baseName": "joinedCommonTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "joinedUserTagVariables",
            "baseName": "joinedUserTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "joinWith",
            "baseName": "joinWith",
            "type": "number"
        },
        {
            "name": "kurtosis",
            "baseName": "kurtosis",
            "type": "number"
        },
        {
            "name": "lastProcessedDailyValue",
            "baseName": "lastProcessedDailyValue",
            "type": "number"
        },
        {
            "name": "lastSuccessfulUpdateTime",
            "baseName": "lastSuccessfulUpdateTime",
            "type": "string"
        },
        {
            "name": "lastValue",
            "baseName": "lastValue",
            "type": "number"
        },
        {
            "name": "latestFillingTime",
            "baseName": "latestFillingTime",
            "type": "number"
        },
        {
            "name": "latestMeasurementTime",
            "baseName": "latestMeasurementTime",
            "type": "number"
        },
        {
            "name": "latestSourceTime",
            "baseName": "latestSourceTime",
            "type": "number"
        },
        {
            "name": "latestUserMeasurementTime",
            "baseName": "latestUserMeasurementTime",
            "type": "number"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        },
        {
            "name": "manualTracking",
            "baseName": "manualTracking",
            "type": "boolean"
        },
        {
            "name": "maximumAllowedDailyValue",
            "baseName": "maximumAllowedDailyValue",
            "type": "number"
        },
        {
            "name": "maximumAllowedValue",
            "baseName": "maximumAllowedValue",
            "type": "number"
        },
        {
            "name": "maximumRecordedDailyValue",
            "baseName": "maximumRecordedDailyValue",
            "type": "number"
        },
        {
            "name": "maximumRecordedValue",
            "baseName": "maximumRecordedValue",
            "type": "number"
        },
        {
            "name": "mean",
            "baseName": "mean",
            "type": "number"
        },
        {
            "name": "measurementsAtLastAnalysis",
            "baseName": "measurementsAtLastAnalysis",
            "type": "number"
        },
        {
            "name": "median",
            "baseName": "median",
            "type": "number"
        },
        {
            "name": "minimumAllowedValue",
            "baseName": "minimumAllowedValue",
            "type": "number"
        },
        {
            "name": "minimumAllowedDailyValue",
            "baseName": "minimumAllowedDailyValue",
            "type": "number"
        },
        {
            "name": "minimumNonZeroValue",
            "baseName": "minimumNonZeroValue",
            "type": "number"
        },
        {
            "name": "minimumRecordedValue",
            "baseName": "minimumRecordedValue",
            "type": "number"
        },
        {
            "name": "mostCommonConnectorId",
            "baseName": "mostCommonConnectorId",
            "type": "number"
        },
        {
            "name": "mostCommonOriginalUnitId",
            "baseName": "mostCommonOriginalUnitId",
            "type": "number"
        },
        {
            "name": "mostCommonUnitId",
            "baseName": "mostCommonUnitId",
            "type": "number"
        },
        {
            "name": "mostCommonValue",
            "baseName": "mostCommonValue",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "numberOfAggregateCorrelationsAsCause",
            "baseName": "numberOfAggregateCorrelationsAsCause",
            "type": "number"
        },
        {
            "name": "numberOfAggregateCorrelationsAsEffect",
            "baseName": "numberOfAggregateCorrelationsAsEffect",
            "type": "number"
        },
        {
            "name": "numberOfChanges",
            "baseName": "numberOfChanges",
            "type": "number"
        },
        {
            "name": "numberOfCorrelations",
            "baseName": "numberOfCorrelations",
            "type": "number"
        },
        {
            "name": "numberOfCorrelationsAsCause",
            "baseName": "numberOfCorrelationsAsCause",
            "type": "number"
        },
        {
            "name": "numberOfCorrelationsAsEffect",
            "baseName": "numberOfCorrelationsAsEffect",
            "type": "number"
        },
        {
            "name": "numberOfProcessedDailyMeasurements",
            "baseName": "numberOfProcessedDailyMeasurements",
            "type": "number"
        },
        {
            "name": "numberOfRawMeasurements",
            "baseName": "numberOfRawMeasurements",
            "type": "number"
        },
        {
            "name": "numberOfTrackingReminders",
            "baseName": "numberOfTrackingReminders",
            "type": "number"
        },
        {
            "name": "numberOfUniqueDailyValues",
            "baseName": "numberOfUniqueDailyValues",
            "type": "number"
        },
        {
            "name": "numberOfUniqueValues",
            "baseName": "numberOfUniqueValues",
            "type": "number"
        },
        {
            "name": "numberOfUserCorrelationsAsCause",
            "baseName": "numberOfUserCorrelationsAsCause",
            "type": "number"
        },
        {
            "name": "numberOfUserCorrelationsAsEffect",
            "baseName": "numberOfUserCorrelationsAsEffect",
            "type": "number"
        },
        {
            "name": "numberOfUserVariables",
            "baseName": "numberOfUserVariables",
            "type": "number"
        },
        {
            "name": "onsetDelay",
            "baseName": "onsetDelay",
            "type": "number"
        },
        {
            "name": "onsetDelayInHours",
            "baseName": "onsetDelayInHours",
            "type": "number"
        },
        {
            "name": "outcome",
            "baseName": "outcome",
            "type": "boolean"
        },
        {
            "name": "outcomeOfInterest",
            "baseName": "outcomeOfInterest",
            "type": "boolean"
        },
        {
            "name": "parentCommonTagVariables",
            "baseName": "parentCommonTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "parentUserTagVariables",
            "baseName": "parentUserTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "pngPath",
            "baseName": "pngPath",
            "type": "string"
        },
        {
            "name": "pngUrl",
            "baseName": "pngUrl",
            "type": "string"
        },
        {
            "name": "predictorOfInterest",
            "baseName": "predictorOfInterest",
            "type": "number"
        },
        {
            "name": "price",
            "baseName": "price",
            "type": "number"
        },
        {
            "name": "productUrl",
            "baseName": "productUrl",
            "type": "string"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        },
        {
            "name": "question",
            "baseName": "question",
            "type": "string"
        },
        {
            "name": "longQuestion",
            "baseName": "longQuestion",
            "type": "string"
        },
        {
            "name": "rawMeasurementsAtLastAnalysis",
            "baseName": "rawMeasurementsAtLastAnalysis",
            "type": "number"
        },
        {
            "name": "secondMostCommonValue",
            "baseName": "secondMostCommonValue",
            "type": "number"
        },
        {
            "name": "secondToLastValue",
            "baseName": "secondToLastValue",
            "type": "number"
        },
        {
            "name": "shareUserMeasurements",
            "baseName": "shareUserMeasurements",
            "type": "boolean"
        },
        {
            "name": "skewness",
            "baseName": "skewness",
            "type": "number"
        },
        {
            "name": "standardDeviation",
            "baseName": "standardDeviation",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "subtitle",
            "baseName": "subtitle",
            "type": "string"
        },
        {
            "name": "svgUrl",
            "baseName": "svgUrl",
            "type": "string"
        },
        {
            "name": "thirdMostCommonValue",
            "baseName": "thirdMostCommonValue",
            "type": "number"
        },
        {
            "name": "thirdToLastValue",
            "baseName": "thirdToLastValue",
            "type": "number"
        },
        {
            "name": "trackingInstructions",
            "baseName": "trackingInstructions",
            "type": "string"
        },
        {
            "name": "trackingInstructionsCard",
            "baseName": "trackingInstructionsCard",
            "type": "Card"
        },
        {
            "name": "unit",
            "baseName": "unit",
            "type": "Unit"
        },
        {
            "name": "unitAbbreviatedName",
            "baseName": "unitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "unitCategoryId",
            "baseName": "unitCategoryId",
            "type": "number"
        },
        {
            "name": "unitCategoryName",
            "baseName": "unitCategoryName",
            "type": "string"
        },
        {
            "name": "unitId",
            "baseName": "unitId",
            "type": "number"
        },
        {
            "name": "unitName",
            "baseName": "unitName",
            "type": "string"
        },
        {
            "name": "upc",
            "baseName": "upc",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "string"
        },
        {
            "name": "updatedTime",
            "baseName": "updatedTime",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "userTaggedVariables",
            "baseName": "userTaggedVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "userTagVariables",
            "baseName": "userTagVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "userVariableUnitAbbreviatedName",
            "baseName": "userVariableUnitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "userVariableUnitCategoryId",
            "baseName": "userVariableUnitCategoryId",
            "type": "number"
        },
        {
            "name": "userVariableUnitCategoryName",
            "baseName": "userVariableUnitCategoryName",
            "type": "string"
        },
        {
            "name": "userVariableUnitId",
            "baseName": "userVariableUnitId",
            "type": "number"
        },
        {
            "name": "userVariableUnitName",
            "baseName": "userVariableUnitName",
            "type": "string"
        },
        {
            "name": "variableCategory",
            "baseName": "variableCategory",
            "type": "VariableCategory"
        },
        {
            "name": "joinedVariables",
            "baseName": "joinedVariables",
            "type": "Array<Variable>"
        },
        {
            "name": "valence",
            "baseName": "valence",
            "type": "string"
        },
        {
            "name": "variableCategoryId",
            "baseName": "variableCategoryId",
            "type": "number"
        },
        {
            "name": "variableCategoryName",
            "baseName": "variableCategoryName",
            "type": "string"
        },
        {
            "name": "variableId",
            "baseName": "variableId",
            "type": "number"
        },
        {
            "name": "variableName",
            "baseName": "variableName",
            "type": "string"
        },
        {
            "name": "variance",
            "baseName": "variance",
            "type": "number"
        },
        {
            "name": "wikipediaTitle",
            "baseName": "wikipediaTitle",
            "type": "string"
        }
    ];
    return Variable;
}());
exports.Variable = Variable;
var VariableCategory = /** @class */ (function () {
    function VariableCategory() {
    }
    VariableCategory.getAttributeTypeMap = function () {
        return VariableCategory.attributeTypeMap;
    };
    VariableCategory.discriminator = undefined;
    VariableCategory.attributeTypeMap = [
        {
            "name": "appType",
            "baseName": "appType",
            "type": "string"
        },
        {
            "name": "causeOnly",
            "baseName": "causeOnly",
            "type": "boolean"
        },
        {
            "name": "combinationOperation",
            "baseName": "combinationOperation",
            "type": "string"
        },
        {
            "name": "createdTime",
            "baseName": "createdTime",
            "type": "string"
        },
        {
            "name": "unitAbbreviatedName",
            "baseName": "unitAbbreviatedName",
            "type": "string"
        },
        {
            "name": "unitId",
            "baseName": "unitId",
            "type": "number"
        },
        {
            "name": "durationOfAction",
            "baseName": "durationOfAction",
            "type": "number"
        },
        {
            "name": "fillingValue",
            "baseName": "fillingValue",
            "type": "number"
        },
        {
            "name": "helpText",
            "baseName": "helpText",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "manualTracking",
            "baseName": "manualTracking",
            "type": "boolean"
        },
        {
            "name": "maximumAllowedValue",
            "baseName": "maximumAllowedValue",
            "type": "string"
        },
        {
            "name": "measurementSynonymSingularLowercase",
            "baseName": "measurementSynonymSingularLowercase",
            "type": "string"
        },
        {
            "name": "minimumAllowedValue",
            "baseName": "minimumAllowedValue",
            "type": "string"
        },
        {
            "name": "moreInfo",
            "baseName": "moreInfo",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "onsetDelay",
            "baseName": "onsetDelay",
            "type": "number"
        },
        {
            "name": "outcome",
            "baseName": "outcome",
            "type": "boolean"
        },
        {
            "name": "pngPath",
            "baseName": "pngPath",
            "type": "string"
        },
        {
            "name": "pngUrl",
            "baseName": "pngUrl",
            "type": "string"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        },
        {
            "name": "svgPath",
            "baseName": "svgPath",
            "type": "string"
        },
        {
            "name": "svgUrl",
            "baseName": "svgUrl",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        },
        {
            "name": "updatedTime",
            "baseName": "updatedTime",
            "type": "string"
        },
        {
            "name": "variableCategoryName",
            "baseName": "variableCategoryName",
            "type": "string"
        },
        {
            "name": "variableCategoryNameSingular",
            "baseName": "variableCategoryNameSingular",
            "type": "string"
        }
    ];
    return VariableCategory;
}());
exports.VariableCategory = VariableCategory;
/**
* An object with various chart properties each property contain and svg and Highcharts configuration
*/
var VariableCharts = /** @class */ (function () {
    function VariableCharts() {
    }
    VariableCharts.getAttributeTypeMap = function () {
        return VariableCharts.attributeTypeMap;
    };
    VariableCharts.discriminator = undefined;
    VariableCharts.attributeTypeMap = [
        {
            "name": "hourlyColumnChart",
            "baseName": "hourlyColumnChart",
            "type": "Chart"
        },
        {
            "name": "monthlyColumnChart",
            "baseName": "monthlyColumnChart",
            "type": "Chart"
        },
        {
            "name": "distributionColumnChart",
            "baseName": "distributionColumnChart",
            "type": "Chart"
        },
        {
            "name": "weekdayColumnChart",
            "baseName": "weekdayColumnChart",
            "type": "Chart"
        },
        {
            "name": "lineChartWithoutSmoothing",
            "baseName": "lineChartWithoutSmoothing",
            "type": "Chart"
        },
        {
            "name": "lineChartWithSmoothing",
            "baseName": "lineChartWithSmoothing",
            "type": "Chart"
        }
    ];
    return VariableCharts;
}());
exports.VariableCharts = VariableCharts;
var Vote = /** @class */ (function () {
    function Vote() {
    }
    Vote.getAttributeTypeMap = function () {
        return Vote.attributeTypeMap;
    };
    Vote.discriminator = undefined;
    Vote.attributeTypeMap = [
        {
            "name": "causeVariableId",
            "baseName": "causeVariableId",
            "type": "number"
        },
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "string"
        },
        {
            "name": "effectVariableId",
            "baseName": "effectVariableId",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }
    ];
    return Vote;
}());
exports.Vote = Vote;
var VoteDelete = /** @class */ (function () {
    function VoteDelete() {
    }
    VoteDelete.getAttributeTypeMap = function () {
        return VoteDelete.attributeTypeMap;
    };
    VoteDelete.discriminator = undefined;
    VoteDelete.attributeTypeMap = [
        {
            "name": "cause",
            "baseName": "cause",
            "type": "string"
        },
        {
            "name": "effect",
            "baseName": "effect",
            "type": "string"
        }
    ];
    return VoteDelete;
}());
exports.VoteDelete = VoteDelete;
var XprofileDataResponse = /** @class */ (function () {
    function XprofileDataResponse() {
    }
    XprofileDataResponse.getAttributeTypeMap = function () {
        return XprofileDataResponse.attributeTypeMap;
    };
    XprofileDataResponse.discriminator = undefined;
    XprofileDataResponse.attributeTypeMap = [
        {
            "name": "xprofileData",
            "baseName": "xprofileData",
            "type": "Array<XprofileDatum>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return XprofileDataResponse;
}());
exports.XprofileDataResponse = XprofileDataResponse;
var XprofileDatum = /** @class */ (function () {
    function XprofileDatum() {
    }
    XprofileDatum.getAttributeTypeMap = function () {
        return XprofileDatum.attributeTypeMap;
    };
    XprofileDatum.discriminator = undefined;
    XprofileDatum.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "fieldId",
            "baseName": "fieldId",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "number"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "lastUpdated",
            "baseName": "lastUpdated",
            "type": "string"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return XprofileDatum;
}());
exports.XprofileDatum = XprofileDatum;
var XprofileField = /** @class */ (function () {
    function XprofileField() {
    }
    XprofileField.getAttributeTypeMap = function () {
        return XprofileField.attributeTypeMap;
    };
    XprofileField.discriminator = undefined;
    XprofileField.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "number"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "isRequired",
            "baseName": "isRequired",
            "type": "number"
        },
        {
            "name": "isDefaultOption",
            "baseName": "isDefaultOption",
            "type": "number"
        },
        {
            "name": "fieldOrder",
            "baseName": "fieldOrder",
            "type": "number"
        },
        {
            "name": "optionOrder",
            "baseName": "optionOrder",
            "type": "number"
        },
        {
            "name": "orderBy",
            "baseName": "orderBy",
            "type": "string"
        },
        {
            "name": "canDelete",
            "baseName": "canDelete",
            "type": "number"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return XprofileField;
}());
exports.XprofileField = XprofileField;
var XprofileFieldsResponse = /** @class */ (function () {
    function XprofileFieldsResponse() {
    }
    XprofileFieldsResponse.getAttributeTypeMap = function () {
        return XprofileFieldsResponse.attributeTypeMap;
    };
    XprofileFieldsResponse.discriminator = undefined;
    XprofileFieldsResponse.attributeTypeMap = [
        {
            "name": "xprofileFields",
            "baseName": "xprofileFields",
            "type": "Array<XprofileField>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return XprofileFieldsResponse;
}());
exports.XprofileFieldsResponse = XprofileFieldsResponse;
var XprofileGroup = /** @class */ (function () {
    function XprofileGroup() {
    }
    XprofileGroup.getAttributeTypeMap = function () {
        return XprofileGroup.attributeTypeMap;
    };
    XprofileGroup.discriminator = undefined;
    XprofileGroup.attributeTypeMap = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "groupOrder",
            "baseName": "groupOrder",
            "type": "number"
        },
        {
            "name": "canDelete",
            "baseName": "canDelete",
            "type": "number"
        },
        {
            "name": "metaDataArray",
            "baseName": "metaDataArray",
            "type": "Array<any>"
        }
    ];
    return XprofileGroup;
}());
exports.XprofileGroup = XprofileGroup;
var XprofileGroupsResponse = /** @class */ (function () {
    function XprofileGroupsResponse() {
    }
    XprofileGroupsResponse.getAttributeTypeMap = function () {
        return XprofileGroupsResponse.attributeTypeMap;
    };
    XprofileGroupsResponse.discriminator = undefined;
    XprofileGroupsResponse.attributeTypeMap = [
        {
            "name": "xprofileGroups",
            "baseName": "xprofileGroups",
            "type": "Array<XprofileGroup>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "summary",
            "baseName": "summary",
            "type": "string"
        },
        {
            "name": "image",
            "baseName": "image",
            "type": "Image"
        },
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "string"
        },
        {
            "name": "ionIcon",
            "baseName": "ionIcon",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Card"
        }
    ];
    return XprofileGroupsResponse;
}());
exports.XprofileGroupsResponse = XprofileGroupsResponse;
var enumsMap = {};
var typeMap = {
    "ActivitiesResponse": ActivitiesResponse,
    "Activity": Activity,
    "AppSettings": AppSettings,
    "AppSettingsResponse": AppSettingsResponse,
    "AuthorizedClients": AuthorizedClients,
    "Button": Button,
    "Card": Card,
    "Chart": Chart,
    "CommonResponse": CommonResponse,
    "ConnectInstructions": ConnectInstructions,
    "ConversionStep": ConversionStep,
    "Correlation": Correlation,
    "DataSource": DataSource,
    "DeviceToken": DeviceToken,
    "Explanation": Explanation,
    "ExplanationStartTracking": ExplanationStartTracking,
    "FeedResponse": FeedResponse,
    "Friend": Friend,
    "FriendsResponse": FriendsResponse,
    "GetConnectorsResponse": GetConnectorsResponse,
    "GetCorrelationsDataResponse": GetCorrelationsDataResponse,
    "GetCorrelationsResponse": GetCorrelationsResponse,
    "GetSharesResponse": GetSharesResponse,
    "GetStudiesResponse": GetStudiesResponse,
    "GetTrackingReminderNotificationsResponse": GetTrackingReminderNotificationsResponse,
    "Group": Group,
    "GroupsMember": GroupsMember,
    "GroupsMembersResponse": GroupsMembersResponse,
    "GroupsResponse": GroupsResponse,
    "Image": Image,
    "InputField": InputField,
    "JsonErrorResponse": JsonErrorResponse,
    "Measurement": Measurement,
    "MeasurementDelete": MeasurementDelete,
    "MeasurementItem": MeasurementItem,
    "MeasurementSet": MeasurementSet,
    "MeasurementUpdate": MeasurementUpdate,
    "MessagesMessage": MessagesMessage,
    "MessagesMessagesResponse": MessagesMessagesResponse,
    "MessagesNotice": MessagesNotice,
    "MessagesNoticesResponse": MessagesNoticesResponse,
    "MessagesRecipient": MessagesRecipient,
    "MessagesRecipientsResponse": MessagesRecipientsResponse,
    "ModelError": ModelError,
    "Notification": Notification,
    "NotificationsResponse": NotificationsResponse,
    "Pair": Pair,
    "ParticipantInstruction": ParticipantInstruction,
    "PostMeasurementsDataResponse": PostMeasurementsDataResponse,
    "PostMeasurementsResponse": PostMeasurementsResponse,
    "PostStudyCreateResponse": PostStudyCreateResponse,
    "PostStudyPublishResponse": PostStudyPublishResponse,
    "PostTrackingRemindersDataResponse": PostTrackingRemindersDataResponse,
    "PostTrackingRemindersResponse": PostTrackingRemindersResponse,
    "PostUserSettingsDataResponse": PostUserSettingsDataResponse,
    "PostUserSettingsResponse": PostUserSettingsResponse,
    "ShareInvitationBody": ShareInvitationBody,
    "Study": Study,
    "StudyCharts": StudyCharts,
    "StudyCreationBody": StudyCreationBody,
    "StudyHtml": StudyHtml,
    "StudyImages": StudyImages,
    "StudyJoinResponse": StudyJoinResponse,
    "StudyLinks": StudyLinks,
    "StudySharing": StudySharing,
    "StudyText": StudyText,
    "StudyVotes": StudyVotes,
    "TrackingReminder": TrackingReminder,
    "TrackingReminderDelete": TrackingReminderDelete,
    "TrackingReminderNotification": TrackingReminderNotification,
    "TrackingReminderNotificationAction": TrackingReminderNotificationAction,
    "TrackingReminderNotificationPost": TrackingReminderNotificationPost,
    "TrackingReminderNotificationTrackAllAction": TrackingReminderNotificationTrackAllAction,
    "Unit": Unit,
    "UnitCategory": UnitCategory,
    "User": User,
    "UserBlog": UserBlog,
    "UserBlogsResponse": UserBlogsResponse,
    "UserTag": UserTag,
    "UserVariableDelete": UserVariableDelete,
    "UsersResponse": UsersResponse,
    "Variable": Variable,
    "VariableCategory": VariableCategory,
    "VariableCharts": VariableCharts,
    "Vote": Vote,
    "VoteDelete": VoteDelete,
    "XprofileDataResponse": XprofileDataResponse,
    "XprofileDatum": XprofileDatum,
    "XprofileField": XprofileField,
    "XprofileFieldsResponse": XprofileFieldsResponse,
    "XprofileGroup": XprofileGroup,
    "XprofileGroupsResponse": XprofileGroupsResponse,
};
var HttpBasicAuth = /** @class */ (function () {
    function HttpBasicAuth() {
        this.username = '';
        this.password = '';
    }
    HttpBasicAuth.prototype.applyToRequest = function (requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    };
    return HttpBasicAuth;
}());
exports.HttpBasicAuth = HttpBasicAuth;
var ApiKeyAuth = /** @class */ (function () {
    function ApiKeyAuth(location, paramName) {
        this.location = location;
        this.paramName = paramName;
        this.apiKey = '';
    }
    ApiKeyAuth.prototype.applyToRequest = function (requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    };
    return ApiKeyAuth;
}());
exports.ApiKeyAuth = ApiKeyAuth;
var OAuth = /** @class */ (function () {
    function OAuth() {
        this.accessToken = '';
    }
    OAuth.prototype.applyToRequest = function (requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    };
    return OAuth;
}());
exports.OAuth = OAuth;
var VoidAuth = /** @class */ (function () {
    function VoidAuth() {
        this.username = '';
        this.password = '';
    }
    VoidAuth.prototype.applyToRequest = function (_) {
        // Do nothing
    };
    return VoidAuth;
}());
exports.VoidAuth = VoidAuth;
var ActivitiesApiApiKeys;
(function (ActivitiesApiApiKeys) {
    ActivitiesApiApiKeys[ActivitiesApiApiKeys["access_token"] = 0] = "access_token";
    ActivitiesApiApiKeys[ActivitiesApiApiKeys["client_id"] = 1] = "client_id";
})(ActivitiesApiApiKeys = exports.ActivitiesApiApiKeys || (exports.ActivitiesApiApiKeys = {}));
var ActivitiesApi = /** @class */ (function () {
    function ActivitiesApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(ActivitiesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivitiesApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    ActivitiesApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    ActivitiesApi.prototype.setApiKey = function (key, value) {
        this.authentications[ActivitiesApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(ActivitiesApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get Activities
     * @summary Get Activities
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    ActivitiesApi.prototype.getActivities = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/activities';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<ActivitiesResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post Activities
     * @summary Post Activities
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    ActivitiesApi.prototype.postActivities = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/activities';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<ActivitiesResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return ActivitiesApi;
}());
exports.ActivitiesApi = ActivitiesApi;
var AnalyticsApiApiKeys;
(function (AnalyticsApiApiKeys) {
    AnalyticsApiApiKeys[AnalyticsApiApiKeys["access_token"] = 0] = "access_token";
    AnalyticsApiApiKeys[AnalyticsApiApiKeys["client_id"] = 1] = "client_id";
})(AnalyticsApiApiKeys = exports.AnalyticsApiApiKeys || (exports.AnalyticsApiApiKeys = {}));
var AnalyticsApi = /** @class */ (function () {
    function AnalyticsApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(AnalyticsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnalyticsApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    AnalyticsApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    AnalyticsApi.prototype.setApiKey = function (key, value) {
        this.authentications[AnalyticsApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(AnalyticsApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get explanations of  correlations based on data from a single user.
     * @summary Get correlation explanations
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {*} [options] Override http request options.
     */
    AnalyticsApi.prototype.getCorrelationExplanations = function (causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/correlations/explanations';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (causeVariableName !== undefined) {
            localVarQueryParameters['causeVariableName'] = ObjectSerializer.serialize(causeVariableName, "string");
        }
        if (effectVariableName !== undefined) {
            localVarQueryParameters['effectVariableName'] = ObjectSerializer.serialize(effectVariableName, "string");
        }
        if (causeVariableId !== undefined) {
            localVarQueryParameters['causeVariableId'] = ObjectSerializer.serialize(causeVariableId, "number");
        }
        if (effectVariableId !== undefined) {
            localVarQueryParameters['effectVariableId'] = ObjectSerializer.serialize(effectVariableId, "number");
        }
        if (predictorVariableName !== undefined) {
            localVarQueryParameters['predictorVariableName'] = ObjectSerializer.serialize(predictorVariableName, "string");
        }
        if (outcomeVariableName !== undefined) {
            localVarQueryParameters['outcomeVariableName'] = ObjectSerializer.serialize(outcomeVariableName, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<Correlation>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
     * @summary Get correlations
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param userId User&#39;s id
     * @param correlationCoefficient Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param outcomesOfInterest Only include correlations for which the effect is an outcome of interest for the user
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param commonOnly Return only public, anonymized and aggregated population data instead of user-specific variables
     * @param {*} [options] Override http request options.
     */
    AnalyticsApi.prototype.getCorrelations = function (causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/correlations';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (causeVariableName !== undefined) {
            localVarQueryParameters['causeVariableName'] = ObjectSerializer.serialize(causeVariableName, "string");
        }
        if (effectVariableName !== undefined) {
            localVarQueryParameters['effectVariableName'] = ObjectSerializer.serialize(effectVariableName, "string");
        }
        if (causeVariableId !== undefined) {
            localVarQueryParameters['causeVariableId'] = ObjectSerializer.serialize(causeVariableId, "number");
        }
        if (effectVariableId !== undefined) {
            localVarQueryParameters['effectVariableId'] = ObjectSerializer.serialize(effectVariableId, "number");
        }
        if (predictorVariableName !== undefined) {
            localVarQueryParameters['predictorVariableName'] = ObjectSerializer.serialize(predictorVariableName, "string");
        }
        if (outcomeVariableName !== undefined) {
            localVarQueryParameters['outcomeVariableName'] = ObjectSerializer.serialize(outcomeVariableName, "string");
        }
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (correlationCoefficient !== undefined) {
            localVarQueryParameters['correlationCoefficient'] = ObjectSerializer.serialize(correlationCoefficient, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (outcomesOfInterest !== undefined) {
            localVarQueryParameters['outcomesOfInterest'] = ObjectSerializer.serialize(outcomesOfInterest, "boolean");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (commonOnly !== undefined) {
            localVarQueryParameters['commonOnly'] = ObjectSerializer.serialize(commonOnly, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetCorrelationsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return AnalyticsApi;
}());
exports.AnalyticsApi = AnalyticsApi;
var AppSettingsApiApiKeys;
(function (AppSettingsApiApiKeys) {
    AppSettingsApiApiKeys[AppSettingsApiApiKeys["access_token"] = 0] = "access_token";
    AppSettingsApiApiKeys[AppSettingsApiApiKeys["client_id"] = 1] = "client_id";
})(AppSettingsApiApiKeys = exports.AppSettingsApiApiKeys || (exports.AppSettingsApiApiKeys = {}));
var AppSettingsApi = /** @class */ (function () {
    function AppSettingsApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(AppSettingsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AppSettingsApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    AppSettingsApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    AppSettingsApi.prototype.setApiKey = function (key, value) {
        this.authentications[AppSettingsApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(AppSettingsApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the settings for your application configurable at https://build.quantimo.do
     * @summary Get client app settings
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param clientSecret This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param {*} [options] Override http request options.
     */
    AppSettingsApi.prototype.getAppSettings = function (clientId, clientSecret, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/appSettings';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (clientSecret !== undefined) {
            localVarQueryParameters['client_secret'] = ObjectSerializer.serialize(clientSecret, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "AppSettingsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return AppSettingsApi;
}());
exports.AppSettingsApi = AppSettingsApi;
var AuthenticationApiApiKeys;
(function (AuthenticationApiApiKeys) {
    AuthenticationApiApiKeys[AuthenticationApiApiKeys["access_token"] = 0] = "access_token";
    AuthenticationApiApiKeys[AuthenticationApiApiKeys["client_id"] = 1] = "client_id";
})(AuthenticationApiApiKeys = exports.AuthenticationApiApiKeys || (exports.AuthenticationApiApiKeys = {}));
var AuthenticationApi = /** @class */ (function () {
    function AuthenticationApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(AuthenticationApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AuthenticationApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    AuthenticationApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    AuthenticationApi.prototype.setApiKey = function (key, value) {
        this.authentications[AuthenticationApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(AuthenticationApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)
     * @summary Get a user access token
     * @param grantType Grant Type can be &#39;authorization_code&#39; or &#39;refresh_token&#39;
     * @param code Authorization code you received with the previous request.
     * @param responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
     * @param scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param clientSecret This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param redirectUri The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
     * @param state An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
     * @param {*} [options] Override http request options.
     */
    AuthenticationApi.prototype.getAccessToken = function (grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/oauth2/token';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'grantType' is not null or undefined
        if (grantType === null || grantType === undefined) {
            throw new Error('Required parameter grantType was null or undefined when calling getAccessToken.');
        }
        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getAccessToken.');
        }
        // verify required parameter 'responseType' is not null or undefined
        if (responseType === null || responseType === undefined) {
            throw new Error('Required parameter responseType was null or undefined when calling getAccessToken.');
        }
        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getAccessToken.');
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (clientSecret !== undefined) {
            localVarQueryParameters['client_secret'] = ObjectSerializer.serialize(clientSecret, "string");
        }
        if (grantType !== undefined) {
            localVarQueryParameters['grant_type'] = ObjectSerializer.serialize(grantType, "string");
        }
        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }
        if (responseType !== undefined) {
            localVarQueryParameters['response_type'] = ObjectSerializer.serialize(responseType, "string");
        }
        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "string");
        }
        if (redirectUri !== undefined) {
            localVarQueryParameters['redirect_uri'] = ObjectSerializer.serialize(redirectUri, "string");
        }
        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
     * @summary Request Authorization Code
     * @param responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
     * @param scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param clientSecret This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param redirectUri The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
     * @param state An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
     * @param {*} [options] Override http request options.
     */
    AuthenticationApi.prototype.getOauthAuthorizationCode = function (responseType, scope, clientId, clientSecret, redirectUri, state, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/oauth2/authorize';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'responseType' is not null or undefined
        if (responseType === null || responseType === undefined) {
            throw new Error('Required parameter responseType was null or undefined when calling getOauthAuthorizationCode.');
        }
        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getOauthAuthorizationCode.');
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (clientSecret !== undefined) {
            localVarQueryParameters['client_secret'] = ObjectSerializer.serialize(clientSecret, "string");
        }
        if (responseType !== undefined) {
            localVarQueryParameters['response_type'] = ObjectSerializer.serialize(responseType, "string");
        }
        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "string");
        }
        if (redirectUri !== undefined) {
            localVarQueryParameters['redirect_uri'] = ObjectSerializer.serialize(redirectUri, "string");
        }
        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post GoogleIdToken
     * @summary Post GoogleIdToken
     * @param {*} [options] Override http request options.
     */
    AuthenticationApi.prototype.postGoogleIdToken = function (options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/googleIdToken';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return AuthenticationApi;
}());
exports.AuthenticationApi = AuthenticationApi;
var ConnectorsApiApiKeys;
(function (ConnectorsApiApiKeys) {
    ConnectorsApiApiKeys[ConnectorsApiApiKeys["access_token"] = 0] = "access_token";
    ConnectorsApiApiKeys[ConnectorsApiApiKeys["client_id"] = 1] = "client_id";
})(ConnectorsApiApiKeys = exports.ConnectorsApiApiKeys || (exports.ConnectorsApiApiKeys = {}));
var ConnectorsApi = /** @class */ (function () {
    function ConnectorsApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(ConnectorsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectorsApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    ConnectorsApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    ConnectorsApi.prototype.setApiKey = function (key, value) {
        this.authentications[ConnectorsApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(ConnectorsApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
     * @summary Obtain a token from 3rd party data source
     * @param connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
     * @param userId User&#39;s id
     * @param {*} [options] Override http request options.
     */
    ConnectorsApi.prototype.connectConnector = function (connectorName, userId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/connectors/{connectorName}/connect'
            .replace('{' + 'connectorName' + '}', encodeURIComponent(String(connectorName)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'connectorName' is not null or undefined
        if (connectorName === null || connectorName === undefined) {
            throw new Error('Required parameter connectorName was null or undefined when calling connectConnector.');
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * The disconnect method deletes any stored tokens or connection information from the connectors database.
     * @summary Delete stored connection info
     * @param connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
     * @param {*} [options] Override http request options.
     */
    ConnectorsApi.prototype.disconnectConnector = function (connectorName, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/connectors/{connectorName}/disconnect'
            .replace('{' + 'connectorName' + '}', encodeURIComponent(String(connectorName)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'connectorName' is not null or undefined
        if (connectorName === null || connectorName === undefined) {
            throw new Error('Required parameter connectorName was null or undefined when calling disconnectConnector.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
     * @summary List of Connectors
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    ConnectorsApi.prototype.getConnectors = function (clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/connectors/list';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetConnectorsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get embeddable connect javascript. Usage:   - Embedding in applications with popups for 3rd-party authentication windows.     Use `qmSetupInPopup` function after connecting `connect.js`.   - Embedding in applications with popups for 3rd-party authentication windows.     Requires a selector to block. It will be embedded in this block.     Use `qmSetupOnPage` function after connecting `connect.js`.   - Embedding in mobile applications without popups for 3rd-party authentication.     Use `qmSetupOnMobile` function after connecting `connect.js`.     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
     * @summary Get embeddable connect javascript
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    ConnectorsApi.prototype.getIntegrationJs = function (clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/integration.js';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v3/connect/mobile?access_token=123
     * @summary Mobile connect page
     * @param userId User&#39;s id
     * @param {*} [options] Override http request options.
     */
    ConnectorsApi.prototype.getMobileConnectPage = function (userId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/connect/mobile';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
     * @summary Sync with data source
     * @param connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
     * @param userId User&#39;s id
     * @param {*} [options] Override http request options.
     */
    ConnectorsApi.prototype.updateConnector = function (connectorName, userId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/connectors/{connectorName}/update'
            .replace('{' + 'connectorName' + '}', encodeURIComponent(String(connectorName)));
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'connectorName' is not null or undefined
        if (connectorName === null || connectorName === undefined) {
            throw new Error('Required parameter connectorName was null or undefined when calling updateConnector.');
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return ConnectorsApi;
}());
exports.ConnectorsApi = ConnectorsApi;
var FeedApiApiKeys;
(function (FeedApiApiKeys) {
    FeedApiApiKeys[FeedApiApiKeys["access_token"] = 0] = "access_token";
    FeedApiApiKeys[FeedApiApiKeys["client_id"] = 1] = "client_id";
})(FeedApiApiKeys = exports.FeedApiApiKeys || (exports.FeedApiApiKeys = {}));
var FeedApi = /** @class */ (function () {
    function FeedApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(FeedApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FeedApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    FeedApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    FeedApi.prototype.setApiKey = function (key, value) {
        this.authentications[FeedApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(FeedApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Tracking reminder notifications, messages, and study results
     * @summary Tracking reminder notifications, messages, and study results
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    FeedApi.prototype.getFeed = function (sort, userId, createdAt, updatedAt, limit, offset, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/feed';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "FeedResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post user actions on feed cards
     * @summary Post user interactions with feed
     * @param body Id of the tracking reminder notification to be snoozed
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    FeedApi.prototype.postFeed = function (body, userId, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/feed';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postFeed.');
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<Card>")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "FeedResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return FeedApi;
}());
exports.FeedApi = FeedApi;
var FriendsApiApiKeys;
(function (FriendsApiApiKeys) {
    FriendsApiApiKeys[FriendsApiApiKeys["access_token"] = 0] = "access_token";
    FriendsApiApiKeys[FriendsApiApiKeys["client_id"] = 1] = "client_id";
})(FriendsApiApiKeys = exports.FriendsApiApiKeys || (exports.FriendsApiApiKeys = {}));
var FriendsApi = /** @class */ (function () {
    function FriendsApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(FriendsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FriendsApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    FriendsApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    FriendsApi.prototype.setApiKey = function (key, value) {
        this.authentications[FriendsApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(FriendsApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get Friends
     * @summary Get Friends
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    FriendsApi.prototype.getFriends = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/friends';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<FriendsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post Friends
     * @summary Post Friends
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    FriendsApi.prototype.postFriends = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/friends';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<FriendsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return FriendsApi;
}());
exports.FriendsApi = FriendsApi;
var GroupsApiApiKeys;
(function (GroupsApiApiKeys) {
    GroupsApiApiKeys[GroupsApiApiKeys["access_token"] = 0] = "access_token";
    GroupsApiApiKeys[GroupsApiApiKeys["client_id"] = 1] = "client_id";
})(GroupsApiApiKeys = exports.GroupsApiApiKeys || (exports.GroupsApiApiKeys = {}));
var GroupsApi = /** @class */ (function () {
    function GroupsApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(GroupsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GroupsApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    GroupsApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    GroupsApi.prototype.setApiKey = function (key, value) {
        this.authentications[GroupsApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(GroupsApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get Groups
     * @summary Get Groups
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    GroupsApi.prototype.getGroups = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/groups';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<GroupsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get GroupsMembers
     * @summary Get GroupsMembers
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    GroupsApi.prototype.getGroupsMembers = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/groupsMembers';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<GroupsMembersResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post Groups
     * @summary Post Groups
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    GroupsApi.prototype.postGroups = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/groups';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<GroupsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post GroupsMembers
     * @summary Post GroupsMembers
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    GroupsApi.prototype.postGroupsMembers = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/groupsMembers';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<GroupsMembersResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return GroupsApi;
}());
exports.GroupsApi = GroupsApi;
var MeasurementsApiApiKeys;
(function (MeasurementsApiApiKeys) {
    MeasurementsApiApiKeys[MeasurementsApiApiKeys["access_token"] = 0] = "access_token";
    MeasurementsApiApiKeys[MeasurementsApiApiKeys["client_id"] = 1] = "client_id";
})(MeasurementsApiApiKeys = exports.MeasurementsApiApiKeys || (exports.MeasurementsApiApiKeys = {}));
var MeasurementsApi = /** @class */ (function () {
    function MeasurementsApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(MeasurementsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MeasurementsApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    MeasurementsApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    MeasurementsApi.prototype.setApiKey = function (key, value) {
        this.authentications[MeasurementsApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(MeasurementsApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Delete a previously submitted measurement
     * @summary Delete a measurement
     * @param body The startTime and variableId of the measurement to be deleted.
     * @param {*} [options] Override http request options.
     */
    MeasurementsApi.prototype.deleteMeasurement = function (body, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/measurements/delete';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteMeasurement.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MeasurementDelete")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CommonResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
     * @summary Get measurements for this user
     * @param variableName Name of the variable you want measurements for
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param variableCategoryName Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param sourceName ID of the source you want measurements for (supports exact name match only)
     * @param connectorName Ex: facebook
     * @param value Value of measurement
     * @param unitName Options: % Recommended Daily Allowance, -4 to 4 Rating, 0 to 1 Rating, 0 to 5 Rating, 1 to 10 Rating, 1 to 5 Rating, Applications, Beats per Minute, Calories, Capsules, Centimeters, Count, Degrees Celsius, Degrees East, Degrees Fahrenheit, Degrees North, Dollars, Drops, Event, Feet, Grams, Hours, Inches, Index, Kilocalories, Kilograms, Kilometers, Liters, Meters, Micrograms, Micrograms per decilitre, Miles, Milligrams, Milliliters, Millimeters, Millimeters Merc, Milliseconds, Minutes, Pascal, Percent, Pieces, Pills, Pounds, Puffs, Seconds, Serving, Sprays, Tablets, Torr, Units, Yes/No, per Minute, Doses, Quarts, Ounces, International Units, Meters per Second
     * @param earliestMeasurementTime Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param latestMeasurementTime Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Measurement id
     * @param groupingWidth The time (in seconds) over which measurements are grouped together
     * @param groupingTimezone The time (in seconds) over which measurements are grouped together
     * @param doNotProcess Ex: true
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param doNotConvert Ex: 1
     * @param minMaxFilter Ex: 1
     * @param {*} [options] Override http request options.
     */
    MeasurementsApi.prototype.getMeasurements = function (variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/measurements';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (variableName !== undefined) {
            localVarQueryParameters['variableName'] = ObjectSerializer.serialize(variableName, "string");
        }
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (variableCategoryName !== undefined) {
            localVarQueryParameters['variableCategoryName'] = ObjectSerializer.serialize(variableCategoryName, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (sourceName !== undefined) {
            localVarQueryParameters['sourceName'] = ObjectSerializer.serialize(sourceName, "string");
        }
        if (connectorName !== undefined) {
            localVarQueryParameters['connectorName'] = ObjectSerializer.serialize(connectorName, "string");
        }
        if (value !== undefined) {
            localVarQueryParameters['value'] = ObjectSerializer.serialize(value, "string");
        }
        if (unitName !== undefined) {
            localVarQueryParameters['unitName'] = ObjectSerializer.serialize(unitName, "string");
        }
        if (earliestMeasurementTime !== undefined) {
            localVarQueryParameters['earliestMeasurementTime'] = ObjectSerializer.serialize(earliestMeasurementTime, "string");
        }
        if (latestMeasurementTime !== undefined) {
            localVarQueryParameters['latestMeasurementTime'] = ObjectSerializer.serialize(latestMeasurementTime, "string");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (groupingWidth !== undefined) {
            localVarQueryParameters['groupingWidth'] = ObjectSerializer.serialize(groupingWidth, "number");
        }
        if (groupingTimezone !== undefined) {
            localVarQueryParameters['groupingTimezone'] = ObjectSerializer.serialize(groupingTimezone, "string");
        }
        if (doNotProcess !== undefined) {
            localVarQueryParameters['doNotProcess'] = ObjectSerializer.serialize(doNotProcess, "boolean");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (doNotConvert !== undefined) {
            localVarQueryParameters['doNotConvert'] = ObjectSerializer.serialize(doNotConvert, "boolean");
        }
        if (minMaxFilter !== undefined) {
            localVarQueryParameters['minMaxFilter'] = ObjectSerializer.serialize(minMaxFilter, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<Measurement>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.
     * @summary Get pairs of measurements for correlational analysis
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param effectUnitName Name for the unit effect measurements to be returned in
     * @param userId User&#39;s id
     * @param causeUnitName Name for the unit cause measurements to be returned in
     * @param onsetDelay The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
     * @param durationOfAction The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
     * @param earliestMeasurementTime Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param latestMeasurementTime Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {*} [options] Override http request options.
     */
    MeasurementsApi.prototype.getPairs = function (causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/pairs';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (causeVariableName !== undefined) {
            localVarQueryParameters['causeVariableName'] = ObjectSerializer.serialize(causeVariableName, "string");
        }
        if (effectVariableName !== undefined) {
            localVarQueryParameters['effectVariableName'] = ObjectSerializer.serialize(effectVariableName, "string");
        }
        if (causeVariableId !== undefined) {
            localVarQueryParameters['causeVariableId'] = ObjectSerializer.serialize(causeVariableId, "number");
        }
        if (effectVariableId !== undefined) {
            localVarQueryParameters['effectVariableId'] = ObjectSerializer.serialize(effectVariableId, "number");
        }
        if (predictorVariableName !== undefined) {
            localVarQueryParameters['predictorVariableName'] = ObjectSerializer.serialize(predictorVariableName, "string");
        }
        if (outcomeVariableName !== undefined) {
            localVarQueryParameters['outcomeVariableName'] = ObjectSerializer.serialize(outcomeVariableName, "string");
        }
        if (effectUnitName !== undefined) {
            localVarQueryParameters['effectUnitName'] = ObjectSerializer.serialize(effectUnitName, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (causeUnitName !== undefined) {
            localVarQueryParameters['causeUnitName'] = ObjectSerializer.serialize(causeUnitName, "string");
        }
        if (onsetDelay !== undefined) {
            localVarQueryParameters['onsetDelay'] = ObjectSerializer.serialize(onsetDelay, "string");
        }
        if (durationOfAction !== undefined) {
            localVarQueryParameters['durationOfAction'] = ObjectSerializer.serialize(durationOfAction, "string");
        }
        if (earliestMeasurementTime !== undefined) {
            localVarQueryParameters['earliestMeasurementTime'] = ObjectSerializer.serialize(earliestMeasurementTime, "string");
        }
        if (latestMeasurementTime !== undefined) {
            localVarQueryParameters['latestMeasurementTime'] = ObjectSerializer.serialize(latestMeasurementTime, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<Pair>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
     * @summary Post Request for Measurements CSV
     * @param userId User&#39;s id
     * @param {*} [options] Override http request options.
     */
    MeasurementsApi.prototype.measurementExportRequest = function (userId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v2/measurements/exportRequest';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
     * @summary Post a new set or update existing measurements to the database
     * @param body An array of measurement sets containing measurement items you want to insert.
     * @param userId User&#39;s id
     * @param {*} [options] Override http request options.
     */
    MeasurementsApi.prototype.postMeasurements = function (body, userId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/measurements/post';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postMeasurements.');
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<MeasurementSet>")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "PostMeasurementsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Update a previously submitted measurement
     * @summary Update a measurement
     * @param body The id as well as the new startTime, note, and/or value of the measurement to be updated
     * @param {*} [options] Override http request options.
     */
    MeasurementsApi.prototype.updateMeasurement = function (body, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/measurements/update';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateMeasurement.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MeasurementUpdate")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CommonResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return MeasurementsApi;
}());
exports.MeasurementsApi = MeasurementsApi;
var MessagesApiApiKeys;
(function (MessagesApiApiKeys) {
    MessagesApiApiKeys[MessagesApiApiKeys["access_token"] = 0] = "access_token";
    MessagesApiApiKeys[MessagesApiApiKeys["client_id"] = 1] = "client_id";
})(MessagesApiApiKeys = exports.MessagesApiApiKeys || (exports.MessagesApiApiKeys = {}));
var MessagesApi = /** @class */ (function () {
    function MessagesApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(MessagesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MessagesApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    MessagesApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    MessagesApi.prototype.setApiKey = function (key, value) {
        this.authentications[MessagesApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(MessagesApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get MessagesMessages
     * @summary Get MessagesMessages
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.getMessagesMessages = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/messagesMessages';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<MessagesMessagesResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get MessagesNotices
     * @summary Get MessagesNotices
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.getMessagesNotices = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/messagesNotices';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<MessagesNoticesResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get MessagesRecipients
     * @summary Get MessagesRecipients
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.getMessagesRecipients = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/messagesRecipients';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<MessagesRecipientsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post MessagesMessages
     * @summary Post MessagesMessages
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.postMessagesMessages = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/messagesMessages';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<MessagesMessagesResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post MessagesNotices
     * @summary Post MessagesNotices
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.postMessagesNotices = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/messagesNotices';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<MessagesNoticesResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post MessagesRecipients
     * @summary Post MessagesRecipients
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    MessagesApi.prototype.postMessagesRecipients = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/messagesRecipients';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<MessagesRecipientsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return MessagesApi;
}());
exports.MessagesApi = MessagesApi;
var NotificationsApiApiKeys;
(function (NotificationsApiApiKeys) {
    NotificationsApiApiKeys[NotificationsApiApiKeys["access_token"] = 0] = "access_token";
    NotificationsApiApiKeys[NotificationsApiApiKeys["client_id"] = 1] = "client_id";
})(NotificationsApiApiKeys = exports.NotificationsApiApiKeys || (exports.NotificationsApiApiKeys = {}));
var NotificationsApi = /** @class */ (function () {
    function NotificationsApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(NotificationsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationsApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    NotificationsApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    NotificationsApi.prototype.setApiKey = function (key, value) {
        this.authentications[NotificationsApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(NotificationsApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get NotificationPreferences
     * @summary Get NotificationPreferences
     * @param {*} [options] Override http request options.
     */
    NotificationsApi.prototype.getNotificationPreferences = function (options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/notificationPreferences';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get Notifications
     * @summary Get Notifications
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    NotificationsApi.prototype.getNotifications = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/notifications';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<NotificationsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post user token for Android, iOS, or web push notifications
     * @summary Post DeviceTokens
     * @param body The platform and token
     * @param {*} [options] Override http request options.
     */
    NotificationsApi.prototype.postDeviceToken = function (body, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/deviceTokens';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postDeviceToken.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DeviceToken")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post Notifications
     * @summary Post Notifications
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    NotificationsApi.prototype.postNotifications = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/notifications';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<NotificationsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return NotificationsApi;
}());
exports.NotificationsApi = NotificationsApi;
var RemindersApiApiKeys;
(function (RemindersApiApiKeys) {
    RemindersApiApiKeys[RemindersApiApiKeys["access_token"] = 0] = "access_token";
    RemindersApiApiKeys[RemindersApiApiKeys["client_id"] = 1] = "client_id";
})(RemindersApiApiKeys = exports.RemindersApiApiKeys || (exports.RemindersApiApiKeys = {}));
var RemindersApi = /** @class */ (function () {
    function RemindersApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(RemindersApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RemindersApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    RemindersApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    RemindersApi.prototype.setApiKey = function (key, value) {
        this.authentications[RemindersApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(RemindersApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
     * @summary Delete Tracking Reminder
     * @param body Id of reminder to be deleted
     * @param userId User&#39;s id
     * @param {*} [options] Override http request options.
     */
    RemindersApi.prototype.deleteTrackingReminder = function (body, userId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/trackingReminders/delete';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteTrackingReminder.');
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TrackingReminderDelete")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CommonResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Specific tracking reminder notification instances that still need to be tracked.
     * @summary Get specific tracking reminder notifications
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param variableCategoryName Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
     * @param reminderTime Ex: (lt)2017-07-31 21:43:26
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param onlyPast Ex: 1
     * @param includeDeleted Include deleted variables
     * @param {*} [options] Override http request options.
     */
    RemindersApi.prototype.getTrackingReminderNotifications = function (sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/trackingReminderNotifications';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (variableCategoryName !== undefined) {
            localVarQueryParameters['variableCategoryName'] = ObjectSerializer.serialize(variableCategoryName, "string");
        }
        if (reminderTime !== undefined) {
            localVarQueryParameters['reminderTime'] = ObjectSerializer.serialize(reminderTime, "string");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (onlyPast !== undefined) {
            localVarQueryParameters['onlyPast'] = ObjectSerializer.serialize(onlyPast, "boolean");
        }
        if (includeDeleted !== undefined) {
            localVarQueryParameters['includeDeleted'] = ObjectSerializer.serialize(includeDeleted, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetTrackingReminderNotificationsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Users can be reminded to track certain variables at a specified frequency with a default value.
     * @summary Get repeating tracking reminder settings
     * @param userId User&#39;s id
     * @param variableCategoryName Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param appVersion Ex: 2.1.1.0
     * @param {*} [options] Override http request options.
     */
    RemindersApi.prototype.getTrackingReminders = function (userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/trackingReminders';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (variableCategoryName !== undefined) {
            localVarQueryParameters['variableCategoryName'] = ObjectSerializer.serialize(variableCategoryName, "string");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<TrackingReminder>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Snooze, skip, or track a tracking reminder notification
     * @summary Snooze, skip, or track a tracking reminder notification
     * @param body Id of the tracking reminder notification to be snoozed
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    RemindersApi.prototype.postTrackingReminderNotifications = function (body, userId, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/trackingReminderNotifications';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postTrackingReminderNotifications.');
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<TrackingReminderNotificationPost>")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CommonResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * This is to enable users to create reminders to track a variable with a default value at a specified frequency
     * @summary Store a Tracking Reminder
     * @param body TrackingReminder that should be stored
     * @param {*} [options] Override http request options.
     */
    RemindersApi.prototype.postTrackingReminders = function (body, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/trackingReminders';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postTrackingReminders.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<TrackingReminder>")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "PostTrackingRemindersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return RemindersApi;
}());
exports.RemindersApi = RemindersApi;
var SharesApiApiKeys;
(function (SharesApiApiKeys) {
    SharesApiApiKeys[SharesApiApiKeys["access_token"] = 0] = "access_token";
    SharesApiApiKeys[SharesApiApiKeys["client_id"] = 1] = "client_id";
})(SharesApiApiKeys = exports.SharesApiApiKeys || (exports.SharesApiApiKeys = {}));
var SharesApi = /** @class */ (function () {
    function SharesApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(SharesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SharesApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    SharesApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    SharesApi.prototype.setApiKey = function (key, value) {
        this.authentications[SharesApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(SharesApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Remove access to user data for a given client_id associated with a given individual, app, or study
     * @summary Delete share
     * @param clientIdToRevoke Client id of the individual, study, or app that the user wishes to no longer have access to their data
     * @param reason Ex: I hate you!
     * @param {*} [options] Override http request options.
     */
    SharesApi.prototype.deleteShare = function (clientIdToRevoke, reason, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/shares/delete';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'clientIdToRevoke' is not null or undefined
        if (clientIdToRevoke === null || clientIdToRevoke === undefined) {
            throw new Error('Required parameter clientIdToRevoke was null or undefined when calling deleteShare.');
        }
        if (clientIdToRevoke !== undefined) {
            localVarQueryParameters['clientIdToRevoke'] = ObjectSerializer.serialize(clientIdToRevoke, "string");
        }
        if (reason !== undefined) {
            localVarQueryParameters['reason'] = ObjectSerializer.serialize(reason, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * This is a list of individuals, apps, or studies with access to your measurements.
     * @summary Get Authorized Apps, Studies, and Individuals
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param appVersion Ex: 2.1.1.0
     * @param log Username or email
     * @param pwd User password
     * @param {*} [options] Override http request options.
     */
    SharesApi.prototype.getShares = function (userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/shares';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }
        if (log !== undefined) {
            localVarQueryParameters['log'] = ObjectSerializer.serialize(log, "string");
        }
        if (pwd !== undefined) {
            localVarQueryParameters['pwd'] = ObjectSerializer.serialize(pwd, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetSharesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Invite someone to view your measurements
     * @summary Delete share
     * @param body Details about person to share with
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    SharesApi.prototype.inviteShare = function (body, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/shares/invite';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling inviteShare.');
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ShareInvitationBody")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return SharesApi;
}());
exports.SharesApi = SharesApi;
var StudiesApiApiKeys;
(function (StudiesApiApiKeys) {
    StudiesApiApiKeys[StudiesApiApiKeys["access_token"] = 0] = "access_token";
    StudiesApiApiKeys[StudiesApiApiKeys["client_id"] = 1] = "client_id";
})(StudiesApiApiKeys = exports.StudiesApiApiKeys || (exports.StudiesApiApiKeys = {}));
var StudiesApi = /** @class */ (function () {
    function StudiesApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(StudiesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StudiesApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    StudiesApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    StudiesApi.prototype.setApiKey = function (key, value) {
        this.authentications[StudiesApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(StudiesApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
     * @summary Create a Study
     * @param body Details about the study you want to create
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    StudiesApi.prototype.createStudy = function (body, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/study/create';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createStudy.');
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "StudyCreationBody")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "PostStudyCreateResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Delete previously posted vote
     * @summary Delete vote
     * @param body The cause and effect variable names for the predictor vote to be deleted.
     * @param userId User&#39;s id
     * @param {*} [options] Override http request options.
     */
    StudiesApi.prototype.deleteVote = function (body, userId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/votes/delete';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteVote.');
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "VoteDelete")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CommonResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
     * @summary These are open studies that anyone can join
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param includeCharts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param recalculate Recalculate instead of using cached analysis
     * @param studyId Client id for the study you want
     * @param {*} [options] Override http request options.
     */
    StudiesApi.prototype.getOpenStudies = function (causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/studies/open';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (causeVariableName !== undefined) {
            localVarQueryParameters['causeVariableName'] = ObjectSerializer.serialize(causeVariableName, "string");
        }
        if (effectVariableName !== undefined) {
            localVarQueryParameters['effectVariableName'] = ObjectSerializer.serialize(effectVariableName, "string");
        }
        if (causeVariableId !== undefined) {
            localVarQueryParameters['causeVariableId'] = ObjectSerializer.serialize(causeVariableId, "number");
        }
        if (effectVariableId !== undefined) {
            localVarQueryParameters['effectVariableId'] = ObjectSerializer.serialize(effectVariableId, "number");
        }
        if (predictorVariableName !== undefined) {
            localVarQueryParameters['predictorVariableName'] = ObjectSerializer.serialize(predictorVariableName, "string");
        }
        if (outcomeVariableName !== undefined) {
            localVarQueryParameters['outcomeVariableName'] = ObjectSerializer.serialize(outcomeVariableName, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (includeCharts !== undefined) {
            localVarQueryParameters['includeCharts'] = ObjectSerializer.serialize(includeCharts, "boolean");
        }
        if (recalculate !== undefined) {
            localVarQueryParameters['recalculate'] = ObjectSerializer.serialize(recalculate, "boolean");
        }
        if (studyId !== undefined) {
            localVarQueryParameters['studyId'] = ObjectSerializer.serialize(studyId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetStudiesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
     * @summary Get Personal or Population Studies
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param includeCharts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param recalculate Recalculate instead of using cached analysis
     * @param studyId Client id for the study you want
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param correlationCoefficient Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param outcomesOfInterest Only include correlations for which the effect is an outcome of interest for the user
     * @param principalInvestigatorUserId These are studies created by a specific principal investigator
     * @param open These are studies that anyone can join
     * @param joined These are studies that you have joined
     * @param created These are studies that you have created
     * @param population These are studies based on the entire population of users that have shared their data
     * @param downvoted These are studies that you have down-voted
     * @param {*} [options] Override http request options.
     */
    StudiesApi.prototype.getStudies = function (causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/studies';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (causeVariableName !== undefined) {
            localVarQueryParameters['causeVariableName'] = ObjectSerializer.serialize(causeVariableName, "string");
        }
        if (effectVariableName !== undefined) {
            localVarQueryParameters['effectVariableName'] = ObjectSerializer.serialize(effectVariableName, "string");
        }
        if (causeVariableId !== undefined) {
            localVarQueryParameters['causeVariableId'] = ObjectSerializer.serialize(causeVariableId, "number");
        }
        if (effectVariableId !== undefined) {
            localVarQueryParameters['effectVariableId'] = ObjectSerializer.serialize(effectVariableId, "number");
        }
        if (predictorVariableName !== undefined) {
            localVarQueryParameters['predictorVariableName'] = ObjectSerializer.serialize(predictorVariableName, "string");
        }
        if (outcomeVariableName !== undefined) {
            localVarQueryParameters['outcomeVariableName'] = ObjectSerializer.serialize(outcomeVariableName, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (includeCharts !== undefined) {
            localVarQueryParameters['includeCharts'] = ObjectSerializer.serialize(includeCharts, "boolean");
        }
        if (recalculate !== undefined) {
            localVarQueryParameters['recalculate'] = ObjectSerializer.serialize(recalculate, "boolean");
        }
        if (studyId !== undefined) {
            localVarQueryParameters['studyId'] = ObjectSerializer.serialize(studyId, "string");
        }
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (correlationCoefficient !== undefined) {
            localVarQueryParameters['correlationCoefficient'] = ObjectSerializer.serialize(correlationCoefficient, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (outcomesOfInterest !== undefined) {
            localVarQueryParameters['outcomesOfInterest'] = ObjectSerializer.serialize(outcomesOfInterest, "boolean");
        }
        if (principalInvestigatorUserId !== undefined) {
            localVarQueryParameters['principalInvestigatorUserId'] = ObjectSerializer.serialize(principalInvestigatorUserId, "number");
        }
        if (open !== undefined) {
            localVarQueryParameters['open'] = ObjectSerializer.serialize(open, "boolean");
        }
        if (joined !== undefined) {
            localVarQueryParameters['joined'] = ObjectSerializer.serialize(joined, "boolean");
        }
        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "boolean");
        }
        if (population !== undefined) {
            localVarQueryParameters['population'] = ObjectSerializer.serialize(population, "boolean");
        }
        if (downvoted !== undefined) {
            localVarQueryParameters['downvoted'] = ObjectSerializer.serialize(downvoted, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetStudiesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * These are studies that you have created.
     * @summary Get studies you have created
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param userId User&#39;s id
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    StudiesApi.prototype.getStudiesCreated = function (causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/studies/created';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (causeVariableName !== undefined) {
            localVarQueryParameters['causeVariableName'] = ObjectSerializer.serialize(causeVariableName, "string");
        }
        if (effectVariableName !== undefined) {
            localVarQueryParameters['effectVariableName'] = ObjectSerializer.serialize(effectVariableName, "string");
        }
        if (causeVariableId !== undefined) {
            localVarQueryParameters['causeVariableId'] = ObjectSerializer.serialize(causeVariableId, "number");
        }
        if (effectVariableId !== undefined) {
            localVarQueryParameters['effectVariableId'] = ObjectSerializer.serialize(effectVariableId, "number");
        }
        if (predictorVariableName !== undefined) {
            localVarQueryParameters['predictorVariableName'] = ObjectSerializer.serialize(predictorVariableName, "string");
        }
        if (outcomeVariableName !== undefined) {
            localVarQueryParameters['outcomeVariableName'] = ObjectSerializer.serialize(outcomeVariableName, "string");
        }
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetStudiesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * These are studies that you are currently sharing your data with.
     * @summary Studies You Have Joined
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param userId User&#39;s id
     * @param correlationCoefficient Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param outcomesOfInterest Only include correlations for which the effect is an outcome of interest for the user
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    StudiesApi.prototype.getStudiesJoined = function (causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/studies/joined';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (causeVariableName !== undefined) {
            localVarQueryParameters['causeVariableName'] = ObjectSerializer.serialize(causeVariableName, "string");
        }
        if (effectVariableName !== undefined) {
            localVarQueryParameters['effectVariableName'] = ObjectSerializer.serialize(effectVariableName, "string");
        }
        if (causeVariableId !== undefined) {
            localVarQueryParameters['causeVariableId'] = ObjectSerializer.serialize(causeVariableId, "number");
        }
        if (effectVariableId !== undefined) {
            localVarQueryParameters['effectVariableId'] = ObjectSerializer.serialize(effectVariableId, "number");
        }
        if (predictorVariableName !== undefined) {
            localVarQueryParameters['predictorVariableName'] = ObjectSerializer.serialize(predictorVariableName, "string");
        }
        if (outcomeVariableName !== undefined) {
            localVarQueryParameters['outcomeVariableName'] = ObjectSerializer.serialize(outcomeVariableName, "string");
        }
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (correlationCoefficient !== undefined) {
            localVarQueryParameters['correlationCoefficient'] = ObjectSerializer.serialize(correlationCoefficient, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (outcomesOfInterest !== undefined) {
            localVarQueryParameters['outcomesOfInterest'] = ObjectSerializer.serialize(outcomesOfInterest, "boolean");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "GetStudiesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get Study
     * @summary Get Study
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param includeCharts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param recalculate Recalculate instead of using cached analysis
     * @param studyId Client id for the study you want
     * @param {*} [options] Override http request options.
     */
    StudiesApi.prototype.getStudy = function (causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v4/study';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (causeVariableName !== undefined) {
            localVarQueryParameters['causeVariableName'] = ObjectSerializer.serialize(causeVariableName, "string");
        }
        if (effectVariableName !== undefined) {
            localVarQueryParameters['effectVariableName'] = ObjectSerializer.serialize(effectVariableName, "string");
        }
        if (causeVariableId !== undefined) {
            localVarQueryParameters['causeVariableId'] = ObjectSerializer.serialize(causeVariableId, "number");
        }
        if (effectVariableId !== undefined) {
            localVarQueryParameters['effectVariableId'] = ObjectSerializer.serialize(effectVariableId, "number");
        }
        if (predictorVariableName !== undefined) {
            localVarQueryParameters['predictorVariableName'] = ObjectSerializer.serialize(predictorVariableName, "string");
        }
        if (outcomeVariableName !== undefined) {
            localVarQueryParameters['outcomeVariableName'] = ObjectSerializer.serialize(outcomeVariableName, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (includeCharts !== undefined) {
            localVarQueryParameters['includeCharts'] = ObjectSerializer.serialize(includeCharts, "boolean");
        }
        if (recalculate !== undefined) {
            localVarQueryParameters['recalculate'] = ObjectSerializer.serialize(recalculate, "boolean");
        }
        if (studyId !== undefined) {
            localVarQueryParameters['studyId'] = ObjectSerializer.serialize(studyId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Study");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Anonymously share measurements for specified variables
     * @summary Join a Study
     * @param studyId Client id for the study you want
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    StudiesApi.prototype.joinStudy = function (studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/study/join';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (studyId !== undefined) {
            localVarQueryParameters['studyId'] = ObjectSerializer.serialize(studyId, "string");
        }
        if (causeVariableName !== undefined) {
            localVarQueryParameters['causeVariableName'] = ObjectSerializer.serialize(causeVariableName, "string");
        }
        if (effectVariableName !== undefined) {
            localVarQueryParameters['effectVariableName'] = ObjectSerializer.serialize(effectVariableName, "string");
        }
        if (causeVariableId !== undefined) {
            localVarQueryParameters['causeVariableId'] = ObjectSerializer.serialize(causeVariableId, "number");
        }
        if (effectVariableId !== undefined) {
            localVarQueryParameters['effectVariableId'] = ObjectSerializer.serialize(effectVariableId, "number");
        }
        if (predictorVariableName !== undefined) {
            localVarQueryParameters['predictorVariableName'] = ObjectSerializer.serialize(predictorVariableName, "string");
        }
        if (outcomeVariableName !== undefined) {
            localVarQueryParameters['outcomeVariableName'] = ObjectSerializer.serialize(outcomeVariableName, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "StudyJoinResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
     * @summary Post or update vote
     * @param body Contains the cause variable, effect variable, and vote value.
     * @param userId User&#39;s id
     * @param {*} [options] Override http request options.
     */
    StudiesApi.prototype.postVote = function (body, userId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/votes';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postVote.');
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Vote")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CommonResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Make a study and all related measurements publicly visible by anyone
     * @summary Publish Your Study
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param includeCharts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param recalculate Recalculate instead of using cached analysis
     * @param studyId Client id for the study you want
     * @param {*} [options] Override http request options.
     */
    StudiesApi.prototype.publishStudy = function (causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/study/publish';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (causeVariableName !== undefined) {
            localVarQueryParameters['causeVariableName'] = ObjectSerializer.serialize(causeVariableName, "string");
        }
        if (effectVariableName !== undefined) {
            localVarQueryParameters['effectVariableName'] = ObjectSerializer.serialize(effectVariableName, "string");
        }
        if (causeVariableId !== undefined) {
            localVarQueryParameters['causeVariableId'] = ObjectSerializer.serialize(causeVariableId, "number");
        }
        if (effectVariableId !== undefined) {
            localVarQueryParameters['effectVariableId'] = ObjectSerializer.serialize(effectVariableId, "number");
        }
        if (predictorVariableName !== undefined) {
            localVarQueryParameters['predictorVariableName'] = ObjectSerializer.serialize(predictorVariableName, "string");
        }
        if (outcomeVariableName !== undefined) {
            localVarQueryParameters['outcomeVariableName'] = ObjectSerializer.serialize(outcomeVariableName, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (includeCharts !== undefined) {
            localVarQueryParameters['includeCharts'] = ObjectSerializer.serialize(includeCharts, "boolean");
        }
        if (recalculate !== undefined) {
            localVarQueryParameters['recalculate'] = ObjectSerializer.serialize(recalculate, "boolean");
        }
        if (studyId !== undefined) {
            localVarQueryParameters['studyId'] = ObjectSerializer.serialize(studyId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "PostStudyPublishResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return StudiesApi;
}());
exports.StudiesApi = StudiesApi;
var UnitsApiApiKeys;
(function (UnitsApiApiKeys) {
    UnitsApiApiKeys[UnitsApiApiKeys["access_token"] = 0] = "access_token";
    UnitsApiApiKeys[UnitsApiApiKeys["client_id"] = 1] = "client_id";
})(UnitsApiApiKeys = exports.UnitsApiApiKeys || (exports.UnitsApiApiKeys = {}));
var UnitsApi = /** @class */ (function () {
    function UnitsApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(UnitsApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnitsApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    UnitsApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    UnitsApi.prototype.setApiKey = function (key, value) {
        this.authentications[UnitsApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(UnitsApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
     * @summary Get unit categories
     * @param {*} [options] Override http request options.
     */
    UnitsApi.prototype.getUnitCategories = function (options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/unitCategories';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<UnitCategory>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get a list of the available measurement units
     * @summary Get units
     * @param {*} [options] Override http request options.
     */
    UnitsApi.prototype.getUnits = function (options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/units';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<Unit>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return UnitsApi;
}());
exports.UnitsApi = UnitsApi;
var UserApiApiKeys;
(function (UserApiApiKeys) {
    UserApiApiKeys[UserApiApiKeys["access_token"] = 0] = "access_token";
    UserApiApiKeys[UserApiApiKeys["client_id"] = 1] = "client_id";
})(UserApiApiKeys = exports.UserApiApiKeys || (exports.UserApiApiKeys = {}));
var UserApi = /** @class */ (function () {
    function UserApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(UserApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    UserApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    UserApi.prototype.setApiKey = function (key, value) {
        this.authentications[UserApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(UserApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Delete user account. Only the client app that created a user can delete that user.
     * @summary Delete user
     * @param reason Ex: I hate you!
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    UserApi.prototype.deleteUser = function (reason, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/user/delete';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'reason' is not null or undefined
        if (reason === null || reason === undefined) {
            throw new Error('Required parameter reason was null or undefined when calling deleteUser.');
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (reason !== undefined) {
            localVarQueryParameters['reason'] = ObjectSerializer.serialize(reason, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CommonResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Returns user info.  If no userId is specified, returns info for currently authenticated user
     * @summary Get user info
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param appVersion Ex: 2.1.1.0
     * @param clientUserId Ex: 74802
     * @param log Username or email
     * @param pwd User password
     * @param includeAuthorizedClients Return list of apps, studies, and individuals with access to user data
     * @param {*} [options] Override http request options.
     */
    UserApi.prototype.getUser = function (userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/user';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }
        if (clientUserId !== undefined) {
            localVarQueryParameters['clientUserId'] = ObjectSerializer.serialize(clientUserId, "number");
        }
        if (log !== undefined) {
            localVarQueryParameters['log'] = ObjectSerializer.serialize(log, "string");
        }
        if (pwd !== undefined) {
            localVarQueryParameters['pwd'] = ObjectSerializer.serialize(pwd, "string");
        }
        if (includeAuthorizedClients !== undefined) {
            localVarQueryParameters['includeAuthorizedClients'] = ObjectSerializer.serialize(includeAuthorizedClients, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get UserBlogs
     * @summary Get UserBlogs
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    UserApi.prototype.getUserBlogs = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/userBlogs';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<UserBlogsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Returns users who have granted access to their data
     * @summary Get users who shared data
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param appVersion Ex: 2.1.1.0
     * @param clientUserId Ex: 74802
     * @param log Username or email
     * @param pwd User password
     * @param {*} [options] Override http request options.
     */
    UserApi.prototype.getUsers = function (userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/users';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (appVersion !== undefined) {
            localVarQueryParameters['appVersion'] = ObjectSerializer.serialize(appVersion, "string");
        }
        if (clientUserId !== undefined) {
            localVarQueryParameters['clientUserId'] = ObjectSerializer.serialize(clientUserId, "number");
        }
        if (log !== undefined) {
            localVarQueryParameters['log'] = ObjectSerializer.serialize(log, "string");
        }
        if (pwd !== undefined) {
            localVarQueryParameters['pwd'] = ObjectSerializer.serialize(pwd, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "UsersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post UserBlogs
     * @summary Post UserBlogs
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    UserApi.prototype.postUserBlogs = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/userBlogs';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<UserBlogsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post UserSettings
     * @summary Post UserSettings
     * @param body User settings to update
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    UserApi.prototype.postUserSettings = function (body, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/userSettings';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postUserSettings.');
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "User")
        };
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "PostUserSettingsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return UserApi;
}());
exports.UserApi = UserApi;
var VariablesApiApiKeys;
(function (VariablesApiApiKeys) {
    VariablesApiApiKeys[VariablesApiApiKeys["access_token"] = 0] = "access_token";
    VariablesApiApiKeys[VariablesApiApiKeys["client_id"] = 1] = "client_id";
})(VariablesApiApiKeys = exports.VariablesApiApiKeys || (exports.VariablesApiApiKeys = {}));
var VariablesApi = /** @class */ (function () {
    function VariablesApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(VariablesApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VariablesApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    VariablesApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    VariablesApi.prototype.setApiKey = function (key, value) {
        this.authentications[VariablesApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(VariablesApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Delete previously created user tags or ingredients.
     * @summary Delete user tag or ingredient
     * @param taggedVariableId Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param tagVariableId Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {*} [options] Override http request options.
     */
    VariablesApi.prototype.deleteUserTag = function (taggedVariableId, tagVariableId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/userTags/delete';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (taggedVariableId !== undefined) {
            localVarQueryParameters['taggedVariableId'] = ObjectSerializer.serialize(taggedVariableId, "number");
        }
        if (tagVariableId !== undefined) {
            localVarQueryParameters['tagVariableId'] = ObjectSerializer.serialize(tagVariableId, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CommonResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Users can delete all of their measurements for a variable
     * @summary Delete All Measurements For Variable
     * @param variableId Id of the variable whose measurements should be deleted
     * @param {*} [options] Override http request options.
     */
    VariablesApi.prototype.deleteUserVariable = function (variableId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/userVariables/delete';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'variableId' is not null or undefined
        if (variableId === null || variableId === undefined) {
            throw new Error('Required parameter variableId was null or undefined when calling deleteUserVariable.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(variableId, "UserVariableDelete")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
     * @summary Variable categories
     * @param {*} [options] Override http request options.
     */
    VariablesApi.prototype.getVariableCategories = function (options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/variableCategories';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<VariableCategory>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
     * @summary Get variables along with related user-specific analysis settings and statistics
     * @param includeCharts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param numberOfRawMeasurements Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
     * @param userId User&#39;s id
     * @param variableCategoryName Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
     * @param name Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood%
     * @param variableName Name of the variable you want measurements for
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param sourceName ID of the source you want measurements for (supports exact name match only)
     * @param earliestMeasurementTime Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param latestMeasurementTime Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param id Common variable id
     * @param lastSourceName Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param includePublic Include variables the user has no measurements for
     * @param manualTracking Only include variables tracked manually by the user
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param upc UPC or other barcode scan result
     * @param effectOrCause Provided variable is the effect or cause
     * @param publicEffectOrCause Ex:
     * @param exactMatch Require exact match
     * @param variableCategoryId Ex: 13
     * @param includePrivate Include user-specific variables in results
     * @param searchPhrase Ex: %Body Fat%
     * @param synonyms Ex: McDonalds hotcake
     * @param taggedVariableId Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param tagVariableId Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param joinVariableId Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
     * @param parentUserTagVariableId Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
     * @param childUserTagVariableId Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
     * @param ingredientUserTagVariableId Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
     * @param ingredientOfUserTagVariableId Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
     * @param commonOnly Return only public and aggregated common variable data instead of user-specific variables
     * @param userOnly Return only user-specific variables and data, excluding common aggregated variable data
     * @param includeTags Return parent, child, duplicate, and ingredient variables
     * @param recalculate Recalculate instead of using cached analysis
     * @param variableId Ex: 13
     * @param concise Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
     * @param refresh Regenerate charts instead of getting from the cache
     * @param {*} [options] Override http request options.
     */
    VariablesApi.prototype.getVariables = function (includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/variables';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (includeCharts !== undefined) {
            localVarQueryParameters['includeCharts'] = ObjectSerializer.serialize(includeCharts, "boolean");
        }
        if (numberOfRawMeasurements !== undefined) {
            localVarQueryParameters['numberOfRawMeasurements'] = ObjectSerializer.serialize(numberOfRawMeasurements, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (variableCategoryName !== undefined) {
            localVarQueryParameters['variableCategoryName'] = ObjectSerializer.serialize(variableCategoryName, "string");
        }
        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }
        if (variableName !== undefined) {
            localVarQueryParameters['variableName'] = ObjectSerializer.serialize(variableName, "string");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (sourceName !== undefined) {
            localVarQueryParameters['sourceName'] = ObjectSerializer.serialize(sourceName, "string");
        }
        if (earliestMeasurementTime !== undefined) {
            localVarQueryParameters['earliestMeasurementTime'] = ObjectSerializer.serialize(earliestMeasurementTime, "string");
        }
        if (latestMeasurementTime !== undefined) {
            localVarQueryParameters['latestMeasurementTime'] = ObjectSerializer.serialize(latestMeasurementTime, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (lastSourceName !== undefined) {
            localVarQueryParameters['lastSourceName'] = ObjectSerializer.serialize(lastSourceName, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (includePublic !== undefined) {
            localVarQueryParameters['includePublic'] = ObjectSerializer.serialize(includePublic, "boolean");
        }
        if (manualTracking !== undefined) {
            localVarQueryParameters['manualTracking'] = ObjectSerializer.serialize(manualTracking, "boolean");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (upc !== undefined) {
            localVarQueryParameters['upc'] = ObjectSerializer.serialize(upc, "string");
        }
        if (effectOrCause !== undefined) {
            localVarQueryParameters['effectOrCause'] = ObjectSerializer.serialize(effectOrCause, "string");
        }
        if (publicEffectOrCause !== undefined) {
            localVarQueryParameters['publicEffectOrCause'] = ObjectSerializer.serialize(publicEffectOrCause, "string");
        }
        if (exactMatch !== undefined) {
            localVarQueryParameters['exactMatch'] = ObjectSerializer.serialize(exactMatch, "boolean");
        }
        if (variableCategoryId !== undefined) {
            localVarQueryParameters['variableCategoryId'] = ObjectSerializer.serialize(variableCategoryId, "number");
        }
        if (includePrivate !== undefined) {
            localVarQueryParameters['includePrivate'] = ObjectSerializer.serialize(includePrivate, "boolean");
        }
        if (searchPhrase !== undefined) {
            localVarQueryParameters['searchPhrase'] = ObjectSerializer.serialize(searchPhrase, "string");
        }
        if (synonyms !== undefined) {
            localVarQueryParameters['synonyms'] = ObjectSerializer.serialize(synonyms, "string");
        }
        if (taggedVariableId !== undefined) {
            localVarQueryParameters['taggedVariableId'] = ObjectSerializer.serialize(taggedVariableId, "number");
        }
        if (tagVariableId !== undefined) {
            localVarQueryParameters['tagVariableId'] = ObjectSerializer.serialize(tagVariableId, "number");
        }
        if (joinVariableId !== undefined) {
            localVarQueryParameters['joinVariableId'] = ObjectSerializer.serialize(joinVariableId, "number");
        }
        if (parentUserTagVariableId !== undefined) {
            localVarQueryParameters['parentUserTagVariableId'] = ObjectSerializer.serialize(parentUserTagVariableId, "number");
        }
        if (childUserTagVariableId !== undefined) {
            localVarQueryParameters['childUserTagVariableId'] = ObjectSerializer.serialize(childUserTagVariableId, "number");
        }
        if (ingredientUserTagVariableId !== undefined) {
            localVarQueryParameters['ingredientUserTagVariableId'] = ObjectSerializer.serialize(ingredientUserTagVariableId, "number");
        }
        if (ingredientOfUserTagVariableId !== undefined) {
            localVarQueryParameters['ingredientOfUserTagVariableId'] = ObjectSerializer.serialize(ingredientOfUserTagVariableId, "number");
        }
        if (commonOnly !== undefined) {
            localVarQueryParameters['commonOnly'] = ObjectSerializer.serialize(commonOnly, "boolean");
        }
        if (userOnly !== undefined) {
            localVarQueryParameters['userOnly'] = ObjectSerializer.serialize(userOnly, "boolean");
        }
        if (includeTags !== undefined) {
            localVarQueryParameters['includeTags'] = ObjectSerializer.serialize(includeTags, "boolean");
        }
        if (recalculate !== undefined) {
            localVarQueryParameters['recalculate'] = ObjectSerializer.serialize(recalculate, "boolean");
        }
        if (variableId !== undefined) {
            localVarQueryParameters['variableId'] = ObjectSerializer.serialize(variableId, "number");
        }
        if (concise !== undefined) {
            localVarQueryParameters['concise'] = ObjectSerializer.serialize(concise, "boolean");
        }
        if (refresh !== undefined) {
            localVarQueryParameters['refresh'] = ObjectSerializer.serialize(refresh, "boolean");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<Variable>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
     * @summary Post or update user tags or ingredients
     * @param body Contains the new user tag data
     * @param userId User&#39;s id
     * @param {*} [options] Override http request options.
     */
    VariablesApi.prototype.postUserTags = function (body, userId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/userTags';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postUserTags.');
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserTag")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CommonResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
     * @summary Update User Settings for a Variable
     * @param userVariables Variable user settings data
     * @param includePrivate Include user-specific variables in results
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param includePublic Include variables the user has no measurements for
     * @param searchPhrase Ex: %Body Fat%
     * @param exactMatch Require exact match
     * @param manualTracking Only include variables tracked manually by the user
     * @param variableCategoryName Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
     * @param variableCategoryId Ex: 13
     * @param synonyms Ex: McDonalds hotcake
     * @param {*} [options] Override http request options.
     */
    VariablesApi.prototype.postUserVariables = function (userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/variables';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'userVariables' is not null or undefined
        if (userVariables === null || userVariables === undefined) {
            throw new Error('Required parameter userVariables was null or undefined when calling postUserVariables.');
        }
        if (includePrivate !== undefined) {
            localVarQueryParameters['includePrivate'] = ObjectSerializer.serialize(includePrivate, "boolean");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        if (includePublic !== undefined) {
            localVarQueryParameters['includePublic'] = ObjectSerializer.serialize(includePublic, "boolean");
        }
        if (searchPhrase !== undefined) {
            localVarQueryParameters['searchPhrase'] = ObjectSerializer.serialize(searchPhrase, "string");
        }
        if (exactMatch !== undefined) {
            localVarQueryParameters['exactMatch'] = ObjectSerializer.serialize(exactMatch, "boolean");
        }
        if (manualTracking !== undefined) {
            localVarQueryParameters['manualTracking'] = ObjectSerializer.serialize(manualTracking, "boolean");
        }
        if (variableCategoryName !== undefined) {
            localVarQueryParameters['variableCategoryName'] = ObjectSerializer.serialize(variableCategoryName, "string");
        }
        if (variableCategoryId !== undefined) {
            localVarQueryParameters['variableCategoryId'] = ObjectSerializer.serialize(variableCategoryId, "number");
        }
        if (synonyms !== undefined) {
            localVarQueryParameters['synonyms'] = ObjectSerializer.serialize(synonyms, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userVariables, "Array<Variable>")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "CommonResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Reset user settings for a variable to defaults
     * @summary Reset user settings for a variable to defaults
     * @param variableId Id of the variable whose measurements should be deleted
     * @param {*} [options] Override http request options.
     */
    VariablesApi.prototype.resetUserVariableSettings = function (variableId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/userVariables/reset';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        // verify required parameter 'variableId' is not null or undefined
        if (variableId === null || variableId === undefined) {
            throw new Error('Required parameter variableId was null or undefined when calling resetUserVariableSettings.');
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(variableId, "UserVariableDelete")
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return VariablesApi;
}());
exports.VariablesApi = VariablesApi;
var XprofileApiApiKeys;
(function (XprofileApiApiKeys) {
    XprofileApiApiKeys[XprofileApiApiKeys["access_token"] = 0] = "access_token";
    XprofileApiApiKeys[XprofileApiApiKeys["client_id"] = 1] = "client_id";
})(XprofileApiApiKeys = exports.XprofileApiApiKeys || (exports.XprofileApiApiKeys = {}));
var XprofileApi = /** @class */ (function () {
    function XprofileApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
            'access_token': new ApiKeyAuth('query', 'access_token'),
            'client_id': new ApiKeyAuth('query', 'clientId'),
            'quantimodo_oauth2': new OAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(XprofileApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XprofileApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    XprofileApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    XprofileApi.prototype.setApiKey = function (key, value) {
        this.authentications[XprofileApiApiKeys[key]].apiKey = value;
    };
    Object.defineProperty(XprofileApi.prototype, "accessToken", {
        set: function (token) {
            this.authentications.quantimodo_oauth2.accessToken = token;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get XprofileData
     * @summary Get XprofileData
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    XprofileApi.prototype.getXprofileData = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/xprofileData';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<XprofileDataResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get XprofileFields
     * @summary Get XprofileFields
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    XprofileApi.prototype.getXprofileFields = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/xprofileFields';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<XprofileFieldsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get XprofileGroups
     * @summary Get XprofileGroups
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    XprofileApi.prototype.getXprofileGroups = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/xprofileGroups';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<XprofileGroupsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post XprofileData
     * @summary Post XprofileData
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    XprofileApi.prototype.postXprofileData = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/xprofileData';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<XprofileDataResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post XprofileFields
     * @summary Post XprofileFields
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    XprofileApi.prototype.postXprofileFields = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/xprofileFields';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<XprofileFieldsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Post XprofileGroups
     * @summary Post XprofileGroups
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param userId User&#39;s id
     * @param createdAt When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param id Id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request options.
     */
    XprofileApi.prototype.postXprofileGroups = function (sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        if (options === void 0) { options = {}; }
        var localVarPath = this.basePath + '/v3/xprofileGroups';
        var localVarQueryParameters = {};
        var localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        var localVarFormParams = {};
        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }
        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }
        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }
        if (updatedAt !== undefined) {
            localVarQueryParameters['updatedAt'] = ObjectSerializer.serialize(updatedAt, "string");
        }
        if (userId !== undefined) {
            localVarQueryParameters['userId'] = ObjectSerializer.serialize(userId, "number");
        }
        if (createdAt !== undefined) {
            localVarQueryParameters['createdAt'] = ObjectSerializer.serialize(createdAt, "string");
        }
        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "number");
        }
        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }
        Object.assign(localVarHeaderParams, options.headers);
        var localVarUseFormData = false;
        var localVarRequestOptions = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.access_token.applyToRequest(localVarRequestOptions);
        this.authentications.quantimodo_oauth2.applyToRequest(localVarRequestOptions);
        this.authentications.default.applyToRequest(localVarRequestOptions);
        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                localVarRequestOptions.formData = localVarFormParams;
            }
            else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise(function (resolve, reject) {
            localVarRequest(localVarRequestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    body = ObjectSerializer.deserialize(body, "Array<XprofileGroupsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return XprofileApi;
}());
exports.XprofileApi = XprofileApi;
//# sourceMappingURL=api.js.map