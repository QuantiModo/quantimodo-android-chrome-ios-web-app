/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * quantimodo
 * We make it easy to retrieve and analyze normalized user data from a wide array of devices and applications. Check out our [docs and sdk's](https://github.com/QuantiModo/docs) or [contact us](https://help.quantimo.do).
 *
 * OpenAPI spec version: 5.8.112511
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://app.quantimo.do/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ActivitiesResponse
 */
export interface ActivitiesResponse {
    /**
     * 
     * @type {Array<Activity>}
     * @memberof ActivitiesResponse
     */
    activities: Array<Activity>;
    /**
     * Activity
     * @type {string}
     * @memberof ActivitiesResponse
     */
    description?: string;
    /**
     * Activity
     * @type {string}
     * @memberof ActivitiesResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof ActivitiesResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof ActivitiesResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof ActivitiesResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof ActivitiesResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof ActivitiesResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof ActivitiesResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof ActivitiesResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof ActivitiesResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof ActivitiesResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof ActivitiesResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * What do you expect?
     * @type {number}
     * @memberof Activity
     */
    id: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Activity
     */
    userId: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Activity
     */
    component: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Activity
     */
    type: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Activity
     */
    action: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Activity
     */
    content: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Activity
     */
    primaryLink: string;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Activity
     */
    itemId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Activity
     */
    secondaryItemId: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Activity
     */
    dateRecorded: string;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Activity
     */
    hideSitewide: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Activity
     */
    mpttLeft: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Activity
     */
    mpttRight: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Activity
     */
    isSpam: number;
    /**
     * Additional activity key-value data
     * @type {Array<any>}
     * @memberof Activity
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface AppSettings
 */
export interface AppSettings {
    /**
     * What do you expect?
     * @type {any}
     * @memberof AppSettings
     */
    additionalSettings?: any;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    appDescription?: string;
    /**
     * What do you expect?
     * @type {any}
     * @memberof AppSettings
     */
    appDesign?: any;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    appDisplayName?: string;
    /**
     * What do you expect?
     * @type {any}
     * @memberof AppSettings
     */
    appStatus?: any;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    appType?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    buildEnabled?: string;
    /**
     * Get yours at https:://builder.quantimo.do
     * @type {string}
     * @memberof AppSettings
     */
    clientId: string;
    /**
     * Get yours at https:://builder.quantimo.do
     * @type {string}
     * @memberof AppSettings
     */
    clientSecret?: string;
    /**
     * What do you expect?
     * @type {Array<User>}
     * @memberof AppSettings
     */
    collaborators?: Array<User>;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    createdAt?: string;
    /**
     * User id of the owner of the application
     * @type {number}
     * @memberof AppSettings
     */
    userId?: number;
    /**
     * What do you expect?
     * @type {Array<User>}
     * @memberof AppSettings
     */
    users?: Array<User>;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    redirectUri?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    companyName?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    homepageUrl?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    iconUrl?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    longDescription?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    splashScreen?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof AppSettings
     */
    textLogo?: string;
}

/**
 * 
 * @export
 * @interface AppSettingsResponse
 */
export interface AppSettingsResponse {
    /**
     * 
     * @type {AppSettings}
     * @memberof AppSettingsResponse
     */
    appSettings?: AppSettings;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof AppSettingsResponse
     */
    description: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof AppSettingsResponse
     */
    summary: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof AppSettingsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof AppSettingsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof AppSettingsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof AppSettingsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof AppSettingsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof AppSettingsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface AuthorizedClients
 */
export interface AuthorizedClients {
    /**
     * Applications with access to user measurements for all variables
     * @type {Array<AppSettings>}
     * @memberof AuthorizedClients
     */
    apps: Array<AppSettings>;
    /**
     * Individuals such as physicians or family members with access to user measurements for all variables
     * @type {Array<AppSettings>}
     * @memberof AuthorizedClients
     */
    individuals: Array<AppSettings>;
    /**
     * Studies with access to generally anonymous user measurements for a specific predictor and outcome variable
     * @type {Array<AppSettings>}
     * @memberof AuthorizedClients
     */
    studies: Array<AppSettings>;
}

/**
 * 
 * @export
 * @interface Button
 */
export interface Button {
    /**
     * Ex: connect
     * @type {string}
     * @memberof Button
     */
    accessibilityText?: string;
    /**
     * Action data
     * @type {any}
     * @memberof Button
     */
    action?: any;
    /**
     * Ex: connect
     * @type {string}
     * @memberof Button
     */
    additionalInformation?: string;
    /**
     * Ex: #f2f2f2
     * @type {string}
     * @memberof Button
     */
    color?: string;
    /**
     * Text to show user before executing functionName
     * @type {string}
     * @memberof Button
     */
    confirmationText?: string;
    /**
     * Name of function to call
     * @type {string}
     * @memberof Button
     */
    functionName?: string;
    /**
     * Data to provide to functionName or be copied to the card parameters when button is clicked and card is posted to the API
     * @type {any}
     * @memberof Button
     */
    parameters?: any;
    /**
     * Ex: connect
     * @type {string}
     * @memberof Button
     */
    html?: string;
    /**
     * HTML element id
     * @type {string}
     * @memberof Button
     */
    id?: string;
    /**
     * Ex: https://image.jpg
     * @type {string}
     * @memberof Button
     */
    image?: string;
    /**
     * Ex: ion-refresh
     * @type {string}
     * @memberof Button
     */
    ionIcon?: string;
    /**
     * Ex: https://local.quantimo.do
     * @type {string}
     * @memberof Button
     */
    link: string;
    /**
     * State to go to
     * @type {string}
     * @memberof Button
     */
    stateName?: string;
    /**
     * Data to provide to the state
     * @type {any}
     * @memberof Button
     */
    stateParams?: any;
    /**
     * Text to show user after executing functionName
     * @type {string}
     * @memberof Button
     */
    successToastText?: string;
    /**
     * Text to show user after executing functionName
     * @type {string}
     * @memberof Button
     */
    successAlertTitle?: string;
    /**
     * Text to show user after executing functionName
     * @type {string}
     * @memberof Button
     */
    successAlertBody?: string;
    /**
     * Ex: Connect
     * @type {string}
     * @memberof Button
     */
    text: string;
    /**
     * Ex: This is a tooltip
     * @type {string}
     * @memberof Button
     */
    tooltip?: string;
    /**
     * Post here on button click
     * @type {string}
     * @memberof Button
     */
    webhookUrl?: string;
}

/**
 * 
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * 
     * @type {Array<Button>}
     * @memberof Card
     */
    actionSheetButtons?: Array<Button>;
    /**
     * Smaller square image
     * @type {string}
     * @memberof Card
     */
    avatar?: string;
    /**
     * Smaller circular image
     * @type {string}
     * @memberof Card
     */
    avatarCircular?: string;
    /**
     * Ex: #f2f2f2
     * @type {string}
     * @memberof Card
     */
    backgroundColor?: string;
    /**
     * 
     * @type {Array<Button>}
     * @memberof Card
     */
    buttons?: Array<Button>;
    /**
     * 
     * @type {Array<Button>}
     * @memberof Card
     */
    buttonsSecondary?: Array<Button>;
    /**
     * Ex: Content
     * @type {string}
     * @memberof Card
     */
    content?: string;
    /**
     * Ex: Title
     * @type {string}
     * @memberof Card
     */
    headerTitle?: string;
    /**
     * HTML for the entire card.
     * @type {string}
     * @memberof Card
     */
    html?: string;
    /**
     * Ex: <div>Content</div>
     * @type {string}
     * @memberof Card
     */
    htmlContent?: string;
    /**
     * HTML element id
     * @type {string}
     * @memberof Card
     */
    id: string;
    /**
     * Larger image of variable dimensions
     * @type {string}
     * @memberof Card
     */
    image?: string;
    /**
     * 
     * @type {Array<InputField>}
     * @memberof Card
     */
    inputFields?: Array<InputField>;
    /**
     * Ex: ion-refresh
     * @type {string}
     * @memberof Card
     */
    ionIcon?: string;
    /**
     * A link to a web page or something. Not much more to say about that.
     * @type {string}
     * @memberof Card
     */
    link?: string;
    /**
     * Key value pairs derived from user input fields, button clicks, or preset defaults
     * @type {any}
     * @memberof Card
     */
    parameters?: any;
    /**
     * 
     * @type {Array<Card>}
     * @memberof Card
     */
    relatedCards?: Array<Card>;
    /**
     * Button that the user clicked and the provided function parameters
     * @type {Button}
     * @memberof Card
     */
    selectedButton?: Button;
    /**
     * Ex: sharingBody
     * @type {string}
     * @memberof Card
     */
    sharingBody?: string;
    /**
     * 
     * @type {Array<Button>}
     * @memberof Card
     */
    sharingButtons?: Array<Button>;
    /**
     * Ex: sharingTitle
     * @type {string}
     * @memberof Card
     */
    sharingTitle?: string;
    /**
     * Ex: subTitle
     * @type {string}
     * @memberof Card
     */
    subHeader?: string;
    /**
     * Ex: subTitle
     * @type {string}
     * @memberof Card
     */
    subTitle?: string;
    /**
     * Ex: Title
     * @type {string}
     * @memberof Card
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface Chart
 */
export interface Chart {
    /**
     *  Highcharts config that can be used if you have highcharts.js included on the page
     * @type {any}
     * @memberof Chart
     */
    highchartConfig?: any;
    /**
     * Ex: correlationScatterPlot
     * @type {string}
     * @memberof Chart
     */
    chartId?: string;
    /**
     * Ex: Overall Mood following Sleep Duration (R = -0.173)
     * @type {string}
     * @memberof Chart
     */
    chartTitle?: string;
    /**
     * Ex: The chart above indicates that an increase in Sleep Duration is usually followed by an decrease in Overall Mood.
     * @type {string}
     * @memberof Chart
     */
    explanation?: string;
    /**
     * Url to a static svg of the chart
     * @type {string}
     * @memberof Chart
     */
    svgUrl?: string;
    /**
     * SVG string than can be embedded directly in HTML
     * @type {string}
     * @memberof Chart
     */
    svg?: string;
}

/**
 * 
 * @export
 * @interface CommonResponse
 */
export interface CommonResponse {
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof CommonResponse
     */
    description: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof CommonResponse
     */
    summary: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof CommonResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof CommonResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof CommonResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof CommonResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof CommonResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof CommonResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface ConnectInstructions
 */
export interface ConnectInstructions {
    /**
     * Create a form with these fields and post the key and user submitted value to the provided connect url
     * @type {Array<any>}
     * @memberof ConnectInstructions
     */
    parameters?: Array<any>;
    /**
     * URL to open to connect
     * @type {string}
     * @memberof ConnectInstructions
     */
    url: string;
    /**
     * True if should open auth window in popup
     * @type {boolean}
     * @memberof ConnectInstructions
     */
    usePopup?: boolean;
}

/**
 * 
 * @export
 * @interface ConversionStep
 */
export interface ConversionStep {
    /**
     * ADD or MULTIPLY
     * @type {string}
     * @memberof ConversionStep
     */
    operation: ConversionStep.OperationEnum;
    /**
     * This specifies the order of conversion steps starting with 0
     * @type {number}
     * @memberof ConversionStep
     */
    value: number;
}

/**
 * @export
 * @namespace ConversionStep
 */
export namespace ConversionStep {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        ADD = <any> 'ADD',
        MULTIPLY = <any> 'MULTIPLY'
    }
}

/**
 * 
 * @export
 * @interface Correlation
 */
export interface Correlation {
    /**
     * Ex: 4.19
     * @type {number}
     * @memberof Correlation
     */
    averageDailyHighCause?: number;
    /**
     * Ex: 1.97
     * @type {number}
     * @memberof Correlation
     */
    averageDailyLowCause?: number;
    /**
     * Ex: 3.0791054117396
     * @type {number}
     * @memberof Correlation
     */
    averageEffect?: number;
    /**
     * Ex: 3.55
     * @type {number}
     * @memberof Correlation
     */
    averageEffectFollowingHighCause?: number;
    /**
     * Ex: 2.65
     * @type {number}
     * @memberof Correlation
     */
    averageEffectFollowingLowCause?: number;
    /**
     * Ex: 0.396
     * @type {number}
     * @memberof Correlation
     */
    averageForwardPearsonCorrelationOverOnsetDelays?: number;
    /**
     * Ex: 0.453667
     * @type {number}
     * @memberof Correlation
     */
    averageReversePearsonCorrelationOverOnsetDelays?: number;
    /**
     * Ex: 0.9855
     * @type {number}
     * @memberof Correlation
     */
    averageVote?: number;
    /**
     * Ex: 164
     * @type {number}
     * @memberof Correlation
     */
    causeChanges?: number;
    /**
     * 
     * @type {DataSource}
     * @memberof Correlation
     */
    causeDataSource?: DataSource;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Correlation
     */
    causeUserVariableShareUserMeasurements?: number;
    /**
     * Ex: 6
     * @type {number}
     * @memberof Correlation
     */
    causeVariableCategoryId?: number;
    /**
     * Ex: Sleep
     * @type {string}
     * @memberof Correlation
     */
    causeVariableCategoryName?: string;
    /**
     * Ex: MEAN
     * @type {string}
     * @memberof Correlation
     */
    causeVariableCombinationOperation?: string;
    /**
     * Ex: /5
     * @type {string}
     * @memberof Correlation
     */
    causeVariableUnitAbbreviatedName?: string;
    /**
     * Ex: 1448
     * @type {number}
     * @memberof Correlation
     */
    causeVariableId?: number;
    /**
     * Ex: 6
     * @type {number}
     * @memberof Correlation
     */
    causeVariableMostCommonConnectorId?: number;
    /**
     * Ex: Sleep Quality
     * @type {string}
     * @memberof Correlation
     */
    causeVariableName: string;
    /**
     * Ex: 0.14344467795996
     * @type {number}
     * @memberof Correlation
     */
    confidenceInterval?: number;
    /**
     * Ex: high
     * @type {string}
     * @memberof Correlation
     */
    confidenceLevel?: string;
    /**
     * Ex: 0.538
     * @type {number}
     * @memberof Correlation
     */
    correlationCoefficient?: number;
    /**
     * Ex: false
     * @type {boolean}
     * @memberof Correlation
     */
    correlationIsContradictoryToOptimalValues?: boolean;
    /**
     * Ex: 2016-12-28 20:47:30 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof Correlation
     */
    createdAt?: string;
    /**
     * Calculated Statistic: Ex: 1.646
     * @type {number}
     * @memberof Correlation
     */
    criticalTValue?: number;
    /**
     * Ex: higher
     * @type {string}
     * @memberof Correlation
     */
    direction?: string;
    /**
     * User-Defined Variable Setting: The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.  Unit: Seconds
     * @type {number}
     * @memberof Correlation
     */
    durationOfAction?: number;
    /**
     * User-Defined Variable Setting: The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.  Unit: Hours
     * @type {number}
     * @memberof Correlation
     */
    durationOfActionInHours?: number;
    /**
     * Ex: 200
     * @type {number}
     * @memberof Correlation
     */
    degreesOfFreedom?: number;
    /**
     * Ex: 145
     * @type {number}
     * @memberof Correlation
     */
    effectNumberOfProcessedDailyMeasurements?: number;
    /**
     * Ex: optimalPearsonProduct is not defined
     * @type {string}
     * @memberof Correlation
     */
    error?: string;
    /**
     * Ex: 193
     * @type {number}
     * @memberof Correlation
     */
    effectChanges?: number;
    /**
     * 
     * @type {DataSource}
     * @memberof Correlation
     */
    effectDataSource?: DataSource;
    /**
     * Ex: moderately positive
     * @type {string}
     * @memberof Correlation
     */
    effectSize?: string;
    /**
     * Ex: /5
     * @type {string}
     * @memberof Correlation
     */
    effectUnit?: string;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Correlation
     */
    effectUserVariableShareUserMeasurements?: number;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Correlation
     */
    effectVariableCategoryId?: number;
    /**
     * Ex: Emotions
     * @type {string}
     * @memberof Correlation
     */
    effectVariableCategoryName?: string;
    /**
     * Ex: MEAN
     * @type {string}
     * @memberof Correlation
     */
    effectVariableCombinationOperation?: string;
    /**
     * Ex: Mood_(psychology)
     * @type {string}
     * @memberof Correlation
     */
    effectVariableCommonAlias?: string;
    /**
     * Ex: /5
     * @type {string}
     * @memberof Correlation
     */
    effectVariableUnitAbbreviatedName?: string;
    /**
     * Ex: 10
     * @type {number}
     * @memberof Correlation
     */
    effectVariableUnitId?: number;
    /**
     * Ex: 1 to 5 Rating
     * @type {string}
     * @memberof Correlation
     */
    effectVariableUnitName?: string;
    /**
     * Ex: 1398
     * @type {number}
     * @memberof Correlation
     */
    effectVariableId?: number;
    /**
     * Ex: 10
     * @type {number}
     * @memberof Correlation
     */
    effectVariableMostCommonConnectorId?: number;
    /**
     * Ex: Overall Mood
     * @type {string}
     * @memberof Correlation
     */
    effectVariableName: string;
    /**
     * Ex: 2014-07-30 12:50:00 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof Correlation
     */
    experimentEndTime?: string;
    /**
     * Ex: 2012-05-06 21:15:00 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof Correlation
     */
    experimentStartTime?: string;
    /**
     * Ex: 0.528359
     * @type {number}
     * @memberof Correlation
     */
    forwardSpearmanCorrelationCoefficient?: number;
    /**
     * Ex: 298
     * @type {number}
     * @memberof Correlation
     */
    numberOfPairs?: number;
    /**
     * Ex: 0
     * @type {number}
     * @memberof Correlation
     */
    onsetDelay?: number;
    /**
     * Ex: 0
     * @type {number}
     * @memberof Correlation
     */
    onsetDelayInHours?: number;
    /**
     * Ex: -86400
     * @type {number}
     * @memberof Correlation
     */
    onsetDelayWithStrongestPearsonCorrelation?: number;
    /**
     * Ex: -24
     * @type {number}
     * @memberof Correlation
     */
    onsetDelayWithStrongestPearsonCorrelationInHours?: number;
    /**
     * Ex: 0.68582816186982
     * @type {number}
     * @memberof Correlation
     */
    optimalPearsonProduct?: number;
    /**
     * User-Defined Variable Setting: Ex: -1. Unit: User-specified or common.
     * @type {number}
     * @memberof Correlation
     */
    outcomeFillingValue?: number;
    /**
     * User-Defined Variable Setting: Ex: 23. Unit: User-specified or common.
     * @type {number}
     * @memberof Correlation
     */
    outcomeMaximumAllowedValue?: number;
    /**
     * User-Defined Variable Setting: Ex: 0.1. Unit: User-specified or common.
     * @type {number}
     * @memberof Correlation
     */
    outcomeMinimumAllowedValue?: number;
    /**
     * Ex: 0.477
     * @type {number}
     * @memberof Correlation
     */
    pearsonCorrelationWithNoOnsetDelay?: number;
    /**
     * Ex: 0.538
     * @type {number}
     * @memberof Correlation
     */
    predictivePearsonCorrelation?: number;
    /**
     * Ex: 0.538
     * @type {number}
     * @memberof Correlation
     */
    predictivePearsonCorrelationCoefficient?: number;
    /**
     * Ex: RescueTime
     * @type {string}
     * @memberof Correlation
     */
    predictorDataSources?: string;
    /**
     * Ex: -1. Unit: User-specified or common.
     * @type {number}
     * @memberof Correlation
     */
    predictorFillingValue?: number;
    /**
     * Ex: 200. Unit: User-specified or common.
     * @type {number}
     * @memberof Correlation
     */
    predictorMaximumAllowedValue?: number;
    /**
     * Ex: 30. Unit: User-specified or common.
     * @type {number}
     * @memberof Correlation
     */
    predictorMinimumAllowedValue?: number;
    /**
     * Ex: 17. Unit: User-specified or common.
     * @type {number}
     * @memberof Correlation
     */
    predictsHighEffectChange?: number;
    /**
     * Ex: -11. Unit: User-specified or common.
     * @type {number}
     * @memberof Correlation
     */
    predictsLowEffectChange?: number;
    /**
     * Ex: 0.39628900511586
     * @type {number}
     * @memberof Correlation
     */
    pValue?: number;
    /**
     * Ex: 0.528
     * @type {number}
     * @memberof Correlation
     */
    qmScore?: number;
    /**
     * Ex: 0.01377184270977
     * @type {number}
     * @memberof Correlation
     */
    reversePearsonCorrelationCoefficient?: number;
    /**
     * Would you like to make this study publicly visible?
     * @type {boolean}
     * @memberof Correlation
     */
    shareUserMeasurements?: boolean;
    /**
     * Ex: N1 Study: Sleep Quality Predicts Higher Overall Mood
     * @type {string}
     * @memberof Correlation
     */
    sharingDescription?: string;
    /**
     * Ex: N1 Study: Sleep Quality Predicts Higher Overall Mood
     * @type {string}
     * @memberof Correlation
     */
    sharingTitle?: string;
    /**
     * Ex: 1
     * @type {boolean}
     * @memberof Correlation
     */
    significantDifference?: boolean;
    /**
     * Ex: 0.9813
     * @type {number}
     * @memberof Correlation
     */
    statisticalSignificance?: number;
    /**
     * Ex: moderate
     * @type {string}
     * @memberof Correlation
     */
    strengthLevel?: string;
    /**
     * Ex: 0.613
     * @type {number}
     * @memberof Correlation
     */
    strongestPearsonCorrelationCoefficient?: number;
    /**
     * 
     * @type {StudyHtml}
     * @memberof Correlation
     */
    studyHtml?: StudyHtml;
    /**
     * 
     * @type {StudyImages}
     * @memberof Correlation
     */
    studyImages?: StudyImages;
    /**
     * 
     * @type {StudyLinks}
     * @memberof Correlation
     */
    studyLinks?: StudyLinks;
    /**
     * 
     * @type {StudyText}
     * @memberof Correlation
     */
    studyText?: StudyText;
    /**
     * Ex: 9.6986079652717
     * @type {number}
     * @memberof Correlation
     */
    tValue?: number;
    /**
     * Ex: 2017-05-06 15:40:38 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof Correlation
     */
    updatedAt?: string;
    /**
     * Ex: 230
     * @type {number}
     * @memberof Correlation
     */
    userId?: number;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Correlation
     */
    userVote?: number;
    /**
     * Ex: 4.14
     * @type {number}
     * @memberof Correlation
     */
    valuePredictingHighOutcome?: number;
    /**
     * Ex: 3.03
     * @type {number}
     * @memberof Correlation
     */
    valuePredictingLowOutcome?: number;
    /**
     * Sources used to collect data for the outcome variable
     * @type {string}
     * @memberof Correlation
     */
    outcomeDataSources?: string;
    /**
     * Mike Sinn
     * @type {string}
     * @memberof Correlation
     */
    principalInvestigator?: string;
    /**
     * Correlation when cause and effect are reversed. For any causal relationship, the forward correlation should exceed the reverse correlation.
     * @type {number}
     * @memberof Correlation
     */
    reverseCorrelation?: number;
    /**
     * Ex: 
     * @type {number}
     * @memberof Correlation
     */
    averagePearsonCorrelationCoefficientOverOnsetDelays?: number;
    /**
     * Ex: 14764
     * @type {number}
     * @memberof Correlation
     */
    causeNumberOfRawMeasurements?: number;
    /**
     * Correlations calculated with various duration of action hyper-parameters
     * @type {Array<Correlation>}
     * @memberof Correlation
     */
    correlationsOverDurationsOfAction?: Array<Correlation>;
    /**
     * Correlations calculated with various onset delay hyper-parameters
     * @type {Array<Correlation>}
     * @memberof Correlation
     */
    correlationsOverOnsetDelays?: Array<Correlation>;
    /**
     * Highchart config illustrating correlations calculated with various duration of action hyper-parameters
     * @type {any}
     * @memberof Correlation
     */
    correlationsOverDurationsOfActionChartConfig?: any;
    /**
     * Highchart config illustrating correlations calculated with various onset delay hyper-parameters
     * @type {any}
     * @memberof Correlation
     */
    correlationsOverOnsetDelaysChartConfig?: any;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Correlation
     */
    numberOfUsers?: number;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Correlation
     */
    rawCauseMeasurementSignificance?: number;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Correlation
     */
    rawEffectMeasurementSignificance?: number;
    /**
     * Ex: 1
     * @type {string}
     * @memberof Correlation
     */
    reversePairsCount?: string;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Correlation
     */
    voteStatisticalSignificance?: number;
    /**
     * Ex: 0.011598441286655
     * @type {number}
     * @memberof Correlation
     */
    aggregateQMScore?: number;
    /**
     * Ex: 0.0333
     * @type {number}
     * @memberof Correlation
     */
    forwardPearsonCorrelationCoefficient?: number;
    /**
     * Ex: 6
     * @type {number}
     * @memberof Correlation
     */
    numberOfCorrelations?: number;
    /**
     * Ex: 1 or 0
     * @type {number}
     * @memberof Correlation
     */
    vote?: number;
}

/**
 * 
 * @export
 * @interface DataSource
 */
export interface DataSource {
    /**
     * Ex: true
     * @type {boolean}
     * @memberof DataSource
     */
    affiliate: boolean;
    /**
     * Background color HEX code that matches the icon
     * @type {string}
     * @memberof DataSource
     */
    backgroundColor?: string;
    /**
     * 
     * @type {Array<Button>}
     * @memberof DataSource
     */
    buttons?: Array<Button>;
    /**
     * Card containing instructions, image, text, link and relevant import buttons
     * @type {Card}
     * @memberof DataSource
     */
    card?: Card;
    /**
     * Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @type {string}
     * @memberof DataSource
     */
    clientId?: string;
    /**
     * True if the authenticated user has this connector enabled
     * @type {boolean}
     * @memberof DataSource
     */
    connected?: boolean;
    /**
     * Ex: Your token is expired. Please re-connect
     * @type {string}
     * @memberof DataSource
     */
    connectError?: string;
    /**
     * URL and parameters used when connecting to a service
     * @type {ConnectInstructions}
     * @memberof DataSource
     */
    connectInstructions?: ConnectInstructions;
    /**
     * Ex: 8
     * @type {number}
     * @memberof DataSource
     */
    connectorId?: number;
    /**
     * Ex: CONNECTED
     * @type {string}
     * @memberof DataSource
     */
    connectStatus?: string;
    /**
     * Number of measurements from this source or number of users who have measurements from this source
     * @type {number}
     * @memberof DataSource
     */
    count?: number;
    /**
     * Ex: 2000-01-01 00:00:00 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof DataSource
     */
    createdAt?: string;
    /**
     * Ex: ba7d0c12432650e23b3ce924ae2d21e2ff59e7e4e28650759633700af7ed0a30
     * @type {string}
     * @memberof DataSource
     */
    connectorClientId: string;
    /**
     * Ex: Foods
     * @type {string}
     * @memberof DataSource
     */
    defaultVariableCategoryName: string;
    /**
     * Ex: QuantiModo
     * @type {string}
     * @memberof DataSource
     */
    displayName: string;
    /**
     * Ex: 0
     * @type {number}
     * @memberof DataSource
     */
    enabled: number;
    /**
     * Ex: https://quantimo.do
     * @type {string}
     * @memberof DataSource
     */
    getItUrl: string;
    /**
     * Ex: 72
     * @type {number}
     * @memberof DataSource
     */
    id: number;
    /**
     * Ex: https://web.quantimo.do/img/logos/quantimodo-logo-qm-rainbow-200-200.png
     * @type {string}
     * @memberof DataSource
     */
    image: string;
    /**
     * Ex: <a href=\"https://quantimo.do\"><img id=\"quantimodo_image\" title=\"QuantiModo\" src=\"https://web.quantimo.do/img/logos/quantimodo-logo-qm-rainbow-200-200.png\" alt=\"QuantiModo\"></a>
     * @type {string}
     * @memberof DataSource
     */
    imageHtml: string;
    /**
     * Ex: 2017-07-31 10:10:34 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof DataSource
     */
    lastSuccessfulUpdatedAt?: string;
    /**
     * Epoch timestamp of last sync
     * @type {number}
     * @memberof DataSource
     */
    lastUpdate?: number;
    /**
     * Ex: <a href=\"https://quantimo.do\">QuantiModo</a>
     * @type {string}
     * @memberof DataSource
     */
    linkedDisplayNameHtml: string;
    /**
     * Ex: QuantiModo is a Chrome extension, Android app, iOS app, and web app that allows you to easily track mood, symptoms, or any outcome you want to optimize in a fraction of a second.  You can also import your data from over 30 other apps and devices like Fitbit, Rescuetime, Jawbone Up, Withings, Facebook, Github, Google Calendar, Runkeeper, MoodPanda, Slice, Google Fit, and more.  QuantiModo then analyzes your data to identify which hidden factors are most likely to be influencing your mood or symptoms and their optimal daily values.
     * @type {string}
     * @memberof DataSource
     */
    longDescription: string;
    /**
     * Ex: Got 412 new measurements on 2017-07-31 10:10:34
     * @type {string}
     * @memberof DataSource
     */
    message?: string;
    /**
     * Mobile connect method: webview, cordova, google, spreadsheet, or ip
     * @type {string}
     * @memberof DataSource
     */
    mobileConnectMethod?: string;
    /**
     * Ex: quantimodo
     * @type {string}
     * @memberof DataSource
     */
    name: string;
    /**
     * Platforms (chrome, android, ios, web) that you can connect on.
     * @type {Array<string>}
     * @memberof DataSource
     */
    platforms?: Array<string>;
    /**
     * True if connection requires upgrade
     * @type {boolean}
     * @memberof DataSource
     */
    premium?: boolean;
    /**
     * Required connector scopes
     * @type {Array<string>}
     * @memberof DataSource
     */
    scopes?: Array<string>;
    /**
     * Ex: Tracks anything
     * @type {string}
     * @memberof DataSource
     */
    shortDescription: string;
    /**
     * URL to POST a spreadsheet to (if available for this data source)
     * @type {string}
     * @memberof DataSource
     */
    spreadsheetUploadLink?: string;
    /**
     * Number of measurements obtained during latest update
     * @type {number}
     * @memberof DataSource
     */
    totalMeasurementsInLastUpdate?: number;
    /**
     * Ex: 2017-07-31 10:10:34 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof DataSource
     */
    updatedAt?: string;
    /**
     * Ex: 2017-07-18 05:16:31 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof DataSource
     */
    updateRequestedAt?: string;
    /**
     * Ex: UPDATED
     * @type {string}
     * @memberof DataSource
     */
    updateStatus?: string;
    /**
     * Ex: 230
     * @type {number}
     * @memberof DataSource
     */
    userId?: number;
}

/**
 * 
 * @export
 * @interface DeviceToken
 */
export interface DeviceToken {
    /**
     * Client id
     * @type {string}
     * @memberof DeviceToken
     */
    clientId?: string;
    /**
     * ios, android, or web
     * @type {string}
     * @memberof DeviceToken
     */
    platform: string;
    /**
     * The device token
     * @type {string}
     * @memberof DeviceToken
     */
    deviceToken: string;
}

/**
 * 
 * @export
 * @interface Explanation
 */
export interface Explanation {
    /**
     * Ex: These factors are most predictive of Overall Mood based on your own data.
     * @type {string}
     * @memberof Explanation
     */
    description: string;
    /**
     * 
     * @type {Image}
     * @memberof Explanation
     */
    image: Image;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof Explanation
     */
    ionIcon: string;
    /**
     * 
     * @type {ExplanationStartTracking}
     * @memberof Explanation
     */
    startTracking: ExplanationStartTracking;
    /**
     * Ex: Top Predictors of Overall Mood
     * @type {string}
     * @memberof Explanation
     */
    title: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof Explanation
     */
    html?: string;
}

/**
 * 
 * @export
 * @interface ExplanationStartTracking
 */
export interface ExplanationStartTracking {
    /**
     * 
     * @type {Button}
     * @memberof ExplanationStartTracking
     */
    button: Button;
    /**
     * Ex: The more data I have the more accurate your results will be so track regularly!
     * @type {string}
     * @memberof ExplanationStartTracking
     */
    description: string;
    /**
     * Ex: Improve Accuracy
     * @type {string}
     * @memberof ExplanationStartTracking
     */
    title: string;
}

/**
 * 
 * @export
 * @interface FeedResponse
 */
export interface FeedResponse {
    /**
     * 
     * @type {Array<Card>}
     * @memberof FeedResponse
     */
    cards: Array<Card>;
    /**
     * Tracking reminder notifications, messages, and study result cards that can be displayed in user feed or stream
     * @type {string}
     * @memberof FeedResponse
     */
    description: string;
    /**
     * Tracking reminder notifications, messages, and study results
     * @type {string}
     * @memberof FeedResponse
     */
    summary: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof FeedResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof FeedResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof FeedResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof FeedResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof FeedResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof FeedResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface Friend
 */
export interface Friend {
    /**
     * What do you expect?
     * @type {number}
     * @memberof Friend
     */
    id: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Friend
     */
    initiatorUserId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Friend
     */
    friendUserId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Friend
     */
    isConfirmed: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Friend
     */
    isLimited: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Friend
     */
    dateCreated: string;
    /**
     * Additional friend key-value data
     * @type {Array<any>}
     * @memberof Friend
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface FriendsResponse
 */
export interface FriendsResponse {
    /**
     * 
     * @type {Array<Friend>}
     * @memberof FriendsResponse
     */
    friends: Array<Friend>;
    /**
     * Friend
     * @type {string}
     * @memberof FriendsResponse
     */
    description?: string;
    /**
     * Friend
     * @type {string}
     * @memberof FriendsResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof FriendsResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof FriendsResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof FriendsResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof FriendsResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof FriendsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof FriendsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof FriendsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof FriendsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof FriendsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof FriendsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface GetConnectorsResponse
 */
export interface GetConnectorsResponse {
    /**
     * 
     * @type {Array<DataSource>}
     * @memberof GetConnectorsResponse
     */
    connectors?: Array<DataSource>;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof GetConnectorsResponse
     */
    description: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof GetConnectorsResponse
     */
    summary: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof GetConnectorsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof GetConnectorsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof GetConnectorsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof GetConnectorsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof GetConnectorsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof GetConnectorsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface GetCorrelationsDataResponse
 */
export interface GetCorrelationsDataResponse {
    /**
     * 
     * @type {Array<Correlation>}
     * @memberof GetCorrelationsDataResponse
     */
    correlations: Array<Correlation>;
    /**
     * 
     * @type {Explanation}
     * @memberof GetCorrelationsDataResponse
     */
    explanation: Explanation;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof GetCorrelationsDataResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof GetCorrelationsDataResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof GetCorrelationsDataResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof GetCorrelationsDataResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof GetCorrelationsDataResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof GetCorrelationsDataResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof GetCorrelationsDataResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof GetCorrelationsDataResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface GetCorrelationsResponse
 */
export interface GetCorrelationsResponse {
    /**
     * 
     * @type {GetCorrelationsDataResponse}
     * @memberof GetCorrelationsResponse
     */
    data?: GetCorrelationsDataResponse;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof GetCorrelationsResponse
     */
    description: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof GetCorrelationsResponse
     */
    summary: string;
    /**
     * Square icon png url
     * @type {string}
     * @memberof GetCorrelationsResponse
     */
    avatar?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof GetCorrelationsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof GetCorrelationsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof GetCorrelationsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof GetCorrelationsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof GetCorrelationsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof GetCorrelationsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface GetSharesResponse
 */
export interface GetSharesResponse {
    /**
     * 
     * @type {AuthorizedClients}
     * @memberof GetSharesResponse
     */
    authorizedClients?: AuthorizedClients;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof GetSharesResponse
     */
    description: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof GetSharesResponse
     */
    summary: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof GetSharesResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof GetSharesResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof GetSharesResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof GetSharesResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof GetSharesResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof GetSharesResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface GetStudiesResponse
 */
export interface GetStudiesResponse {
    /**
     * 
     * @type {Array<Study>}
     * @memberof GetStudiesResponse
     */
    studies?: Array<Study>;
    /**
     * Ex: These factors are most predictive of Overall Mood based on your own data.
     * @type {string}
     * @memberof GetStudiesResponse
     */
    description: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof GetStudiesResponse
     */
    summary: string;
    /**
     * 
     * @type {Image}
     * @memberof GetStudiesResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof GetStudiesResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof GetStudiesResponse
     */
    ionIcon?: string;
    /**
     * 
     * @type {ExplanationStartTracking}
     * @memberof GetStudiesResponse
     */
    startTracking?: ExplanationStartTracking;
    /**
     * Ex: Top Predictors of Overall Mood
     * @type {string}
     * @memberof GetStudiesResponse
     */
    title?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof GetStudiesResponse
     */
    html?: string;
}

/**
 * 
 * @export
 * @interface GetTrackingReminderNotificationsResponse
 */
export interface GetTrackingReminderNotificationsResponse {
    /**
     * 
     * @type {Array<TrackingReminderNotification>}
     * @memberof GetTrackingReminderNotificationsResponse
     */
    data?: Array<TrackingReminderNotification>;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof GetTrackingReminderNotificationsResponse
     */
    description: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof GetTrackingReminderNotificationsResponse
     */
    summary: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof GetTrackingReminderNotificationsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof GetTrackingReminderNotificationsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof GetTrackingReminderNotificationsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof GetTrackingReminderNotificationsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof GetTrackingReminderNotificationsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof GetTrackingReminderNotificationsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * What do you expect?
     * @type {number}
     * @memberof Group
     */
    id: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Group
     */
    creatorId: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Group
     */
    name: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Group
     */
    slug: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Group
     */
    description: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Group
     */
    status: string;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Group
     */
    parentId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Group
     */
    enableForum: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Group
     */
    dateCreated: string;
    /**
     * Additional group key-value data
     * @type {Array<any>}
     * @memberof Group
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface GroupsMember
 */
export interface GroupsMember {
    /**
     * What do you expect?
     * @type {number}
     * @memberof GroupsMember
     */
    id: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof GroupsMember
     */
    groupId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof GroupsMember
     */
    userId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof GroupsMember
     */
    inviterId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof GroupsMember
     */
    isAdmin: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof GroupsMember
     */
    isMod: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof GroupsMember
     */
    userTitle: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof GroupsMember
     */
    dateModified: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof GroupsMember
     */
    comments: string;
    /**
     * What do you expect?
     * @type {number}
     * @memberof GroupsMember
     */
    isConfirmed: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof GroupsMember
     */
    isBanned: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof GroupsMember
     */
    inviteSent: number;
    /**
     * Additional groupsmember key-value data
     * @type {Array<any>}
     * @memberof GroupsMember
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface GroupsMembersResponse
 */
export interface GroupsMembersResponse {
    /**
     * 
     * @type {Array<GroupsMember>}
     * @memberof GroupsMembersResponse
     */
    groupsMembers: Array<GroupsMember>;
    /**
     * GroupsMember
     * @type {string}
     * @memberof GroupsMembersResponse
     */
    description?: string;
    /**
     * GroupsMember
     * @type {string}
     * @memberof GroupsMembersResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof GroupsMembersResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof GroupsMembersResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof GroupsMembersResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof GroupsMembersResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof GroupsMembersResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof GroupsMembersResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof GroupsMembersResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof GroupsMembersResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof GroupsMembersResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof GroupsMembersResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface GroupsResponse
 */
export interface GroupsResponse {
    /**
     * 
     * @type {Array<Group>}
     * @memberof GroupsResponse
     */
    groups: Array<Group>;
    /**
     * Group
     * @type {string}
     * @memberof GroupsResponse
     */
    description?: string;
    /**
     * Group
     * @type {string}
     * @memberof GroupsResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof GroupsResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof GroupsResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof GroupsResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof GroupsResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof GroupsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof GroupsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof GroupsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof GroupsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof GroupsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof GroupsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * Ex: 240
     * @type {string}
     * @memberof Image
     */
    height: string;
    /**
     * Ex: https://www.filepicker.io/api/file/TjmeNWS5Q2SFmtJlUGLf
     * @type {string}
     * @memberof Image
     */
    imageUrl: string;
    /**
     * Ex: 224
     * @type {string}
     * @memberof Image
     */
    width: string;
}

/**
 * 
 * @export
 * @interface InputField
 */
export interface InputField {
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    displayName: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    helpText?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    hint?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    icon?: string;
    /**
     * HTML element id
     * @type {string}
     * @memberof InputField
     */
    id?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    image?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    key?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    labelLeft?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    labelRight?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    link?: string;
    /**
     * What do you expect?
     * @type {number}
     * @memberof InputField
     */
    maxLength?: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof InputField
     */
    maxValue?: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof InputField
     */
    minLength?: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof InputField
     */
    minValue?: number;
    /**
     * Selector list options
     * @type {Array<string>}
     * @memberof InputField
     */
    options?: Array<string>;
    /**
     * Ex: Title
     * @type {string}
     * @memberof InputField
     */
    placeholder?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    postUrl?: string;
    /**
     * What do you expect?
     * @type {boolean}
     * @memberof InputField
     */
    required?: boolean;
    /**
     * Ex: Title
     * @type {boolean}
     * @memberof InputField
     */
    show?: boolean;
    /**
     * 
     * @type {Button}
     * @memberof InputField
     */
    submitButton?: Button;
    /**
     * Ex: Title
     * @type {string}
     * @memberof InputField
     */
    type: InputField.TypeEnum;
    /**
     * See http://html5pattern.com/ for examples
     * @type {string}
     * @memberof InputField
     */
    validationPattern?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof InputField
     */
    value?: string;
}

/**
 * @export
 * @namespace InputField
 */
export namespace InputField {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CheckBox = <any> 'check_box',
        Date = <any> 'date',
        Email = <any> 'email',
        Number = <any> 'number',
        PostalCode = <any> 'postal_code',
        SelectOption = <any> 'select_option',
        String = <any> 'string',
        Switch = <any> 'switch',
        TextArea = <any> 'text_area',
        Unit = <any> 'unit',
        VariableCategory = <any> 'variable_category'
    }
}

/**
 * 
 * @export
 * @interface JsonErrorResponse
 */
export interface JsonErrorResponse {
    /**
     * Error message
     * @type {string}
     * @memberof JsonErrorResponse
     */
    message?: string;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof JsonErrorResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof JsonErrorResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof JsonErrorResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof JsonErrorResponse
     */
    status: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof JsonErrorResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof JsonErrorResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof JsonErrorResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof JsonErrorResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface Measurement
 */
export interface Measurement {
    /**
     * Card containing image, text, link and relevant buttons
     * @type {Card}
     * @memberof Measurement
     */
    card?: Card;
    /**
     * Ex: quantimodo
     * @type {string}
     * @memberof Measurement
     */
    clientId?: string;
    /**
     * Ex: 13
     * @type {number}
     * @memberof Measurement
     */
    connectorId?: number;
    /**
     * Ex: 2017-07-30 21:08:36
     * @type {string}
     * @memberof Measurement
     */
    createdAt?: string;
    /**
     * Examples: 3/5, $10, or 1 count
     * @type {string}
     * @memberof Measurement
     */
    displayValueAndUnitString?: string;
    /**
     * Ex: ion-sad-outline
     * @type {string}
     * @memberof Measurement
     */
    iconIcon?: string;
    /**
     * Ex: 1051466127
     * @type {number}
     * @memberof Measurement
     */
    id?: number;
    /**
     * Ex: value
     * @type {string}
     * @memberof Measurement
     */
    inputType?: string;
    /**
     * Ex: ion-ios-medkit-outline
     * @type {string}
     * @memberof Measurement
     */
    ionIcon?: string;
    /**
     * Ex: 1
     * @type {boolean}
     * @memberof Measurement
     */
    manualTracking?: boolean;
    /**
     * Ex: 5. Unit: User-specified or common.
     * @type {number}
     * @memberof Measurement
     */
    maximumAllowedValue?: number;
    /**
     * Ex: 1. Unit: User-specified or common.
     * @type {number}
     * @memberof Measurement
     */
    minimumAllowedValue?: number;
    /**
     * Note of measurement
     * @type {string}
     * @memberof Measurement
     */
    note?: string;
    /**
     * Additional meta data for the measurement
     * @type {any}
     * @memberof Measurement
     */
    noteObject?: any;
    /**
     * Embeddable HTML with message hyperlinked with associated url
     * @type {any}
     * @memberof Measurement
     */
    noteHtml?: any;
    /**
     * Ex: 23
     * @type {number}
     * @memberof Measurement
     */
    originalUnitId?: number;
    /**
     * Original value submitted. Unit: Originally submitted.
     * @type {number}
     * @memberof Measurement
     */
    originalValue?: number;
    /**
     * Ex: img/variable_categories/treatments.png
     * @type {string}
     * @memberof Measurement
     */
    pngPath?: string;
    /**
     * Ex: https://web.quantimo.do/img/variable_categories/treatments.png
     * @type {string}
     * @memberof Measurement
     */
    pngUrl?: string;
    /**
     * Link to associated product for purchase
     * @type {string}
     * @memberof Measurement
     */
    productUrl?: string;
    /**
     * Application or device used to record the measurement values
     * @type {string}
     * @memberof Measurement
     */
    sourceName: string;
    /**
     * Ex: 2014-08-27
     * @type {string}
     * @memberof Measurement
     */
    startDate?: string;
    /**
     * Seconds between the start of the event measured and 1970 (Unix timestamp)
     * @type {number}
     * @memberof Measurement
     */
    startTimeEpoch?: number;
    /**
     * Start Time for the measurement event in UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof Measurement
     */
    startTimeString: string;
    /**
     * Ex: https://web.quantimo.do/img/variable_categories/treatments.svg
     * @type {string}
     * @memberof Measurement
     */
    svgUrl?: string;
    /**
     * Abbreviated name for the unit of measurement
     * @type {string}
     * @memberof Measurement
     */
    unitAbbreviatedName: string;
    /**
     * Ex: 6
     * @type {number}
     * @memberof Measurement
     */
    unitCategoryId?: number;
    /**
     * Ex: Miscellany
     * @type {string}
     * @memberof Measurement
     */
    unitCategoryName?: string;
    /**
     * Ex: 23
     * @type {number}
     * @memberof Measurement
     */
    unitId?: number;
    /**
     * Ex: Count
     * @type {string}
     * @memberof Measurement
     */
    unitName?: string;
    /**
     * Ex: 2017-07-30 21:08:36
     * @type {string}
     * @memberof Measurement
     */
    updatedAt?: string;
    /**
     * Link to associated Facebook like or Github commit, for instance
     * @type {string}
     * @memberof Measurement
     */
    url?: string;
    /**
     * Ex: count
     * @type {string}
     * @memberof Measurement
     */
    userVariableUnitAbbreviatedName?: string;
    /**
     * Ex: 6
     * @type {number}
     * @memberof Measurement
     */
    userVariableUnitCategoryId?: number;
    /**
     * Ex: Miscellany
     * @type {string}
     * @memberof Measurement
     */
    userVariableUnitCategoryName?: string;
    /**
     * Ex: 23
     * @type {number}
     * @memberof Measurement
     */
    userVariableUnitId?: number;
    /**
     * Ex: Count
     * @type {string}
     * @memberof Measurement
     */
    userVariableUnitName?: string;
    /**
     * Ex: 13
     * @type {number}
     * @memberof Measurement
     */
    userVariableVariableCategoryId?: number;
    /**
     * Ex: Treatments
     * @type {string}
     * @memberof Measurement
     */
    userVariableVariableCategoryName?: string;
    /**
     * Valence indicates what type of buttons should be used when recording measurements for this variable. positive - Face buttons with the happiest face equating to a 5/5 rating where higher is better like Overall Mood. negative - Face buttons with happiest face equating to a 1/5 rating where lower is better like Headache Severity. numeric - Just 1 to 5 numeric buttons for neutral variables. 
     * @type {string}
     * @memberof Measurement
     */
    valence?: string;
    /**
     * Converted measurement value in requested unit
     * @type {number}
     * @memberof Measurement
     */
    value: number;
    /**
     * Ex: 13
     * @type {number}
     * @memberof Measurement
     */
    variableCategoryId?: number;
    /**
     * Ex: https://static.quantimo.do/img/variable_categories/pill-96.png
     * @type {string}
     * @memberof Measurement
     */
    variableCategoryImageUrl?: string;
    /**
     * Ex: Emotions, Treatments, Symptoms...
     * @type {string}
     * @memberof Measurement
     */
    variableCategoryName?: Measurement.VariableCategoryNameEnum;
    /**
     * Valence indicates what type of buttons should be used when recording measurements for this variable. positive - Face buttons with the happiest face equating to a 5/5 rating where higher is better like Overall Mood. negative - Face buttons with happiest face equating to a 1/5 rating where lower is better like Headache Severity. numeric - Just 1 to 5 numeric buttons for neutral variables. 
     * @type {string}
     * @memberof Measurement
     */
    variableDescription?: string;
    /**
     * Ex: 5956846
     * @type {number}
     * @memberof Measurement
     */
    variableId?: number;
    /**
     * Name of the variable for which we are creating the measurement records
     * @type {string}
     * @memberof Measurement
     */
    variableName: string;
    /**
     * Ex: Trader Joe's Bedtime Tea
     * @type {string}
     * @memberof Measurement
     */
    displayName?: string;
}

/**
 * @export
 * @namespace Measurement
 */
export namespace Measurement {
    /**
     * @export
     * @enum {string}
     */
    export enum VariableCategoryNameEnum {
        Activity = <any> 'Activity',
        Books = <any> 'Books',
        CausesOfIllness = <any> 'Causes of Illness',
        CognitivePerformance = <any> 'Cognitive Performance',
        Conditions = <any> 'Conditions',
        Emotions = <any> 'Emotions',
        Environment = <any> 'Environment',
        Foods = <any> 'Foods',
        Goals = <any> 'Goals',
        Locations = <any> 'Locations',
        Miscellaneous = <any> 'Miscellaneous',
        MoviesAndTV = <any> 'Movies and TV',
        Music = <any> 'Music',
        Nutrients = <any> 'Nutrients',
        Payments = <any> 'Payments',
        PhysicalActivities = <any> 'Physical Activities',
        Physique = <any> 'Physique',
        Sleep = <any> 'Sleep',
        SocialInteractions = <any> 'Social Interactions',
        Software = <any> 'Software',
        Symptoms = <any> 'Symptoms',
        Treatments = <any> 'Treatments',
        VitalSigns = <any> 'Vital Signs'
    }
}

/**
 * 
 * @export
 * @interface MeasurementDelete
 */
export interface MeasurementDelete {
    /**
     * Start time of the measurement to be deleted
     * @type {number}
     * @memberof MeasurementDelete
     */
    startTime?: number;
    /**
     * Variable id of the measurement to be deleted
     * @type {number}
     * @memberof MeasurementDelete
     */
    variableId?: number;
    /**
     * Name of the connector for which measurements should be deleted
     * @type {string}
     * @memberof MeasurementDelete
     */
    connectorName?: string;
    /**
     * Your app's client id
     * @type {string}
     * @memberof MeasurementDelete
     */
    clientId: string;
}

/**
 * 
 * @export
 * @interface MeasurementItem
 */
export interface MeasurementItem {
    /**
     * Optional note to include with the measurement
     * @type {string}
     * @memberof MeasurementItem
     */
    note?: string;
    /**
     * Timestamp for the measurement event in epoch time (unixtime)
     * @type {number}
     * @memberof MeasurementItem
     */
    timestamp: number;
    /**
     * Measurement value
     * @type {number}
     * @memberof MeasurementItem
     */
    value: number;
}

/**
 * 
 * @export
 * @interface MeasurementSet
 */
export interface MeasurementSet {
    /**
     * Way to aggregate measurements over time. SUM should be used for things like minutes of exercise.  If you use MEAN for exercise, then a person might exercise more minutes in one day but add separate measurements that were smaller.  So when we are doing correlational analysis, we would think that the person exercised less that day even though they exercised more.  Conversely, we must use MEAN for things such as ratings which cannot be SUMMED.
     * @type {string}
     * @memberof MeasurementSet
     */
    combinationOperation?: MeasurementSet.CombinationOperationEnum;
    /**
     * Array of timestamps, values, and optional notes
     * @type {Array<MeasurementItem>}
     * @memberof MeasurementSet
     */
    measurementItems: Array<MeasurementItem>;
    /**
     * Name of the application or device used to record the measurement values
     * @type {string}
     * @memberof MeasurementSet
     */
    sourceName: string;
    /**
     * Unit of measurement
     * @type {string}
     * @memberof MeasurementSet
     */
    unitAbbreviatedName: string;
    /**
     * Ex: Emotions, Treatments, Symptoms...
     * @type {string}
     * @memberof MeasurementSet
     */
    variableCategoryName?: MeasurementSet.VariableCategoryNameEnum;
    /**
     * ORIGINAL name of the variable for which we are creating the measurement records
     * @type {string}
     * @memberof MeasurementSet
     */
    variableName: string;
    /**
     * UPC or other barcode scan result
     * @type {string}
     * @memberof MeasurementSet
     */
    upc?: string;
}

/**
 * @export
 * @namespace MeasurementSet
 */
export namespace MeasurementSet {
    /**
     * @export
     * @enum {string}
     */
    export enum CombinationOperationEnum {
        MEAN = <any> 'MEAN',
        SUM = <any> 'SUM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VariableCategoryNameEnum {
        Activity = <any> 'Activity',
        Books = <any> 'Books',
        CausesOfIllness = <any> 'Causes of Illness',
        CognitivePerformance = <any> 'Cognitive Performance',
        Conditions = <any> 'Conditions',
        Emotions = <any> 'Emotions',
        Environment = <any> 'Environment',
        Foods = <any> 'Foods',
        Goals = <any> 'Goals',
        Locations = <any> 'Locations',
        Miscellaneous = <any> 'Miscellaneous',
        MoviesAndTV = <any> 'Movies and TV',
        Music = <any> 'Music',
        Nutrients = <any> 'Nutrients',
        Payments = <any> 'Payments',
        PhysicalActivities = <any> 'Physical Activities',
        Physique = <any> 'Physique',
        Sleep = <any> 'Sleep',
        SocialInteractions = <any> 'Social Interactions',
        Software = <any> 'Software',
        Symptoms = <any> 'Symptoms',
        Treatments = <any> 'Treatments',
        VitalSigns = <any> 'Vital Signs'
    }
}

/**
 * 
 * @export
 * @interface MeasurementUpdate
 */
export interface MeasurementUpdate {
    /**
     * Variable id of the measurement to be updated
     * @type {number}
     * @memberof MeasurementUpdate
     */
    id: number;
    /**
     * The new note for the measurement (optional)
     * @type {string}
     * @memberof MeasurementUpdate
     */
    note?: string;
    /**
     * The new timestamp for the the event in epoch seconds (optional)
     * @type {number}
     * @memberof MeasurementUpdate
     */
    startTime?: number;
    /**
     * The new value of for the measurement (optional)
     * @type {number}
     * @memberof MeasurementUpdate
     */
    value?: number;
}

/**
 * 
 * @export
 * @interface MessagesMessage
 */
export interface MessagesMessage {
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesMessage
     */
    id: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesMessage
     */
    threadId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesMessage
     */
    senderId: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof MessagesMessage
     */
    subject: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof MessagesMessage
     */
    message: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof MessagesMessage
     */
    dateSent: string;
    /**
     * Additional messagesmessage key-value data
     * @type {Array<any>}
     * @memberof MessagesMessage
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface MessagesMessagesResponse
 */
export interface MessagesMessagesResponse {
    /**
     * 
     * @type {Array<MessagesMessage>}
     * @memberof MessagesMessagesResponse
     */
    messagesMessages: Array<MessagesMessage>;
    /**
     * MessagesMessage
     * @type {string}
     * @memberof MessagesMessagesResponse
     */
    description?: string;
    /**
     * MessagesMessage
     * @type {string}
     * @memberof MessagesMessagesResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof MessagesMessagesResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof MessagesMessagesResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof MessagesMessagesResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof MessagesMessagesResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof MessagesMessagesResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof MessagesMessagesResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof MessagesMessagesResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof MessagesMessagesResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof MessagesMessagesResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof MessagesMessagesResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface MessagesNotice
 */
export interface MessagesNotice {
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesNotice
     */
    id: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof MessagesNotice
     */
    subject: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof MessagesNotice
     */
    message: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof MessagesNotice
     */
    dateSent: string;
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesNotice
     */
    isActive: number;
    /**
     * Additional messagesnotice key-value data
     * @type {Array<any>}
     * @memberof MessagesNotice
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface MessagesNoticesResponse
 */
export interface MessagesNoticesResponse {
    /**
     * 
     * @type {Array<MessagesNotice>}
     * @memberof MessagesNoticesResponse
     */
    messagesNotices: Array<MessagesNotice>;
    /**
     * MessagesNotice
     * @type {string}
     * @memberof MessagesNoticesResponse
     */
    description?: string;
    /**
     * MessagesNotice
     * @type {string}
     * @memberof MessagesNoticesResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof MessagesNoticesResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof MessagesNoticesResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof MessagesNoticesResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof MessagesNoticesResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof MessagesNoticesResponse
     */
    errors?: Array<Error>;
    /**
     * Error message
     * @type {string}
     * @memberof MessagesNoticesResponse
     */
    error?: string;
    /**
     * Error message
     * @type {string}
     * @memberof MessagesNoticesResponse
     */
    errorMessage?: string;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof MessagesNoticesResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof MessagesNoticesResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof MessagesNoticesResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof MessagesNoticesResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof MessagesNoticesResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface MessagesRecipient
 */
export interface MessagesRecipient {
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesRecipient
     */
    id: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesRecipient
     */
    userId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesRecipient
     */
    threadId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesRecipient
     */
    unreadCount: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesRecipient
     */
    senderOnly: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof MessagesRecipient
     */
    isDeleted: number;
    /**
     * Additional messagesrecipient key-value data
     * @type {Array<any>}
     * @memberof MessagesRecipient
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface MessagesRecipientsResponse
 */
export interface MessagesRecipientsResponse {
    /**
     * 
     * @type {Array<MessagesRecipient>}
     * @memberof MessagesRecipientsResponse
     */
    messagesRecipients: Array<MessagesRecipient>;
    /**
     * MessagesRecipient
     * @type {string}
     * @memberof MessagesRecipientsResponse
     */
    description?: string;
    /**
     * MessagesRecipient
     * @type {string}
     * @memberof MessagesRecipientsResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof MessagesRecipientsResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof MessagesRecipientsResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof MessagesRecipientsResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof MessagesRecipientsResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof MessagesRecipientsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof MessagesRecipientsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof MessagesRecipientsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof MessagesRecipientsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof MessagesRecipientsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof MessagesRecipientsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    message: string;
}

/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * What do you expect?
     * @type {number}
     * @memberof Notification
     */
    id: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Notification
     */
    userId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Notification
     */
    itemId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Notification
     */
    secondaryItemId: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Notification
     */
    componentName: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Notification
     */
    componentAction: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Notification
     */
    dateNotified: string;
    /**
     * What do you expect?
     * @type {number}
     * @memberof Notification
     */
    isNew: number;
    /**
     * Additional notification key-value data
     * @type {Array<any>}
     * @memberof Notification
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface NotificationsResponse
 */
export interface NotificationsResponse {
    /**
     * 
     * @type {Array<Notification>}
     * @memberof NotificationsResponse
     */
    notifications: Array<Notification>;
    /**
     * Notification
     * @type {string}
     * @memberof NotificationsResponse
     */
    description?: string;
    /**
     * Notification
     * @type {string}
     * @memberof NotificationsResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof NotificationsResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof NotificationsResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof NotificationsResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof NotificationsResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof NotificationsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof NotificationsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof NotificationsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof NotificationsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof NotificationsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof NotificationsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface Pair
 */
export interface Pair {
    /**
     * Ex: 101341.66666667
     * @type {number}
     * @memberof Pair
     */
    causeMeasurement: number;
    /**
     * Ex: 101341.66666667
     * @type {number}
     * @memberof Pair
     */
    causeMeasurementValue: number;
    /**
     * Ex: mg
     * @type {string}
     * @memberof Pair
     */
    causeVariableUnitAbbreviatedName: string;
    /**
     * Ex: 7.98
     * @type {number}
     * @memberof Pair
     */
    effectMeasurement: number;
    /**
     * Ex: 7.98
     * @type {number}
     * @memberof Pair
     */
    effectMeasurementValue: number;
    /**
     * Ex: %
     * @type {string}
     * @memberof Pair
     */
    effectVariableUnitAbbreviatedName: string;
    /**
     * Ex: 2015-08-06 15:49:02 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof Pair
     */
    eventAt?: string;
    /**
     * Ex: 1438876142
     * @type {number}
     * @memberof Pair
     */
    eventAtUnixTime?: number;
    /**
     * Ex: 2015-08-06 15:49:02 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof Pair
     */
    startTimeString?: string;
    /**
     * Ex: 1464937200
     * @type {number}
     * @memberof Pair
     */
    timestamp: number;
}

/**
 * 
 * @export
 * @interface ParticipantInstruction
 */
export interface ParticipantInstruction {
    /**
     * Ex: <a href=\"https://www.amazon.com/Fitbit-Charge-Heart-Fitness-Wristband/dp/B01K9S260E/ref=as_li_ss_tl?ie=UTF8&qid=1493518902&sr=8-3&keywords=fitbit&th=1&linkCode=ll1&tag=quant08-20&linkId=b357b0833de73b0c4e935fd7c13a079e\">Obtain Fitbit</a> and use it to record your Sleep Duration. Once you have a <a href=\"https://www.amazon.com/Fitbit-Charge-Heart-Fitness-Wristband/dp/B01K9S260E/ref=as_li_ss_tl?ie=UTF8&qid=1493518902&sr=8-3&keywords=fitbit&th=1&linkCode=ll1&tag=quant08-20&linkId=b357b0833de73b0c4e935fd7c13a079e\">Fitbit</a> account, <a href=\"https://web.quantimo.do/#/app/import\">connect your  Fitbit account at QuantiModo</a> to automatically import and analyze your data.
     * @type {string}
     * @memberof ParticipantInstruction
     */
    instructionsForCauseVariable?: string;
    /**
     * Ex: <a href=\"https://quantimo.do\">Obtain QuantiModo</a> and use it to record your Overall Mood. Once you have a <a href=\"https://quantimo.do\">QuantiModo</a> account, <a href=\"https://web.quantimo.do/#/app/import\">connect your  QuantiModo account at QuantiModo</a> to automatically import and analyze your data.
     * @type {string}
     * @memberof ParticipantInstruction
     */
    instructionsForEffectVariable?: string;
}

/**
 * 
 * @export
 * @interface PostMeasurementsDataResponse
 */
export interface PostMeasurementsDataResponse {
    /**
     * 
     * @type {Array<Variable>}
     * @memberof PostMeasurementsDataResponse
     */
    userVariables?: Array<Variable>;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof PostMeasurementsDataResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof PostMeasurementsDataResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof PostMeasurementsDataResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof PostMeasurementsDataResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof PostMeasurementsDataResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof PostMeasurementsDataResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof PostMeasurementsDataResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof PostMeasurementsDataResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface PostMeasurementsResponse
 */
export interface PostMeasurementsResponse {
    /**
     * 
     * @type {PostMeasurementsDataResponse}
     * @memberof PostMeasurementsResponse
     */
    data?: PostMeasurementsDataResponse;
    /**
     * Message
     * @type {string}
     * @memberof PostMeasurementsResponse
     */
    message?: string;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof PostMeasurementsResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof PostMeasurementsResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof PostMeasurementsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof PostMeasurementsResponse
     */
    status: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof PostMeasurementsResponse
     */
    success: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof PostMeasurementsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof PostMeasurementsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof PostMeasurementsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface PostStudyCreateResponse
 */
export interface PostStudyCreateResponse {
    /**
     * 
     * @type {Study}
     * @memberof PostStudyCreateResponse
     */
    study?: Study;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof PostStudyCreateResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof PostStudyCreateResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof PostStudyCreateResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof PostStudyCreateResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof PostStudyCreateResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof PostStudyCreateResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof PostStudyCreateResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof PostStudyCreateResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface PostStudyPublishResponse
 */
export interface PostStudyPublishResponse {
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof PostStudyPublishResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof PostStudyPublishResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof PostStudyPublishResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof PostStudyPublishResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof PostStudyPublishResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof PostStudyPublishResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof PostStudyPublishResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof PostStudyPublishResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface PostTrackingRemindersDataResponse
 */
export interface PostTrackingRemindersDataResponse {
    /**
     * 
     * @type {Array<TrackingReminderNotification>}
     * @memberof PostTrackingRemindersDataResponse
     */
    trackingReminderNotifications?: Array<TrackingReminderNotification>;
    /**
     * 
     * @type {Array<TrackingReminder>}
     * @memberof PostTrackingRemindersDataResponse
     */
    trackingReminders?: Array<TrackingReminder>;
    /**
     * 
     * @type {Array<Variable>}
     * @memberof PostTrackingRemindersDataResponse
     */
    userVariables?: Array<Variable>;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof PostTrackingRemindersDataResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof PostTrackingRemindersDataResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof PostTrackingRemindersDataResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof PostTrackingRemindersDataResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof PostTrackingRemindersDataResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof PostTrackingRemindersDataResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof PostTrackingRemindersDataResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof PostTrackingRemindersDataResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface PostTrackingRemindersResponse
 */
export interface PostTrackingRemindersResponse {
    /**
     * 
     * @type {PostTrackingRemindersDataResponse}
     * @memberof PostTrackingRemindersResponse
     */
    data?: PostTrackingRemindersDataResponse;
    /**
     * Message
     * @type {string}
     * @memberof PostTrackingRemindersResponse
     */
    message?: string;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof PostTrackingRemindersResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof PostTrackingRemindersResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof PostTrackingRemindersResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof PostTrackingRemindersResponse
     */
    status: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof PostTrackingRemindersResponse
     */
    success: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof PostTrackingRemindersResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof PostTrackingRemindersResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof PostTrackingRemindersResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface PostUserSettingsDataResponse
 */
export interface PostUserSettingsDataResponse {
    /**
     * Ex: 1
     * @type {number}
     * @memberof PostUserSettingsDataResponse
     */
    purchaseId?: number;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof PostUserSettingsDataResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof PostUserSettingsDataResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof PostUserSettingsDataResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof PostUserSettingsDataResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof PostUserSettingsDataResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof PostUserSettingsDataResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof PostUserSettingsDataResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof PostUserSettingsDataResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface PostUserSettingsResponse
 */
export interface PostUserSettingsResponse {
    /**
     * 
     * @type {PostUserSettingsDataResponse}
     * @memberof PostUserSettingsResponse
     */
    data?: PostUserSettingsDataResponse;
    /**
     * Message
     * @type {string}
     * @memberof PostUserSettingsResponse
     */
    message?: string;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof PostUserSettingsResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof PostUserSettingsResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof PostUserSettingsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof PostUserSettingsResponse
     */
    status: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof PostUserSettingsResponse
     */
    success: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof PostUserSettingsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof PostUserSettingsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof PostUserSettingsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface ShareInvitationBody
 */
export interface ShareInvitationBody {
    /**
     * Enter the email address of the friend, family member, or health-care provider that you would like to give access to your measurements
     * @type {string}
     * @memberof ShareInvitationBody
     */
    emailAddress: string;
    /**
     * Name of the individual that the user wishes to have access to their measurements
     * @type {string}
     * @memberof ShareInvitationBody
     */
    name?: string;
    /**
     * Ex: I would like to share my measurements with you!
     * @type {string}
     * @memberof ShareInvitationBody
     */
    emailSubject?: string;
    /**
     * Ex: I would like to share my data with you so you can help me identify find discover hidden causes of and new treatments for my illness.
     * @type {string}
     * @memberof ShareInvitationBody
     */
    emailBody?: string;
    /**
     * Space separated list of scopes to grant to the recipient (i.e. readmeasurements, writemeasurements, measurements:read
     * @type {string}
     * @memberof ShareInvitationBody
     */
    scopes?: string;
}

/**
 * A study analyzes the relationship between a predictor variable like gluten-intake and an outcome of interest such as overall mood.
 * @export
 * @interface Study
 */
export interface Study {
    /**
     * Ex: population, cohort, or individual
     * @type {string}
     * @memberof Study
     */
    type: string;
    /**
     * The user id of the principal investigator or subject if an individual studies
     * @type {number}
     * @memberof Study
     */
    userId?: number;
    /**
     * ID of the cohort study which is necessary to allow participants to join
     * @type {string}
     * @memberof Study
     */
    id?: string;
    /**
     * 
     * @type {Variable}
     * @memberof Study
     */
    causeVariable?: Variable;
    /**
     * Ex: Sleep Quality
     * @type {string}
     * @memberof Study
     */
    causeVariableName?: string;
    /**
     * 
     * @type {StudyCharts}
     * @memberof Study
     */
    studyCharts?: StudyCharts;
    /**
     * 
     * @type {Variable}
     * @memberof Study
     */
    effectVariable?: Variable;
    /**
     * Ex: Overall Mood
     * @type {string}
     * @memberof Study
     */
    effectVariableName?: string;
    /**
     * 
     * @type {ParticipantInstruction}
     * @memberof Study
     */
    participantInstructions?: ParticipantInstruction;
    /**
     * 
     * @type {Correlation}
     * @memberof Study
     */
    statistics?: Correlation;
    /**
     * Contains a summary, images, sharing buttons, and links
     * @type {Card}
     * @memberof Study
     */
    studyCard?: Card;
    /**
     * 
     * @type {StudyHtml}
     * @memberof Study
     */
    studyHtml?: StudyHtml;
    /**
     * 
     * @type {StudyImages}
     * @memberof Study
     */
    studyImages?: StudyImages;
    /**
     * 
     * @type {StudyLinks}
     * @memberof Study
     */
    studyLinks?: StudyLinks;
    /**
     * 
     * @type {StudySharing}
     * @memberof Study
     */
    studySharing?: StudySharing;
    /**
     * 
     * @type {StudyText}
     * @memberof Study
     */
    studyText?: StudyText;
    /**
     * 
     * @type {StudyVotes}
     * @memberof Study
     */
    studyVotes?: StudyVotes;
    /**
     * True if you are sharing your data with this study
     * @type {boolean}
     * @memberof Study
     */
    joined?: boolean;
}

/**
 * An object with various chart properties each property contain and svg and Highcharts configuration
 * @export
 * @interface StudyCharts
 */
export interface StudyCharts {
    /**
     * 
     * @type {Chart}
     * @memberof StudyCharts
     */
    populationTraitScatterPlot?: Chart;
    /**
     * 
     * @type {Chart}
     * @memberof StudyCharts
     */
    outcomeDistributionColumnChart?: Chart;
    /**
     * 
     * @type {Chart}
     * @memberof StudyCharts
     */
    predictorDistributionColumnChart?: Chart;
    /**
     * 
     * @type {Chart}
     * @memberof StudyCharts
     */
    correlationScatterPlot?: Chart;
    /**
     * 
     * @type {Chart}
     * @memberof StudyCharts
     */
    pairsOverTimeLineChart?: Chart;
}

/**
 * 
 * @export
 * @interface StudyCreationBody
 */
export interface StudyCreationBody {
    /**
     * Name of predictor variable
     * @type {string}
     * @memberof StudyCreationBody
     */
    causeVariableName: string;
    /**
     * Name of the outcome variable
     * @type {string}
     * @memberof StudyCreationBody
     */
    effectVariableName: string;
    /**
     * Title of your study (optional)
     * @type {string}
     * @memberof StudyCreationBody
     */
    studyTitle?: string;
    /**
     * Individual studies are based on data of a single user. Group studies are based on data from a specific group of individuals who have joined.  Global studies are based on aggregated and anonymously shared data from all users.
     * @type {string}
     * @memberof StudyCreationBody
     */
    type: StudyCreationBody.TypeEnum;
}

/**
 * @export
 * @namespace StudyCreationBody
 */
export namespace StudyCreationBody {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Individual = <any> 'individual',
        Group = <any> 'group',
        Global = <any> 'global'
    }
}

/**
 * 
 * @export
 * @interface StudyHtml
 */
export interface StudyHtml {
    /**
     * Embeddable chart html
     * @type {string}
     * @memberof StudyHtml
     */
    chartHtml: string;
    /**
     * Play Store, App Store, Chrome Web Store
     * @type {string}
     * @memberof StudyHtml
     */
    downloadButtonsHtml?: string;
    /**
     * Embeddable study including HTML head section charts.  Modifiable css classes are study-title, study-section-header, study-section-body
     * @type {string}
     * @memberof StudyHtml
     */
    fullPageWithHead?: string;
    /**
     * Embeddable study text html including charts.  Modifiable css classes are study-title, study-section-header, study-section-body
     * @type {string}
     * @memberof StudyHtml
     */
    fullStudyHtml: string;
    /**
     * Embeddable study html including charts and css styling
     * @type {string}
     * @memberof StudyHtml
     */
    fullStudyHtmlWithCssStyles?: string;
    /**
     * Instructions for study participation
     * @type {string}
     * @memberof StudyHtml
     */
    participantInstructionsHtml?: string;
    /**
     * Embeddable table with statistics
     * @type {string}
     * @memberof StudyHtml
     */
    statisticsTableHtml?: string;
    /**
     * Text summary
     * @type {string}
     * @memberof StudyHtml
     */
    studyAbstractHtml?: string;
    /**
     * Title, study image, abstract with CSS styling
     * @type {string}
     * @memberof StudyHtml
     */
    studyHeaderHtml?: string;
    /**
     * PNG image
     * @type {string}
     * @memberof StudyHtml
     */
    studyImageHtml?: string;
    /**
     * Facebook, Twitter, Google+
     * @type {string}
     * @memberof StudyHtml
     */
    studyMetaHtml?: string;
    /**
     * Formatted study text sections
     * @type {string}
     * @memberof StudyHtml
     */
    studyTextHtml?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof StudyHtml
     */
    socialSharingButtonHtml?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof StudyHtml
     */
    studySummaryBoxHtml?: string;
}

/**
 * 
 * @export
 * @interface StudyImages
 */
export interface StudyImages {
    /**
     * Ex: https://static.quantimo.do/img/variable_categories/sleeping_in_bed-96.png
     * @type {string}
     * @memberof StudyImages
     */
    causeVariableImageUrl?: string;
    /**
     * Ex: ion-ios-cloudy-night-outline
     * @type {string}
     * @memberof StudyImages
     */
    causeVariableIonIcon?: string;
    /**
     * Ex: https://static.quantimo.do/img/variable_categories/theatre_mask-96.png
     * @type {string}
     * @memberof StudyImages
     */
    effectVariableImageUrl?: string;
    /**
     * Ex: ion-happy-outline
     * @type {string}
     * @memberof StudyImages
     */
    effectVariableIonIcon?: string;
    /**
     * Ex: https://s3.amazonaws.com/quantimodo-docs/images/gauge-moderately-positive-relationship.png
     * @type {string}
     * @memberof StudyImages
     */
    gaugeImage: string;
    /**
     * Ex: https://s3.amazonaws.com/quantimodo-docs/images/gauge-moderately-positive-relationship-200-200.png
     * @type {string}
     * @memberof StudyImages
     */
    gaugeImageSquare: string;
    /**
     * Image with gauge and category images
     * @type {string}
     * @memberof StudyImages
     */
    gaugeSharingImageUrl?: string;
    /**
     * Ex: https://s3-us-west-1.amazonaws.com/qmimages/variable_categories_gauges_logo_background/gauge-moderately-positive-relationship_sleep_emotions_logo_background.png
     * @type {string}
     * @memberof StudyImages
     */
    imageUrl: string;
    /**
     * Image with robot and category images
     * @type {string}
     * @memberof StudyImages
     */
    robotSharingImageUrl?: string;
    /**
     * Avatar of the principal investigator
     * @type {string}
     * @memberof StudyImages
     */
    avatar?: string;
}

/**
 * 
 * @export
 * @interface StudyJoinResponse
 */
export interface StudyJoinResponse {
    /**
     * 
     * @type {Study}
     * @memberof StudyJoinResponse
     */
    study?: Study;
    /**
     * 
     * @type {Array<TrackingReminder>}
     * @memberof StudyJoinResponse
     */
    trackingReminders?: Array<TrackingReminder>;
    /**
     * 
     * @type {Array<TrackingReminderNotification>}
     * @memberof StudyJoinResponse
     */
    trackingReminderNotifications?: Array<TrackingReminderNotification>;
    /**
     * Can be used as body of help info popup
     * @type {string}
     * @memberof StudyJoinResponse
     */
    description?: string;
    /**
     * Can be used as title in help info popup
     * @type {string}
     * @memberof StudyJoinResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof StudyJoinResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof StudyJoinResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof StudyJoinResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof StudyJoinResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof StudyJoinResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof StudyJoinResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface StudyLinks
 */
export interface StudyLinks {
    /**
     * Share this link with potential study participants
     * @type {string}
     * @memberof StudyLinks
     */
    studyJoinLink?: string;
    /**
     * Ex: mailto:?subject=N1%20Study%3A%20Sleep%20Quality%20Predicts%20Higher%20Overall%20Mood&body=Check%20out%20my%20study%20at%20https%3A%2F%2Flocal.quantimo.do%2Fapi%2Fv2%2Fstudy%3FcauseVariableName%3DSleep%2520Quality%26effectVariableName%3DOverall%2520Mood%26userId%3D230%0A%0AHave%20a%20great%20day!
     * @type {string}
     * @memberof StudyLinks
     */
    studyLinkEmail: string;
    /**
     * Ex: https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Flocal.quantimo.do%2Fapi%2Fv2%2Fstudy%3FcauseVariableName%3DSleep%2520Quality%26effectVariableName%3DOverall%2520Mood%26userId%3D230
     * @type {string}
     * @memberof StudyLinks
     */
    studyLinkFacebook: string;
    /**
     * Ex: https://plus.google.com/share?url=https%3A%2F%2Flocal.quantimo.do%2Fapi%2Fv2%2Fstudy%3FcauseVariableName%3DSleep%2520Quality%26effectVariableName%3DOverall%2520Mood%26userId%3D230
     * @type {string}
     * @memberof StudyLinks
     */
    studyLinkGoogle: string;
    /**
     * Ex: https://local.quantimo.do/api/v2/study?causeVariableName=Sleep%20Quality&effectVariableName=Overall%20Mood&userId=230
     * @type {string}
     * @memberof StudyLinks
     */
    studyLinkStatic: string;
    /**
     * Ex: https://local.quantimo.do/ionic/Modo/www/index.html#/app/study?causeVariableName=Sleep%20Quality&effectVariableName=Overall%20Mood&userId=230
     * @type {string}
     * @memberof StudyLinks
     */
    studyLinkDynamic: string;
    /**
     * Ex: https://twitter.com/home?status=Sleep%20Quality%20Predicts%20Higher%20Overall%20Mood%20https%3A%2F%2Flocal.quantimo.do%2Fapi%2Fv2%2Fstudy%3FcauseVariableName%3DSleep%2520Quality%26effectVariableName%3DOverall%2520Mood%26userId%3D230%20%40quantimodo
     * @type {string}
     * @memberof StudyLinks
     */
    studyLinkTwitter: string;
}

/**
 * 
 * @export
 * @interface StudySharing
 */
export interface StudySharing {
    /**
     * Would you like to make this study publicly visible?
     * @type {boolean}
     * @memberof StudySharing
     */
    shareUserMeasurements: boolean;
    /**
     * Ex: N1 Study: Sleep Quality Predicts Higher Overall Mood
     * @type {string}
     * @memberof StudySharing
     */
    sharingDescription: string;
    /**
     * Ex: N1 Study: Sleep Quality Predicts Higher Overall Mood
     * @type {string}
     * @memberof StudySharing
     */
    sharingTitle: string;
}

/**
 * 
 * @export
 * @interface StudyText
 */
export interface StudyText {
    /**
     * Ex: Overall Mood is 3.55/5 (15% higher) on average after days with around 4.19/5 Sleep Quality
     * @type {string}
     * @memberof StudyText
     */
    averageEffectFollowingHighCauseExplanation?: string;
    /**
     * Ex: Overall Mood is 2.65/5 (14% lower) on average after days with around 1.97/5 Sleep Quality
     * @type {string}
     * @memberof StudyText
     */
    averageEffectFollowingLowCauseExplanation?: string;
    /**
     * Ex: Overall Mood, on average, 17% higher after around 4.14/5 Sleep Quality
     * @type {string}
     * @memberof StudyText
     */
    valuePredictingHighOutcomeExplanation?: string;
    /**
     * Ex: Overall Mood, on average, 11% lower after around 3.03/5 Sleep Quality
     * @type {string}
     * @memberof StudyText
     */
    valuePredictingLowOutcomeExplanation?: string;
    /**
     * Ex: It was assumed that 0 hours would pass before a change in Very Distracting Time would produce an observable change in Video Activities.  It was assumed that Very Distracting Time could produce an observable change in Video Activities for as much as 7 days after the stimulus event.
     * @type {string}
     * @memberof StudyText
     */
    dataAnalysis?: string;
    /**
     * Ex: Very Distracting Time data was primarily collected using <a href=\"https://www.rescuetime.com/rp/quantimodo/plans\">RescueTime</a>. Detailed reports show which applications and websites you spent time on. Activities are automatically grouped into pre-defined categories with built-in productivity scores covering thousands of websites and applications. You can customize categories and productivity scores to meet your needs.<br>Video Activities data was primarily collected using <a href=\"https://www.rescuetime.com/rp/quantimodo/plans\">RescueTime</a>. Detailed reports show which applications and websites you spent time on. Activities are automatically grouped into pre-defined categories with built-in productivity scores covering thousands of websites and applications. You can customize categories and productivity scores to meet your needs.
     * @type {string}
     * @memberof StudyText
     */
    dataSources?: string;
    /**
     * Ex: Very Distracting Time data was primarily collected using <a href=\"https://www.rescuetime.com/rp/quantimodo/plans\">RescueTime</a>. Detailed reports show which applications and websites you spent time on. Activities are automatically grouped into pre-defined categories with built-in productivity scores covering thousands of websites and applications. You can customize categories and productivity scores to meet your needs.<br>Video Activities data was primarily collected using <a href=\"https://www.rescuetime.com/rp/quantimodo/plans\">RescueTime</a>. Detailed reports show which applications and websites you spent time on. Activities are automatically grouped into pre-defined categories with built-in productivity scores covering thousands of websites and applications. You can customize categories and productivity scores to meet your needs.
     * @type {string}
     * @memberof StudyText
     */
    dataSourcesParagraphForCause?: string;
    /**
     * Ex: Very Distracting Time data was primarily collected using <a href=\"https://www.rescuetime.com/rp/quantimodo/plans\">RescueTime</a>. Detailed reports show which applications and websites you spent time on. Activities are automatically grouped into pre-defined categories with built-in productivity scores covering thousands of websites and applications. You can customize categories and productivity scores to meet your needs.<br>Video Activities data was primarily collected using <a href=\"https://www.rescuetime.com/rp/quantimodo/plans\">RescueTime</a>. Detailed reports show which applications and websites you spent time on. Activities are automatically grouped into pre-defined categories with built-in productivity scores covering thousands of websites and applications. You can customize categories and productivity scores to meet your needs.
     * @type {string}
     * @memberof StudyText
     */
    dataSourcesParagraphForEffect?: string;
    /**
     * Ex: Sleep Quality Predicts Higher Overall Mood
     * @type {string}
     * @memberof StudyText
     */
    lastCauseDailyValueSentenceExtended?: string;
    /**
     * Ex: Sleep Quality Predicts Higher Overall Mood
     * @type {string}
     * @memberof StudyText
     */
    lastCauseAndOptimalValueSentence?: string;
    /**
     * Ex: Sleep Quality Predicts Higher Overall Mood
     * @type {string}
     * @memberof StudyText
     */
    lastCauseDailyValueSentence?: string;
    /**
     * Ex: Sleep Quality Predicts Higher Overall Mood
     * @type {string}
     * @memberof StudyText
     */
    optimalDailyValueSentence?: string;
    /**
     * Instructions for study participation
     * @type {string}
     * @memberof StudyText
     */
    participantInstructions?: string;
    /**
     * Ex: Sleep Quality Predicts Higher Overall Mood
     * @type {string}
     * @memberof StudyText
     */
    predictorExplanation?: string;
    /**
     * Ex: Using a two-tailed t-test with alpha = 0.05, it was determined that the change in Video Activities is statistically significant at 95% confidence interval.
     * @type {string}
     * @memberof StudyText
     */
    significanceExplanation?: string;
    /**
     * Ex: Aggregated data from 21 suggests with a low degree of confidence (p=0.097) that Very Distracting Time has a moderately positive predictive relationship (R=0.354) with Video Activities  (Activity).  The highest quartile of Video Activities measurements were observed following an average 2.03h Very Distracting Timeper day.  The lowest quartile of Video Activities  measurements were observed following an average 1.04h Very Distracting Timeper day.
     * @type {string}
     * @memberof StudyText
     */
    studyAbstract: string;
    /**
     * Ex: This study is based on data donated by  21 QuantiModo users. Thus, the study design is equivalent to the aggregation of 21 separate n=1 observational natural experiments.
     * @type {string}
     * @memberof StudyText
     */
    studyDesign: string;
    /**
     * Ex: As with any human experiment, it was impossible to control for all potentially confounding variables.             Correlation does not necessarily imply correlation.  We can never know for sure if one factor is definitely the cause of an outcome.             However, lack of correlation definitely implies the lack of a causal relationship.  Hence, we can with great             confidence rule out non-existent relationships. For instance, if we discover no relationship between mood             and an antidepressant this information is just as or even more valuable than the discovery that there is a relationship.             <br>             <br>             We can also take advantage of several characteristics of time series data from many subjects  to infer the likelihood of a causal relationship if we do find a correlational relationship.             The criteria for causation are a group of minimal conditions necessary to provide adequate evidence of a causal relationship between an incidence and a possible consequence.             The list of the criteria is as follows:             <br>             1. Strength (effect size): A small association does not mean that there is not a causal effect, though the larger the association, the more likely that it is causal.             <br>             2. Consistency (reproducibility): Consistent findings observed by different persons in different places with different samples strengthens the likelihood of an effect.             <br>             3. Specificity: Causation is likely if a very specific population at a specific site and disease with no other likely explanation. The more specific an association between a factor and an effect is, the bigger the probability of a causal relationship.             <br>             4. Temporality: The effect has to occur after the cause (and if there is an expected delay between the cause and expected effect, then the effect must occur after that delay).             <br>             5. Biological gradient: Greater exposure should generally lead to greater incidence of the effect. However, in some cases, the mere presence of the factor can trigger the effect. In other cases, an inverse proportion is observed: greater exposure leads to lower incidence.             <br>             6. Plausibility: A plausible mechanism between cause and effect is helpful.             <br>             7. Coherence: Coherence between epidemiological and laboratory findings increases the likelihood of an effect.             <br>             8. Experiment: \"Occasionally it is possible to appeal to experimental evidence\".             <br>             9. Analogy: The effect of similar factors may be considered.             <br>             <br>              The confidence in a causal relationship is bolstered by the fact that time-precedence was taken into account in all calculations. Furthermore, in accordance with the law of large numbers (LLN), the predictive power and accuracy of these results will continually grow over time.  146 paired data points were used in this analysis.   Assuming that the relationship is merely coincidental, as the participant independently modifies their Very Distracting Time values, the observed strength of the relationship will decline until it is below the threshold of significance.  To it another way, in the case that we do find a spurious correlation, suggesting that banana intake improves mood for instance,             one will likely increase their banana intake.  Due to the fact that this correlation is spurious, it is unlikely             that you will see a continued and persistent corresponding increase in mood.  So over time, the spurious correlation will             naturally dissipate.Furthermore, it will be very enlightening to aggregate this data with the data from other participants  with similar genetic, diseasomic, environmentomic, and demographic profiles.
     * @type {string}
     * @memberof StudyText
     */
    studyLimitations: string;
    /**
     * Ex: The objective of this study is to determine the nature of the relationship (if any) between the Very Distracting Time and the Video Activities. Additionally, we attempt to determine the Very Distracting Time values most likely to produce optimal Video Activities values.
     * @type {string}
     * @memberof StudyText
     */
    studyObjective: string;
    /**
     * Ex: This analysis suggests that higher Very Distracting Time generally predicts negative Video Activities (p = 0.097). Video Activities is, on average, 36%  higher after around 2.03 Very Distracting Time.  After an onset delay of 168 hours, Video Activities is, on average, 16%  lower than its average over the 168 hours following around 1.04 Very Distracting Time.  146 data points were used in this analysis.  The value for Very Distracting Time changed 2984 times, effectively running 1492 separate natural experiments. The top quartile outcome values are preceded by an average 2.03 h of Very Distracting Time.  The bottom quartile outcome values are preceded by an average 1.04 h of Very Distracting Time.  Forward Pearson Correlation Coefficient was 0.354 (p=0.097, 95% CI -0.437 to 1.144 onset delay = 0 hours, duration of action = 168 hours) .  The Reverse Pearson Correlation Coefficient was 0.208 (P=0.097, 95% CI -0.583 to 0.998, onset delay = -0 hours, duration of action = -168 hours). When the Very Distracting Time value is closer to 2.03 h than 1.04 h, the Video Activities value which follows is, on average, 36% percent higher than its typical value.  When the Very Distracting Time value is closer to 1.04 h than 2.03 h, the Video Activities value which follows is 0% lower than its typical value.  Video Activities is 5 h (67% higher) on average after days with around 5 h Very Distracting Time
     * @type {string}
     * @memberof StudyText
     */
    studyResults: string;
    /**
     * Ex: N1 Study: Very Distracting Time Predicts Negative Video Activities
     * @type {string}
     * @memberof StudyText
     */
    studyTitle: string;
    /**
     * Help us determine if Remeron affects Overall Mood!
     * @type {string}
     * @memberof StudyText
     */
    studyInvitation?: string;
    /**
     * Does Remeron affect Overall Mood?
     * @type {string}
     * @memberof StudyText
     */
    studyQuestion?: string;
    /**
     * In order to reduce suffering through the advancement of human knowledge...
     * @type {string}
     * @memberof StudyText
     */
    studyBackground?: string;
}

/**
 * 
 * @export
 * @interface StudyVotes
 */
export interface StudyVotes {
    /**
     * Average of all user votes with 1 representing an up-vote and 0 representing a down-vote. Ex: 0.9855
     * @type {number}
     * @memberof StudyVotes
     */
    averageVote: number;
    /**
     * 1 if the current user has up-voted the study and 0 if they down-voted it. Null means no vote. Ex: 1 or 0 or null
     * @type {number}
     * @memberof StudyVotes
     */
    userVote: number;
}

/**
 * 
 * @export
 * @interface TrackingReminder
 */
export interface TrackingReminder {
    /**
     * 
     * @type {Array<TrackingReminderNotificationAction>}
     * @memberof TrackingReminder
     */
    actionArray?: Array<TrackingReminderNotificationAction>;
    /**
     * 
     * @type {Array<Unit>}
     * @memberof TrackingReminder
     */
    availableUnits?: Array<Unit>;
    /**
     * Link to study comparing variable with strongest relationship for user or population
     * @type {string}
     * @memberof TrackingReminder
     */
    bestStudyLink?: string;
    /**
     * Description of relationship with variable with strongest relationship for user or population
     * @type {Card}
     * @memberof TrackingReminder
     */
    bestStudyCard?: Card;
    /**
     * Link to study comparing variable with strongest relationship for user
     * @type {string}
     * @memberof TrackingReminder
     */
    bestUserStudyLink?: string;
    /**
     * Description of relationship with variable with strongest relationship for user
     * @type {Card}
     * @memberof TrackingReminder
     */
    bestUserStudyCard?: Card;
    /**
     * Link to study comparing variable with strongest relationship for population
     * @type {string}
     * @memberof TrackingReminder
     */
    bestPopulationStudyLink?: string;
    /**
     * Description of relationship with variable with strongest relationship for population
     * @type {Card}
     * @memberof TrackingReminder
     */
    bestPopulationStudyCard?: Card;
    /**
     * Description of relationship with variable with strongest relationship for user or population
     * @type {string}
     * @memberof TrackingReminder
     */
    optimalValueMessage?: string;
    /**
     * Description of relationship with variable with strongest relationship for population
     * @type {string}
     * @memberof TrackingReminder
     */
    commonOptimalValueMessage?: string;
    /**
     * Description of relationship with variable with strongest relationship for user
     * @type {string}
     * @memberof TrackingReminder
     */
    userOptimalValueMessage?: string;
    /**
     * Card containing instructions, image, text, link and relevant import buttons
     * @type {Card}
     * @memberof TrackingReminder
     */
    card?: Card;
    /**
     * Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @type {string}
     * @memberof TrackingReminder
     */
    clientId?: string;
    /**
     * The way multiple measurements are aggregated over time
     * @type {string}
     * @memberof TrackingReminder
     */
    combinationOperation?: TrackingReminder.CombinationOperationEnum;
    /**
     * Ex: 2016-05-18 02:24:08 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof TrackingReminder
     */
    createdAt?: string;
    /**
     * Ex: Trader Joe's Bedtime Tea
     * @type {string}
     * @memberof TrackingReminder
     */
    displayName?: string;
    /**
     * Ex: /5
     * @type {string}
     * @memberof TrackingReminder
     */
    unitAbbreviatedName: string;
    /**
     * Ex: 5
     * @type {number}
     * @memberof TrackingReminder
     */
    unitCategoryId?: number;
    /**
     * Ex: Rating
     * @type {string}
     * @memberof TrackingReminder
     */
    unitCategoryName?: string;
    /**
     * Ex: 10
     * @type {number}
     * @memberof TrackingReminder
     */
    unitId?: number;
    /**
     * Ex: 1 to 5 Rating
     * @type {string}
     * @memberof TrackingReminder
     */
    unitName?: string;
    /**
     * Default value to use for the measurement when tracking. Unit: User-specified or common.
     * @type {number}
     * @memberof TrackingReminder
     */
    defaultValue?: number;
    /**
     * If a tracking reminder is enabled, tracking reminder notifications will be generated for this variable.
     * @type {boolean}
     * @memberof TrackingReminder
     */
    enabled?: boolean;
    /**
     * True if the reminders should be delivered via email
     * @type {boolean}
     * @memberof TrackingReminder
     */
    email?: boolean;
    /**
     * Ex: reminderStartTimeLocal is less than $user->earliestReminderTime or greater than  $user->latestReminderTime
     * @type {string}
     * @memberof TrackingReminder
     */
    errorMessage?: string;
    /**
     * Ex: 0. Unit: User-specified or common.
     * @type {number}
     * @memberof TrackingReminder
     */
    fillingValue?: number;
    /**
     * Ex: 02:45:20 in UTC timezone
     * @type {string}
     * @memberof TrackingReminder
     */
    firstDailyReminderTime?: string;
    /**
     * Ex: Daily
     * @type {string}
     * @memberof TrackingReminder
     */
    frequencyTextDescription?: string;
    /**
     * Ex: Daily at 09:45 PM
     * @type {string}
     * @memberof TrackingReminder
     */
    frequencyTextDescriptionWithTime?: string;
    /**
     * id
     * @type {number}
     * @memberof TrackingReminder
     */
    id?: number;
    /**
     * Ex: saddestFaceIsFive
     * @type {string}
     * @memberof TrackingReminder
     */
    inputType?: string;
    /**
     * Ex: I am an instruction!
     * @type {string}
     * @memberof TrackingReminder
     */
    instructions?: string;
    /**
     * Ex: ion-sad-outline
     * @type {string}
     * @memberof TrackingReminder
     */
    ionIcon?: string;
    /**
     * UTC ISO 8601 YYYY-MM-DDThh:mm:ss timestamp for the last time a measurement was received for this user and variable
     * @type {string}
     * @memberof TrackingReminder
     */
    lastTracked?: string;
    /**
     * Ex: 2
     * @type {number}
     * @memberof TrackingReminder
     */
    lastValue?: number;
    /**
     * UTC ISO 8601 YYYY-MM-DDThh:mm:ss  timestamp for the reminder time of the latest tracking reminder notification that has been pre-emptively generated in the database
     * @type {string}
     * @memberof TrackingReminder
     */
    latestTrackingReminderNotificationReminderTime?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingReminder
     */
    localDailyReminderNotificationTimes?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingReminder
     */
    localDailyReminderNotificationTimesForAllReminders?: Array<string>;
    /**
     * Ex: 1
     * @type {boolean}
     * @memberof TrackingReminder
     */
    manualTracking?: boolean;
    /**
     * Ex: 5. Unit: User-specified or common.
     * @type {number}
     * @memberof TrackingReminder
     */
    maximumAllowedValue?: number;
    /**
     * Ex: 1. Unit: User-specified or common.
     * @type {number}
     * @memberof TrackingReminder
     */
    minimumAllowedValue?: number;
    /**
     * Ex: 1501555520
     * @type {number}
     * @memberof TrackingReminder
     */
    nextReminderTimeEpochSeconds?: number;
    /**
     * True if the reminders should appear in the notification bar
     * @type {boolean}
     * @memberof TrackingReminder
     */
    notificationBar?: boolean;
    /**
     * Ex: 445
     * @type {number}
     * @memberof TrackingReminder
     */
    numberOfRawMeasurements?: number;
    /**
     * Ex: 1
     * @type {number}
     * @memberof TrackingReminder
     */
    numberOfUniqueValues?: number;
    /**
     * Indicates whether or not the variable is usually an outcome of interest such as a symptom or emotion
     * @type {boolean}
     * @memberof TrackingReminder
     */
    outcome?: boolean;
    /**
     * Ex: img/variable_categories/symptoms.png
     * @type {string}
     * @memberof TrackingReminder
     */
    pngPath?: string;
    /**
     * Ex: https://web.quantimo.do/img/variable_categories/symptoms.png
     * @type {string}
     * @memberof TrackingReminder
     */
    pngUrl?: string;
    /**
     * Link to associated product for purchase
     * @type {string}
     * @memberof TrackingReminder
     */
    productUrl?: string;
    /**
     * True if the reminders should appear as a popup notification
     * @type {boolean}
     * @memberof TrackingReminder
     */
    popUp?: boolean;
    /**
     * Ex: How is your overall mood?
     * @type {string}
     * @memberof TrackingReminder
     */
    question?: string;
    /**
     * Ex: How is your overall mood on a scale of 1 to 5??
     * @type {string}
     * @memberof TrackingReminder
     */
    longQuestion?: string;
    /**
     * Latest time of day at which reminders should appear in UTC HH:MM:SS format
     * @type {string}
     * @memberof TrackingReminder
     */
    reminderEndTime?: string;
    /**
     * Number of seconds between one reminder and the next
     * @type {number}
     * @memberof TrackingReminder
     */
    reminderFrequency: number;
    /**
     * String identifier for the sound to accompany the reminder
     * @type {string}
     * @memberof TrackingReminder
     */
    reminderSound?: string;
    /**
     * Ex: 1469760320
     * @type {number}
     * @memberof TrackingReminder
     */
    reminderStartEpochSeconds?: number;
    /**
     * Earliest time of day at which reminders should appear in UTC HH:MM:SS format
     * @type {string}
     * @memberof TrackingReminder
     */
    reminderStartTime?: string;
    /**
     * Ex: 21:45:20
     * @type {string}
     * @memberof TrackingReminder
     */
    reminderStartTimeLocal?: string;
    /**
     * Ex: 09:45 PM
     * @type {string}
     * @memberof TrackingReminder
     */
    reminderStartTimeLocalHumanFormatted?: string;
    /**
     * Ex: true
     * @type {boolean}
     * @memberof TrackingReminder
     */
    repeating?: boolean;
    /**
     * Ex: 01:00:00
     * @type {string}
     * @memberof TrackingReminder
     */
    secondDailyReminderTime?: string;
    /**
     * Ex: 1. Unit: User-specified or common.
     * @type {number}
     * @memberof TrackingReminder
     */
    secondToLastValue?: number;
    /**
     * True if the reminders should be delivered via SMS
     * @type {boolean}
     * @memberof TrackingReminder
     */
    sms?: boolean;
    /**
     * Earliest date on which the user should be reminded to track in YYYY-MM-DD format
     * @type {string}
     * @memberof TrackingReminder
     */
    startTrackingDate?: string;
    /**
     * Latest date on which the user should be reminded to track in YYYY-MM-DD format
     * @type {string}
     * @memberof TrackingReminder
     */
    stopTrackingDate?: string;
    /**
     * Ex: https://web.quantimo.do/img/variable_categories/symptoms.svg
     * @type {string}
     * @memberof TrackingReminder
     */
    svgUrl?: string;
    /**
     * Ex: 20:00:00
     * @type {string}
     * @memberof TrackingReminder
     */
    thirdDailyReminderTime?: string;
    /**
     * Ex: 3
     * @type {number}
     * @memberof TrackingReminder
     */
    thirdToLastValue?: number;
    /**
     * Ex: 11841
     * @type {number}
     * @memberof TrackingReminder
     */
    trackingReminderId?: number;
    /**
     * Ex: Not Found
     * @type {string}
     * @memberof TrackingReminder
     */
    trackingReminderImageUrl?: string;
    /**
     * UPC or other barcode scan result
     * @type {string}
     * @memberof TrackingReminder
     */
    upc?: string;
    /**
     * When the record in the database was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @type {string}
     * @memberof TrackingReminder
     */
    updatedAt?: string;
    /**
     * ID of User
     * @type {number}
     * @memberof TrackingReminder
     */
    userId?: number;
    /**
     * Ex: /5
     * @type {string}
     * @memberof TrackingReminder
     */
    userVariableUnitAbbreviatedName?: string;
    /**
     * Ex: 5
     * @type {number}
     * @memberof TrackingReminder
     */
    userVariableUnitCategoryId?: number;
    /**
     * Ex: Rating
     * @type {string}
     * @memberof TrackingReminder
     */
    userVariableUnitCategoryName?: string;
    /**
     * Ex: 10
     * @type {number}
     * @memberof TrackingReminder
     */
    userVariableUnitId?: number;
    /**
     * Ex: 1 to 5 Rating
     * @type {string}
     * @memberof TrackingReminder
     */
    userVariableUnitName?: string;
    /**
     * Ex: 10
     * @type {number}
     * @memberof TrackingReminder
     */
    userVariableVariableCategoryId?: number;
    /**
     * Ex: Symptoms
     * @type {string}
     * @memberof TrackingReminder
     */
    userVariableVariableCategoryName?: string;
    /**
     * Valence indicates what type of buttons should be used when recording measurements for this variable. positive - Face buttons with the happiest face equating to a 5/5 rating where higher is better like Overall Mood. negative - Face buttons with happiest face equating to a 1/5 rating where lower is better like Headache Severity. numeric - Just 1 to 5 numeric buttons for neutral variables. 
     * @type {string}
     * @memberof TrackingReminder
     */
    valence?: string;
    /**
     * Ex: Rate daily
     * @type {string}
     * @memberof TrackingReminder
     */
    valueAndFrequencyTextDescription?: string;
    /**
     * Ex: Rate daily at 09:45 PM
     * @type {string}
     * @memberof TrackingReminder
     */
    valueAndFrequencyTextDescriptionWithTime?: string;
    /**
     * Ex: 10
     * @type {number}
     * @memberof TrackingReminder
     */
    variableCategoryId?: number;
    /**
     * Ex: https://static.quantimo.do/img/variable_categories/sad-96.png
     * @type {string}
     * @memberof TrackingReminder
     */
    variableCategoryImageUrl?: string;
    /**
     * Ex: Emotions, Treatments, Symptoms...
     * @type {string}
     * @memberof TrackingReminder
     */
    variableCategoryName: TrackingReminder.VariableCategoryNameEnum;
    /**
     * Valence indicates what type of buttons should be used when recording measurements for this variable. positive - Face buttons with the happiest face equating to a 5/5 rating where higher is better like Overall Mood. negative - Face buttons with happiest face equating to a 1/5 rating where lower is better like Headache Severity. numeric - Just 1 to 5 numeric buttons for neutral variables. 
     * @type {string}
     * @memberof TrackingReminder
     */
    variableDescription?: string;
    /**
     * Id for the variable to be tracked
     * @type {number}
     * @memberof TrackingReminder
     */
    variableId?: number;
    /**
     * Name of the variable to be used when sending measurements
     * @type {string}
     * @memberof TrackingReminder
     */
    variableName: string;
}

/**
 * @export
 * @namespace TrackingReminder
 */
export namespace TrackingReminder {
    /**
     * @export
     * @enum {string}
     */
    export enum CombinationOperationEnum {
        MEAN = <any> 'MEAN',
        SUM = <any> 'SUM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VariableCategoryNameEnum {
        Activity = <any> 'Activity',
        Books = <any> 'Books',
        CausesOfIllness = <any> 'Causes of Illness',
        CognitivePerformance = <any> 'Cognitive Performance',
        Conditions = <any> 'Conditions',
        Emotions = <any> 'Emotions',
        Environment = <any> 'Environment',
        Foods = <any> 'Foods',
        Goals = <any> 'Goals',
        Locations = <any> 'Locations',
        Miscellaneous = <any> 'Miscellaneous',
        MoviesAndTV = <any> 'Movies and TV',
        Music = <any> 'Music',
        Nutrients = <any> 'Nutrients',
        Payments = <any> 'Payments',
        PhysicalActivities = <any> 'Physical Activities',
        Physique = <any> 'Physique',
        Sleep = <any> 'Sleep',
        SocialInteractions = <any> 'Social Interactions',
        Software = <any> 'Software',
        Symptoms = <any> 'Symptoms',
        Treatments = <any> 'Treatments',
        VitalSigns = <any> 'Vital Signs'
    }
}

/**
 * 
 * @export
 * @interface TrackingReminderDelete
 */
export interface TrackingReminderDelete {
    /**
     * Id of the TrackingReminder to be deleted
     * @type {number}
     * @memberof TrackingReminderDelete
     */
    id: number;
}

/**
 * 
 * @export
 * @interface TrackingReminderNotification
 */
export interface TrackingReminderNotification {
    /**
     * 
     * @type {Array<TrackingReminderNotificationAction>}
     * @memberof TrackingReminderNotification
     */
    actionArray: Array<TrackingReminderNotificationAction>;
    /**
     * 
     * @type {Array<Unit>}
     * @memberof TrackingReminderNotification
     */
    availableUnits: Array<Unit>;
    /**
     * Link to study comparing variable with strongest relationship for user or population
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    bestStudyLink?: string;
    /**
     * Description of relationship with variable with strongest relationship for user or population
     * @type {Card}
     * @memberof TrackingReminderNotification
     */
    bestStudyCard?: Card;
    /**
     * Link to study comparing variable with strongest relationship for user
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    bestUserStudyLink?: string;
    /**
     * Description of relationship with variable with strongest relationship for user
     * @type {Card}
     * @memberof TrackingReminderNotification
     */
    bestUserStudyCard?: Card;
    /**
     * Link to study comparing variable with strongest relationship for population
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    bestPopulationStudyLink?: string;
    /**
     * Description of relationship with variable with strongest relationship for population
     * @type {Card}
     * @memberof TrackingReminderNotification
     */
    bestPopulationStudyCard?: Card;
    /**
     * Description of relationship with variable with strongest relationship for user or population
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    optimalValueMessage?: string;
    /**
     * Description of relationship with variable with strongest relationship for population
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    commonOptimalValueMessage?: string;
    /**
     * Description of relationship with variable with strongest relationship for user
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    userOptimalValueMessage?: string;
    /**
     * Card with options for tracking.
     * @type {Card}
     * @memberof TrackingReminderNotification
     */
    card?: Card;
    /**
     * Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    clientId?: string;
    /**
     * The way multiple measurements are aggregated over time
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    combinationOperation?: TrackingReminderNotification.CombinationOperationEnum;
    /**
     * Ex: 2017-07-29 20:49:54 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    createdAt?: string;
    /**
     * Ex: Trader Joe's Bedtime Tea
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    displayName?: string;
    /**
     * Is the user specified default value or falls back to the last value in user unit. Good for initializing input fields. Unit: User-specified or common.
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    modifiedValue?: number;
    /**
     * Ex: /5
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    unitAbbreviatedName?: string;
    /**
     * Ex: 5
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    unitCategoryId?: number;
    /**
     * Ex: Rating
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    unitCategoryName?: string;
    /**
     * Ex: 10
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    unitId?: number;
    /**
     * Ex: 1 to 5 Rating
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    unitName?: string;
    /**
     * Default value to use for the measurement when tracking
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    defaultValue?: number;
    /**
     * Valence indicates what type of buttons should be used when recording measurements for this variable. positive - Face buttons with the happiest face equating to a 5/5 rating where higher is better like Overall Mood. negative - Face buttons with happiest face equating to a 1/5 rating where lower is better like Headache Severity. numeric - Just 1 to 5 numeric buttons for neutral variables. 
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    description?: string;
    /**
     * True if the reminders should be delivered via email
     * @type {boolean}
     * @memberof TrackingReminderNotification
     */
    email?: boolean;
    /**
     * Ex: 0
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    fillingValue: number;
    /**
     * Ex: ion-sad-outline
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    iconIcon?: string;
    /**
     * id for the specific PENDING tracking remidner
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    id: number;
    /**
     * Ex: https://rximage.nlm.nih.gov/image/images/gallery/original/55111-0129-60_RXNAVIMAGE10_B051D81E.jpg
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    imageUrl?: string;
    /**
     * Ex: happiestFaceIsFive
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    inputType?: string;
    /**
     * Ex: ion-happy-outline
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    ionIcon?: string;
    /**
     * Ex: 3
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    lastValue?: number;
    /**
     * True if this variable is normally tracked via manual user input rather than automatic imports
     * @type {boolean}
     * @memberof TrackingReminderNotification
     */
    manualTracking?: boolean;
    /**
     * Ex: 5
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    maximumAllowedValue?: number;
    /**
     * Ex: 1
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    minimumAllowedValue?: number;
    /**
     * Ex: 3
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    mostCommonValue?: number;
    /**
     * True if the reminders should appear in the notification bar
     * @type {boolean}
     * @memberof TrackingReminderNotification
     */
    notificationBar?: boolean;
    /**
     * Ex: UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    notifiedAt?: string;
    /**
     * Ex: 5
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    numberOfUniqueValues?: number;
    /**
     * Indicates whether or not the variable is usually an outcome of interest such as a symptom or emotion
     * @type {boolean}
     * @memberof TrackingReminderNotification
     */
    outcome?: boolean;
    /**
     * Ex: img/variable_categories/emotions.png
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    pngPath?: string;
    /**
     * Ex: https://web.quantimo.do/img/variable_categories/emotions.png
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    pngUrl?: string;
    /**
     * True if the reminders should appear as a popup notification
     * @type {boolean}
     * @memberof TrackingReminderNotification
     */
    popUp?: boolean;
    /**
     * Link to associated product for purchase
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    productUrl?: string;
    /**
     * Ex: How is your overall mood?
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    question?: string;
    /**
     * Ex: How is your overall mood on a scale of 1 to 5??
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    longQuestion?: string;
    /**
     * Ex: 01-01-2018
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    reminderEndTime?: string;
    /**
     * How often user should be reminded in seconds. Ex: 86400
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    reminderFrequency?: number;
    /**
     * String identifier for the sound to accompany the reminder
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    reminderSound?: string;
    /**
     * Earliest time of day at which reminders should appear in UTC HH:MM:SS format
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    reminderStartTime?: string;
    /**
     * UTC ISO 8601 YYYY-MM-DDThh:mm:ss timestamp for the specific time the variable should be tracked in UTC.  This will be used for the measurement startTime if the track endpoint is used.
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    reminderTime?: string;
    /**
     * Ex: 4
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    secondMostCommonValue?: number;
    /**
     * Ex: 1
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    secondToLastValue?: number;
    /**
     * True if the reminders should be delivered via SMS
     * @type {boolean}
     * @memberof TrackingReminderNotification
     */
    sms?: boolean;
    /**
     * Ex: https://web.quantimo.do/img/variable_categories/emotions.svg
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    svgUrl?: string;
    /**
     * Ex: 2
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    thirdMostCommonValue?: number;
    /**
     * Ex: 2
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    thirdToLastValue?: number;
    /**
     * Ex: Rate Overall Mood
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    title?: string;
    /**
     * Ex: 3
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    total?: number;
    /**
     * 
     * @type {Array<TrackingReminderNotificationTrackAllAction>}
     * @memberof TrackingReminderNotification
     */
    trackAllActions: Array<TrackingReminderNotificationTrackAllAction>;
    /**
     * id for the repeating tracking remidner
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    trackingReminderId?: number;
    /**
     * Ex: https://rximage.nlm.nih.gov/image/images/gallery/original/55111-0129-60_RXNAVIMAGE10_B051D81E.jpg
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    trackingReminderImageUrl?: string;
    /**
     * Ex: 5072482
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    trackingReminderNotificationId?: number;
    /**
     * UTC ISO 8601 YYYY-MM-DDThh:mm:ss timestamp for the specific time the variable should be tracked in UTC.  This will be used for the measurement startTime if the track endpoint is used.
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    trackingReminderNotificationTime?: string;
    /**
     * Ex: 1501534124
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    trackingReminderNotificationTimeEpoch?: number;
    /**
     * Ex: 15:48:44
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    trackingReminderNotificationTimeLocal?: string;
    /**
     * Ex: 8PM Sun, May 1
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    trackingReminderNotificationTimeLocalHumanString?: string;
    /**
     * When the record in the database was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    updatedAt?: string;
    /**
     * ID of User
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    userId?: number;
    /**
     * Ex: /5
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    userVariableUnitAbbreviatedName?: string;
    /**
     * Ex: 5
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    userVariableUnitCategoryId?: number;
    /**
     * Ex: Rating
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    userVariableUnitCategoryName?: string;
    /**
     * Ex: 10
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    userVariableUnitId?: number;
    /**
     * Ex: 1 to 5 Rating
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    userVariableUnitName?: string;
    /**
     * Ex: 1
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    userVariableVariableCategoryId?: number;
    /**
     * Ex: Emotions
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    userVariableVariableCategoryName?: string;
    /**
     * Valence indicates what type of buttons should be used when recording measurements for this variable. positive - Face buttons with the happiest face equating to a 5/5 rating where higher is better like Overall Mood. negative - Face buttons with happiest face equating to a 1/5 rating where lower is better like Headache Severity. numeric - Just 1 to 5 numeric buttons for neutral variables. 
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    valence?: string;
    /**
     * Ex: 1
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    variableCategoryId?: number;
    /**
     * Ex: https://static.quantimo.do/img/variable_categories/theatre_mask-96.png
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    variableCategoryImageUrl?: string;
    /**
     * Ex: Emotions, Treatments, Symptoms...
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    variableCategoryName?: TrackingReminderNotification.VariableCategoryNameEnum;
    /**
     * Id for the variable to be tracked
     * @type {number}
     * @memberof TrackingReminderNotification
     */
    variableId?: number;
    /**
     * Ex: https://image.png
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    variableImageUrl?: string;
    /**
     * Name of the variable to be used when sending measurements
     * @type {string}
     * @memberof TrackingReminderNotification
     */
    variableName?: string;
}

/**
 * @export
 * @namespace TrackingReminderNotification
 */
export namespace TrackingReminderNotification {
    /**
     * @export
     * @enum {string}
     */
    export enum CombinationOperationEnum {
        MEAN = <any> 'MEAN',
        SUM = <any> 'SUM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VariableCategoryNameEnum {
        Activity = <any> 'Activity',
        Books = <any> 'Books',
        CausesOfIllness = <any> 'Causes of Illness',
        CognitivePerformance = <any> 'Cognitive Performance',
        Conditions = <any> 'Conditions',
        Emotions = <any> 'Emotions',
        Environment = <any> 'Environment',
        Foods = <any> 'Foods',
        Goals = <any> 'Goals',
        Locations = <any> 'Locations',
        Miscellaneous = <any> 'Miscellaneous',
        MoviesAndTV = <any> 'Movies and TV',
        Music = <any> 'Music',
        Nutrients = <any> 'Nutrients',
        Payments = <any> 'Payments',
        PhysicalActivities = <any> 'Physical Activities',
        Physique = <any> 'Physique',
        Sleep = <any> 'Sleep',
        SocialInteractions = <any> 'Social Interactions',
        Software = <any> 'Software',
        Symptoms = <any> 'Symptoms',
        Treatments = <any> 'Treatments',
        VitalSigns = <any> 'Vital Signs'
    }
}

/**
 * 
 * @export
 * @interface TrackingReminderNotificationAction
 */
export interface TrackingReminderNotificationAction {
    /**
     * Ex: track
     * @type {string}
     * @memberof TrackingReminderNotificationAction
     */
    action: string;
    /**
     * Ex: trackThreeRatingAction
     * @type {string}
     * @memberof TrackingReminderNotificationAction
     */
    callback: string;
    /**
     * Ex: 3
     * @type {number}
     * @memberof TrackingReminderNotificationAction
     */
    modifiedValue: number;
    /**
     * Ex: 3/5
     * @type {string}
     * @memberof TrackingReminderNotificationAction
     */
    title: string;
    /**
     * Ex: Rate 3/5
     * @type {string}
     * @memberof TrackingReminderNotificationAction
     */
    longTitle?: string;
    /**
     * Ex: 3
     * @type {string}
     * @memberof TrackingReminderNotificationAction
     */
    shortTitle?: string;
}

/**
 * 
 * @export
 * @interface TrackingReminderNotificationPost
 */
export interface TrackingReminderNotificationPost {
    /**
     * track records a measurement for the notification.  snooze changes the notification to 1 hour from now. skip deletes the notification.
     * @type {string}
     * @memberof TrackingReminderNotificationPost
     */
    action: TrackingReminderNotificationPost.ActionEnum;
    /**
     * Id of the TrackingReminderNotification
     * @type {number}
     * @memberof TrackingReminderNotificationPost
     */
    id: number;
    /**
     * Optional value to be recorded instead of the tracking reminder default value
     * @type {number}
     * @memberof TrackingReminderNotificationPost
     */
    modifiedValue?: number;
}

/**
 * @export
 * @namespace TrackingReminderNotificationPost
 */
export namespace TrackingReminderNotificationPost {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionEnum {
        Skip = <any> 'skip',
        Snooze = <any> 'snooze',
        Track = <any> 'track'
    }
}

/**
 * 
 * @export
 * @interface TrackingReminderNotificationTrackAllAction
 */
export interface TrackingReminderNotificationTrackAllAction {
    /**
     * Ex: trackAll
     * @type {string}
     * @memberof TrackingReminderNotificationTrackAllAction
     */
    action: string;
    /**
     * Ex: trackThreeRatingAction
     * @type {string}
     * @memberof TrackingReminderNotificationTrackAllAction
     */
    callback: string;
    /**
     * Ex: 3
     * @type {number}
     * @memberof TrackingReminderNotificationTrackAllAction
     */
    modifiedValue: number;
    /**
     * Ex: Rate 3/5 for all
     * @type {string}
     * @memberof TrackingReminderNotificationTrackAllAction
     */
    title: string;
}

/**
 * 
 * @export
 * @interface Unit
 */
export interface Unit {
    /**
     * Unit abbreviation
     * @type {string}
     * @memberof Unit
     */
    abbreviatedName: string;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Unit
     */
    advanced?: number;
    /**
     * Unit category
     * @type {string}
     * @memberof Unit
     */
    category: Unit.CategoryEnum;
    /**
     * Ex: 6
     * @type {number}
     * @memberof Unit
     */
    categoryId?: number;
    /**
     * Ex: Miscellany
     * @type {string}
     * @memberof Unit
     */
    categoryName?: string;
    /**
     * Conversion steps list
     * @type {Array<ConversionStep>}
     * @memberof Unit
     */
    conversionSteps: Array<ConversionStep>;
    /**
     * Ex: 29
     * @type {number}
     * @memberof Unit
     */
    id?: number;
    /**
     * Ex: 0
     * @type {number}
     * @memberof Unit
     */
    manualTracking?: number;
    /**
     * The maximum allowed value for measurements. While you can record a value above this maximum, it will be excluded from the correlation analysis.
     * @type {number}
     * @memberof Unit
     */
    maximumAllowedValue?: number;
    /**
     * Ex: 4
     * @type {number}
     * @memberof Unit
     */
    maximumValue: number;
    /**
     * The minimum allowed value for measurements. While you can record a value below this minimum, it will be excluded from the correlation analysis.
     * @type {number}
     * @memberof Unit
     */
    minimumAllowedValue?: number;
    /**
     * Ex: 0
     * @type {number}
     * @memberof Unit
     */
    minimumValue?: number;
    /**
     * Unit name
     * @type {string}
     * @memberof Unit
     */
    name: string;
    /**
     * 
     * @type {UnitCategory}
     * @memberof Unit
     */
    unitCategory: UnitCategory;
}

/**
 * @export
 * @namespace Unit
 */
export namespace Unit {
    /**
     * @export
     * @enum {string}
     */
    export enum CategoryEnum {
        Distance = <any> 'Distance',
        Duration = <any> 'Duration',
        Energy = <any> 'Energy',
        Frequency = <any> 'Frequency',
        Miscellany = <any> 'Miscellany',
        Pressure = <any> 'Pressure',
        Proportion = <any> 'Proportion',
        Rating = <any> 'Rating',
        Temperature = <any> 'Temperature',
        Volume = <any> 'Volume',
        Weight = <any> 'Weight',
        Count = <any> 'Count'
    }
}

/**
 * 
 * @export
 * @interface UnitCategory
 */
export interface UnitCategory {
    /**
     * id
     * @type {number}
     * @memberof UnitCategory
     */
    id?: number;
    /**
     * Category name
     * @type {string}
     * @memberof UnitCategory
     */
    name: string;
    /**
     * Base unit for in which measurements are to be converted to and stored
     * @type {string}
     * @memberof UnitCategory
     */
    standardUnitAbbreviatedName?: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * User access token
     * @type {string}
     * @memberof User
     */
    accessToken: string;
    /**
     * Ex: 2018-08-08 02:41:19
     * @type {string}
     * @memberof User
     */
    accessTokenExpires?: string;
    /**
     * Ex: 1533696079000
     * @type {number}
     * @memberof User
     */
    accessTokenExpiresAtMilliseconds?: number;
    /**
     * Is user administrator
     * @type {boolean}
     * @memberof User
     */
    administrator: boolean;
    /**
     * 
     * @type {AuthorizedClients}
     * @memberof User
     */
    authorizedClients?: AuthorizedClients;
    /**
     * Ex: https://lh6.googleusercontent.com/-BHr4hyUWqZU/AAAAAAAAAAI/AAAAAAAIG28/2Lv0en738II/photo.jpg?sz=50
     * @type {string}
     * @memberof User
     */
    avatar?: string;
    /**
     * Ex: https://lh6.googleusercontent.com/-BHr4hyUWqZU/AAAAAAAAAAI/AAAAAAAIG28/2Lv0en738II/photo.jpg?sz=50
     * @type {string}
     * @memberof User
     */
    avatarImage?: string;
    /**
     * Ex: a:1:{s:13:\"administrator\";b:1;}
     * @type {string}
     * @memberof User
     */
    capabilities?: string;
    /**
     * Avatar and info
     * @type {Card}
     * @memberof User
     */
    card?: Card;
    /**
     * Ex: quantimodo
     * @type {string}
     * @memberof User
     */
    clientId?: string;
    /**
     * Ex: 118444693184829555362
     * @type {string}
     * @memberof User
     */
    clientUserId?: string;
    /**
     * Ex: 1
     * @type {boolean}
     * @memberof User
     */
    combineNotifications?: boolean;
    /**
     * When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format
     * @type {string}
     * @memberof User
     */
    createdAt?: string;
    /**
     * Your bio will be displayed on your published studies
     * @type {string}
     * @memberof User
     */
    description?: string;
    /**
     * User display name
     * @type {string}
     * @memberof User
     */
    displayName: string;
    /**
     * Earliest time user should get notifications. Ex: 05:00:00
     * @type {string}
     * @memberof User
     */
    earliestReminderTime?: string;
    /**
     * User email
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * Ex: Mike
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * Ex: false
     * @type {boolean}
     * @memberof User
     */
    getPreviewBuilds?: boolean;
    /**
     * Ex: false
     * @type {boolean}
     * @memberof User
     */
    hasAndroidApp?: boolean;
    /**
     * Ex: false
     * @type {boolean}
     * @memberof User
     */
    hasChromeExtension?: boolean;
    /**
     * Ex: false
     * @type {boolean}
     * @memberof User
     */
    hasIosApp?: boolean;
    /**
     * User id
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * Ex: Date the user last logged in
     * @type {string}
     * @memberof User
     */
    lastActive?: string;
    /**
     * Ex: 2009
     * @type {string}
     * @memberof User
     */
    lastFour?: string;
    /**
     * Ex: Sinn
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * Ex: 1
     * @type {string}
     * @memberof User
     */
    lastSmsTrackingReminderNotificationId?: string;
    /**
     * Latest time user should get notifications. Ex: 23:00:00
     * @type {string}
     * @memberof User
     */
    latestReminderTime?: string;
    /**
     * User login name
     * @type {string}
     * @memberof User
     */
    loginName: string;
    /**
     * Ex: PASSWORD
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * Ex: 618-391-0002
     * @type {string}
     * @memberof User
     */
    phoneNumber?: string;
    /**
     * Ex: 1234
     * @type {string}
     * @memberof User
     */
    phoneVerificationCode?: string;
    /**
     * A good primary outcome variable is something that you want to improve and that changes inexplicably. For instance, if you have anxiety, back pain or arthritis which is worse on some days than others, these would be good candidates for primary outcome variables.  Recording their severity and potential factors will help you identify hidden factors exacerbating or improving them. 
     * @type {number}
     * @memberof User
     */
    primaryOutcomeVariableId?: number;
    /**
     * A good primary outcome variable is something that you want to improve and that changes inexplicably. For instance, if you have anxiety, back pain or arthritis which is worse on some days than others, these would be good candidates for primary outcome variables.  Recording their severity and potential factors will help you identify hidden factors exacerbating or improving them. 
     * @type {string}
     * @memberof User
     */
    primaryOutcomeVariableName?: string;
    /**
     * Ex: 1
     * @type {boolean}
     * @memberof User
     */
    pushNotificationsEnabled?: boolean;
    /**
     * See https://oauth.net/2/grant-types/refresh-token/
     * @type {string}
     * @memberof User
     */
    refreshToken?: string;
    /**
     * Ex: [\"admin\"]
     * @type {string}
     * @memberof User
     */
    roles?: string;
    /**
     * Ex: 1
     * @type {boolean}
     * @memberof User
     */
    sendPredictorEmails?: boolean;
    /**
     * Ex: 1
     * @type {boolean}
     * @memberof User
     */
    sendReminderNotificationEmails?: boolean;
    /**
     * Share all studies, charts, and measurement data with all other users
     * @type {boolean}
     * @memberof User
     */
    shareAllData?: boolean;
    /**
     * Ex: false
     * @type {boolean}
     * @memberof User
     */
    smsNotificationsEnabled?: boolean;
    /**
     * Ex: 1
     * @type {boolean}
     * @memberof User
     */
    stripeActive?: boolean;
    /**
     * Ex: cus_A8CEmcvl8jwLhV
     * @type {string}
     * @memberof User
     */
    stripeId?: string;
    /**
     * Ex: monthly7
     * @type {string}
     * @memberof User
     */
    stripePlan?: string;
    /**
     * Ex: sub_ANTx3nOE7nzjQf
     * @type {string}
     * @memberof User
     */
    stripeSubscription?: string;
    /**
     * UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof User
     */
    subscriptionEndsAt?: string;
    /**
     * Ex: google
     * @type {string}
     * @memberof User
     */
    subscriptionProvider?: string;
    /**
     * Ex: 300
     * @type {number}
     * @memberof User
     */
    timeZoneOffset?: number;
    /**
     * Ex: 1
     * @type {boolean}
     * @memberof User
     */
    trackLocation?: boolean;
    /**
     * When the record in the database was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format
     * @type {string}
     * @memberof User
     */
    updatedAt?: string;
    /**
     * Ex: 2013-12-03 15:25:13 UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof User
     */
    userRegistered?: string;
    /**
     * Ex: https://plus.google.com/+MikeSinn
     * @type {string}
     * @memberof User
     */
    userUrl?: string;
}

/**
 * 
 * @export
 * @interface UserBlog
 */
export interface UserBlog {
    /**
     * What do you expect?
     * @type {number}
     * @memberof UserBlog
     */
    id: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof UserBlog
     */
    userId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof UserBlog
     */
    blogId: number;
    /**
     * Additional userblog key-value data
     * @type {Array<any>}
     * @memberof UserBlog
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface UserBlogsResponse
 */
export interface UserBlogsResponse {
    /**
     * 
     * @type {Array<UserBlog>}
     * @memberof UserBlogsResponse
     */
    userBlogs: Array<UserBlog>;
    /**
     * UserBlog
     * @type {string}
     * @memberof UserBlogsResponse
     */
    description?: string;
    /**
     * UserBlog
     * @type {string}
     * @memberof UserBlogsResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof UserBlogsResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof UserBlogsResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof UserBlogsResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof UserBlogsResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof UserBlogsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof UserBlogsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof UserBlogsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof UserBlogsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof UserBlogsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof UserBlogsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface UserTag
 */
export interface UserTag {
    /**
     * Number by which we multiply the tagged variable value to obtain the tag variable (ingredient) value
     * @type {number}
     * @memberof UserTag
     */
    conversionFactor: number;
    /**
     * This is the id of the variable being tagged with an ingredient or something.
     * @type {number}
     * @memberof UserTag
     */
    taggedVariableId: number;
    /**
     * This is the id of the ingredient variable whose value is determined based on the value of the tagged variable.
     * @type {number}
     * @memberof UserTag
     */
    tagVariableId: number;
}

/**
 * 
 * @export
 * @interface UserVariableDelete
 */
export interface UserVariableDelete {
    /**
     * Id of the variable whose measurements should be deleted
     * @type {number}
     * @memberof UserVariableDelete
     */
    variableId: number;
}

/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof UsersResponse
     */
    users: Array<User>;
    /**
     * Users who granted access to their data
     * @type {string}
     * @memberof UsersResponse
     */
    description?: string;
    /**
     * Users who granted access to their data
     * @type {string}
     * @memberof UsersResponse
     */
    summary?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof UsersResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof UsersResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof UsersResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof UsersResponse
     */
    code?: number;
    /**
     * 
     * @type {Image}
     * @memberof UsersResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof UsersResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof UsersResponse
     */
    ionIcon?: string;
    /**
     * Users who granted access to their data
     * @type {string}
     * @memberof UsersResponse
     */
    html?: string;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof UsersResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof UsersResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface Variable
 */
export interface Variable {
    /**
     * 
     * @type {Array<TrackingReminderNotificationAction>}
     * @memberof Variable
     */
    actionArray?: Array<TrackingReminderNotificationAction>;
    /**
     * User-Defined Variable Setting:  Alternative display name
     * @type {string}
     * @memberof Variable
     */
    alias?: string;
    /**
     * 
     * @type {Array<Unit>}
     * @memberof Variable
     */
    availableUnits?: Array<Unit>;
    /**
     * Link to study comparing variable with strongest relationship for user or population
     * @type {string}
     * @memberof Variable
     */
    bestStudyLink?: string;
    /**
     * Description of relationship with variable with strongest relationship for user or population
     * @type {Card}
     * @memberof Variable
     */
    bestStudyCard?: Card;
    /**
     * Link to study comparing variable with strongest relationship for user
     * @type {string}
     * @memberof Variable
     */
    bestUserStudyLink?: string;
    /**
     * Description of relationship with variable with strongest relationship for user
     * @type {Card}
     * @memberof Variable
     */
    bestUserStudyCard?: Card;
    /**
     * Link to study comparing variable with strongest relationship for population
     * @type {string}
     * @memberof Variable
     */
    bestPopulationStudyLink?: string;
    /**
     * Description of relationship with variable with strongest relationship for population
     * @type {Card}
     * @memberof Variable
     */
    bestPopulationStudyCard?: Card;
    /**
     * Description of relationship with variable with strongest relationship for user or population
     * @type {string}
     * @memberof Variable
     */
    optimalValueMessage?: string;
    /**
     * Description of relationship with variable with strongest relationship for population
     * @type {string}
     * @memberof Variable
     */
    commonOptimalValueMessage?: string;
    /**
     * Description of relationship with variable with strongest relationship for user
     * @type {string}
     * @memberof Variable
     */
    userOptimalValueMessage?: string;
    /**
     * Card containing instructions, image, text, link and relevant import buttons
     * @type {Card}
     * @memberof Variable
     */
    card?: Card;
    /**
     * User-Defined Variable Setting: True indicates that this variable is generally a cause in a causal relationship.  An example of a causeOnly variable would be a variable such as Cloud Cover which would generally not be influenced by the behaviour of the user
     * @type {boolean}
     * @memberof Variable
     */
    causeOnly?: boolean;
    /**
     * 
     * @type {VariableCharts}
     * @memberof Variable
     */
    charts?: VariableCharts;
    /**
     * Ex: https://local.quantimo.do/ionic/Modo/www/#/app/charts/Trader%20Joes%20Bedtime%20Tea%20%2F%20Sleepytime%20Tea%20%28any%20Brand%29?variableName=Trader%20Joes%20Bedtime%20Tea%20%2F%20Sleepytime%20Tea%20%28any%20Brand%29&userId=230&pngUrl=https%3A%2F%2Fapp.quantimo.do%2Fionic%2FModo%2Fwww%2Fimg%2Fvariable_categories%2Ftreatments.png
     * @type {string}
     * @memberof Variable
     */
    chartsLinkDynamic?: string;
    /**
     * Ex: mailto:?subject=Check%20out%20my%20Trader%20Joes%20Bedtime%20Tea%20%2F%20Sleepytime%20Tea%20%28any%20Brand%29%20data%21&body=See%20my%20Trader%20Joes%20Bedtime%20Tea%20%2F%20Sleepytime%20Tea%20%28any%20Brand%29%20history%20at%20https%3A%2F%2Flocal.quantimo.do%2Fapi%2Fv2%2Fcharts%3FvariableName%3DTrader%2520Joes%2520Bedtime%2520Tea%2520%252F%2520Sleepytime%2520Tea%2520%2528any%2520Brand%2529%26userId%3D230%26pngUrl%3Dhttps%253A%252F%252Fapp.quantimo.do%252Fionic%252FModo%252Fwww%252Fimg%252Fvariable_categories%252Ftreatments.png%0A%0AHave%20a%20great%20day!
     * @type {string}
     * @memberof Variable
     */
    chartsLinkEmail?: string;
    /**
     * Ex: https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Flocal.quantimo.do%2Fapi%2Fv2%2Fcharts%3FvariableName%3DTrader%2520Joes%2520Bedtime%2520Tea%2520%252F%2520Sleepytime%2520Tea%2520%2528any%2520Brand%2529%26userId%3D230%26pngUrl%3Dhttps%253A%252F%252Fapp.quantimo.do%252Fionic%252FModo%252Fwww%252Fimg%252Fvariable_categories%252Ftreatments.png
     * @type {string}
     * @memberof Variable
     */
    chartsLinkFacebook?: string;
    /**
     * Ex: https://plus.google.com/share?url=https%3A%2F%2Flocal.quantimo.do%2Fapi%2Fv2%2Fcharts%3FvariableName%3DTrader%2520Joes%2520Bedtime%2520Tea%2520%252F%2520Sleepytime%2520Tea%2520%2528any%2520Brand%2529%26userId%3D230%26pngUrl%3Dhttps%253A%252F%252Fapp.quantimo.do%252Fionic%252FModo%252Fwww%252Fimg%252Fvariable_categories%252Ftreatments.png
     * @type {string}
     * @memberof Variable
     */
    chartsLinkGoogle?: string;
    /**
     * Ex: https://local.quantimo.do/api/v2/charts?variableName=Trader%20Joes%20Bedtime%20Tea%20%2F%20Sleepytime%20Tea%20%28any%20Brand%29&userId=230&pngUrl=https%3A%2F%2Fapp.quantimo.do%2Fionic%2FModo%2Fwww%2Fimg%2Fvariable_categories%2Ftreatments.png
     * @type {string}
     * @memberof Variable
     */
    chartsLinkStatic?: string;
    /**
     * Ex: https://twitter.com/home?status=Check%20out%20my%20Trader%20Joes%20Bedtime%20Tea%20%2F%20Sleepytime%20Tea%20%28any%20Brand%29%20data%21%20https%3A%2F%2Flocal.quantimo.do%2Fapi%2Fv2%2Fcharts%3FvariableName%3DTrader%2520Joes%2520Bedtime%2520Tea%2520%252F%2520Sleepytime%2520Tea%2520%2528any%2520Brand%2529%26userId%3D230%26pngUrl%3Dhttps%253A%252F%252Fapp.quantimo.do%252Fionic%252FModo%252Fwww%252Fimg%252Fvariable_categories%252Ftreatments.png%20%40quantimodo
     * @type {string}
     * @memberof Variable
     */
    chartsLinkTwitter?: string;
    /**
     * Commonly defined for all users. An example of a parent category variable would be Fruit when tagged with the child sub-type variables Apple.  Child variable (Apple) measurements will be included when the parent category (Fruit) is analyzed.  This allows us to see how Fruit consumption might be affecting without having to record both Fruit and Apple intake.
     * @type {Array<Variable>}
     * @memberof Variable
     */
    childCommonTagVariables?: Array<Variable>;
    /**
     * User-Defined Variable Setting: An example of a parent category variable would be Fruit when tagged with the child sub-type variables Apple.  Child variable (Apple) measurements will be included when the parent category (Fruit) is analyzed.  This allows us to see how Fruit consumption might be affecting without having to record both Fruit and Apple intake.
     * @type {Array<Variable>}
     * @memberof Variable
     */
    childUserTagVariables?: Array<Variable>;
    /**
     * Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @type {string}
     * @memberof Variable
     */
    clientId?: string;
    /**
     * User-Defined Variable Setting: How to aggregate measurements over time. SUM should be used for things like minutes of exercise.  If you use MEAN for exercise, then a person might exercise more minutes in one day but add separate measurements that were smaller.  So when we are doing correlational analysis, we would think that the person exercised less that day even though they exercised more.  Conversely, we must use MEAN for things such as ratings which cannot be SUMMED.
     * @type {string}
     * @memberof Variable
     */
    combinationOperation?: Variable.CombinationOperationEnum;
    /**
     * Ex: Anxiety / Nervousness
     * @type {string}
     * @memberof Variable
     */
    commonAlias?: string;
    /**
     * 
     * @type {Array<Variable>}
     * @memberof Variable
     */
    commonTaggedVariables?: Array<Variable>;
    /**
     * 
     * @type {Array<Variable>}
     * @memberof Variable
     */
    commonTagVariables?: Array<Variable>;
    /**
     * When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format
     * @type {string}
     * @memberof Variable
     */
    createdAt?: string;
    /**
     * Comma-separated list of source names to limit variables to those sources
     * @type {string}
     * @memberof Variable
     */
    dataSourceNames?: string;
    /**
     * These are sources of measurements for this variable
     * @type {Array<DataSource>}
     * @memberof Variable
     */
    dataSources?: Array<DataSource>;
    /**
     * User-Defined Variable Setting: Ex: Summary to be used in studies.
     * @type {string}
     * @memberof Variable
     */
    description?: string;
    /**
     * Ex: Trader Joe's Bedtime Tea
     * @type {string}
     * @memberof Variable
     */
    displayName?: string;
    /**
     * The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
     * @type {number}
     * @memberof Variable
     */
    durationOfAction?: number;
    /**
     * User-Defined Variable Setting: The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.  Unit: Hours
     * @type {number}
     * @memberof Variable
     */
    durationOfActionInHours?: number;
    /**
     * Earliest filling time
     * @type {number}
     * @memberof Variable
     */
    earliestFillingTime?: number;
    /**
     * Earliest measurement time
     * @type {number}
     * @memberof Variable
     */
    earliestMeasurementTime?: number;
    /**
     * Earliest source time
     * @type {number}
     * @memberof Variable
     */
    earliestSourceTime?: number;
    /**
     * Error message from last analysis
     * @type {string}
     * @memberof Variable
     */
    errorMessage?: string;
    /**
     * User-Defined Variable Setting: Latest measurement time to be used in analysis. Format: UTC ISO 8601 YYYY-MM-DDThh:mm:ss.
     * @type {string}
     * @memberof Variable
     */
    experimentEndTime?: string;
    /**
     * User-Defined Variable Setting: Earliest measurement time to be used in analysis. Format: UTC ISO 8601 YYYY-MM-DDThh:mm:ss.
     * @type {string}
     * @memberof Variable
     */
    experimentStartTime?: string;
    /**
     * User-Defined Variable Setting: When it comes to analysis to determine the effects of this variable, knowing when it did not occur is as important as knowing when it did occur. For example, if you are tracking a medication, it is important to know when you did not take it, but you do not have to log zero values for all the days when you haven't taken it. Hence, you can specify a filling value (typically 0) to insert whenever data is missing.
     * @type {string}
     * @memberof Variable
     */
    fillingType?: Variable.FillingTypeEnum;
    /**
     * User-Defined Variable Setting: When it comes to analysis to determine the effects of this variable, knowing when it did not occur is as important as knowing when it did occur. For example, if you are tracking a medication, it is important to know when you did not take it, but you do not have to log zero values for all the days when you haven't taken it. Hence, you can specify a filling value (typically 0) to insert whenever data is missing.  Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    fillingValue?: number;
    /**
     * Ex: ion-sad-outline
     * @type {string}
     * @memberof Variable
     */
    iconIcon?: string;
    /**
     * Ex: 95614
     * @type {number}
     * @memberof Variable
     */
    id: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Variable
     */
    imageUrl?: string;
    /**
     * Ex: https://google.com
     * @type {string}
     * @memberof Variable
     */
    informationalUrl?: string;
    /**
     * Commonly defined for all users. IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredient of the variable Lollipop could be Sugar.  This way you only have to record Lollipop consumption and we can use this data to see how sugar might be affecting you.
     * @type {Array<Variable>}
     * @memberof Variable
     */
    ingredientOfCommonTagVariables?: Array<Variable>;
    /**
     * Commonly defined for all users. IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredient of the variable Lollipop could be Sugar.  This way you only have to record Lollipop consumption and we can use this data to see how sugar might be affecting you.
     * @type {Array<Variable>}
     * @memberof Variable
     */
    ingredientCommonTagVariables?: Array<Variable>;
    /**
     * User-Defined Variable Setting: IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredient of the variable Lollipop could be Sugar.  This way you only have to record Lollipop consumption and we can use this data to see how sugar might be affecting you.
     * @type {Array<Variable>}
     * @memberof Variable
     */
    ingredientOfUserTagVariables?: Array<Variable>;
    /**
     * User-Defined Variable Setting: IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredient of the variable Lollipop could be Sugar.  This way you only have to record Lollipop consumption and we can use this data to see how sugar might be affecting you.
     * @type {Array<Variable>}
     * @memberof Variable
     */
    ingredientUserTagVariables?: Array<Variable>;
    /**
     * Type of input field to show for recording measurements
     * @type {string}
     * @memberof Variable
     */
    inputType?: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof Variable
     */
    ionIcon?: string;
    /**
     * Commonly defined for all users.  Joining can be used used to merge duplicate variables. For instance, if two variables called Apples (Red Delicious) and Red Delicious Apples are joined, when one of them is analyzed, the measurements for the other will be included as well.
     * @type {Array<Variable>}
     * @memberof Variable
     */
    joinedCommonTagVariables?: Array<Variable>;
    /**
     * User-Defined Variable Setting: Joining can be used used to merge duplicate variables. For instance, if two variables called Apples (Red Delicious) and Red Delicious Apples are joined, when one of them is analyzed, the measurements for the other will be included as well.
     * @type {Array<Variable>}
     * @memberof Variable
     */
    joinedUserTagVariables?: Array<Variable>;
    /**
     * Duplicate variables. If the variable is joined with some other variable then it is not shown to user in the list of variables
     * @type {number}
     * @memberof Variable
     */
    joinWith?: number;
    /**
     * Kurtosis
     * @type {number}
     * @memberof Variable
     */
    kurtosis?: number;
    /**
     * Calculated Statistic: Ex: 500. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    lastProcessedDailyValue?: number;
    /**
     * When this variable or its settings were last updated UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof Variable
     */
    lastSuccessfulUpdateTime?: string;
    /**
     * Calculated Statistic: Last measurement value in the common unit or user unit if different. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    lastValue?: number;
    /**
     * Latest filling time
     * @type {number}
     * @memberof Variable
     */
    latestFillingTime?: number;
    /**
     * Latest measurement time. Format: Unix-time epoch seconds.
     * @type {number}
     * @memberof Variable
     */
    latestMeasurementTime?: number;
    /**
     * Latest source time. Format: Unix-time epoch seconds.
     * @type {number}
     * @memberof Variable
     */
    latestSourceTime?: number;
    /**
     * Ex: 1501383600. Format: Unix-time epoch seconds.
     * @type {number}
     * @memberof Variable
     */
    latestUserMeasurementTime?: number;
    /**
     * Latitude. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    latitude?: number;
    /**
     * Location
     * @type {string}
     * @memberof Variable
     */
    location?: string;
    /**
     * Longitude
     * @type {number}
     * @memberof Variable
     */
    longitude?: number;
    /**
     * True if the variable is an emotion or symptom rating that is not typically automatically collected by a device or app.
     * @type {boolean}
     * @memberof Variable
     */
    manualTracking?: boolean;
    /**
     * User-Defined Variable Setting: The maximum allowed value a daily aggregated measurement. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    maximumAllowedDailyValue?: number;
    /**
     * User-Defined Variable Setting: The maximum allowed value a single measurement. While you can record a value above this maximum, it will be excluded from the correlation analysis.  Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    maximumAllowedValue?: number;
    /**
     * Calculated Statistic: Maximum recorded daily value of this variable. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    maximumRecordedDailyValue?: number;
    /**
     * Calculated Statistic: Ex: 1. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    maximumRecordedValue?: number;
    /**
     * Mean. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    mean?: number;
    /**
     * Number of measurements at last analysis
     * @type {number}
     * @memberof Variable
     */
    measurementsAtLastAnalysis?: number;
    /**
     * Median
     * @type {number}
     * @memberof Variable
     */
    median?: number;
    /**
     * User-Defined Variable Setting: The minimum allowed value a single measurement. While you can record a value below this minimum, it will be excluded from the correlation analysis. Unit: User-specified or common
     * @type {number}
     * @memberof Variable
     */
    minimumAllowedValue?: number;
    /**
     * User-Defined Variable Setting: The minimum allowed value a daily aggregated measurement.  For instance, you might set to 100 for steps to keep erroneous 0 daily steps out of the analysis. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    minimumAllowedDailyValue?: number;
    /**
     * User-Defined Variable Setting: The minimum allowed non-zero value a single measurement.  For instance, you might set to 100 mL for steps to keep erroneous 0 daily steps out of the analysis. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    minimumNonZeroValue?: number;
    /**
     * Minimum recorded value of this variable. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    minimumRecordedValue?: number;
    /**
     * Ex: 51
     * @type {number}
     * @memberof Variable
     */
    mostCommonConnectorId?: number;
    /**
     * Ex: 23
     * @type {number}
     * @memberof Variable
     */
    mostCommonOriginalUnitId?: number;
    /**
     * Most common Unit ID
     * @type {number}
     * @memberof Variable
     */
    mostCommonUnitId?: number;
    /**
     * Calculated Statistic: Most common value. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    mostCommonValue?: number;
    /**
     * Ex: Trader Joes Bedtime Tea / Sleepytime Tea (any Brand)
     * @type {string}
     * @memberof Variable
     */
    name: string;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Variable
     */
    numberOfAggregateCorrelationsAsCause?: number;
    /**
     * Ex: 310
     * @type {number}
     * @memberof Variable
     */
    numberOfAggregateCorrelationsAsEffect?: number;
    /**
     * Number of changes
     * @type {number}
     * @memberof Variable
     */
    numberOfChanges?: number;
    /**
     * Number of correlations for this variable
     * @type {number}
     * @memberof Variable
     */
    numberOfCorrelations?: number;
    /**
     * numberOfAggregateCorrelationsAsCause plus numberOfUserCorrelationsAsCause
     * @type {number}
     * @memberof Variable
     */
    numberOfCorrelationsAsCause?: number;
    /**
     * numberOfAggregateCorrelationsAsEffect plus numberOfUserCorrelationsAsEffect
     * @type {number}
     * @memberof Variable
     */
    numberOfCorrelationsAsEffect?: number;
    /**
     * Number of processed measurements
     * @type {number}
     * @memberof Variable
     */
    numberOfProcessedDailyMeasurements?: number;
    /**
     * Ex: 295
     * @type {number}
     * @memberof Variable
     */
    numberOfRawMeasurements?: number;
    /**
     * Ex: 1
     * @type {number}
     * @memberof Variable
     */
    numberOfTrackingReminders?: number;
    /**
     * Number of unique daily values
     * @type {number}
     * @memberof Variable
     */
    numberOfUniqueDailyValues?: number;
    /**
     * Ex: 2
     * @type {number}
     * @memberof Variable
     */
    numberOfUniqueValues?: number;
    /**
     * Ex: 115
     * @type {number}
     * @memberof Variable
     */
    numberOfUserCorrelationsAsCause?: number;
    /**
     * Ex: 29014
     * @type {number}
     * @memberof Variable
     */
    numberOfUserCorrelationsAsEffect?: number;
    /**
     * Ex: 2
     * @type {number}
     * @memberof Variable
     */
    numberOfUserVariables?: number;
    /**
     * The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
     * @type {number}
     * @memberof Variable
     */
    onsetDelay?: number;
    /**
     * User-Defined Variable Setting: The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
     * @type {number}
     * @memberof Variable
     */
    onsetDelayInHours?: number;
    /**
     * User-Defined Variable Setting: True for variables for which a human would generally want to identify the influencing factors. These include symptoms of illness, physique, mood, cognitive performance, etc.  Generally correlation calculations are only performed on outcome variables
     * @type {boolean}
     * @memberof Variable
     */
    outcome?: boolean;
    /**
     * Do you want to receive updates on newly discovered factors influencing this variable?
     * @type {boolean}
     * @memberof Variable
     */
    outcomeOfInterest?: boolean;
    /**
     * Commonly defined for all users.  An example of a parent category variable would be Fruit when tagged with the child sub-type variables Apple.  Child variable (Apple) measurements will be included when the parent category (Fruit) is analyzed.  This allows us to see how Fruit consumption might be affecting without having to record both Fruit and Apple intake.
     * @type {Array<Variable>}
     * @memberof Variable
     */
    parentCommonTagVariables?: Array<Variable>;
    /**
     * User-defined. An example of a parent category variable would be Fruit when tagged with the child sub-type variables Apple.  Child variable (Apple) measurements will be included when the parent category (Fruit) is analyzed.  This allows us to see how Fruit consumption might be affecting without having to record both Fruit and Apple intake.
     * @type {Array<Variable>}
     * @memberof Variable
     */
    parentUserTagVariables?: Array<Variable>;
    /**
     * Ex: img/variable_categories/treatments.png
     * @type {string}
     * @memberof Variable
     */
    pngPath?: string;
    /**
     * Ex: https://web.quantimo.do/img/variable_categories/treatments.png
     * @type {string}
     * @memberof Variable
     */
    pngUrl?: string;
    /**
     * Ex: 0
     * @type {number}
     * @memberof Variable
     */
    predictorOfInterest?: number;
    /**
     * Ex: 95.4
     * @type {number}
     * @memberof Variable
     */
    price?: number;
    /**
     * Link to associated product for purchase
     * @type {string}
     * @memberof Variable
     */
    productUrl?: string;
    /**
     * Should this variable show up in automcomplete searches for users who do not already have measurements for it?
     * @type {boolean}
     * @memberof Variable
     */
    _public?: boolean;
    /**
     * Ex: How is your overall mood?
     * @type {string}
     * @memberof Variable
     */
    question?: string;
    /**
     * Ex: How is your overall mood on a scale of 1 to 5??
     * @type {string}
     * @memberof Variable
     */
    longQuestion?: string;
    /**
     * Ex: 131
     * @type {number}
     * @memberof Variable
     */
    rawMeasurementsAtLastAnalysis?: number;
    /**
     * Calculated Statistic: Ex: 1. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    secondMostCommonValue?: number;
    /**
     * Calculated Statistic: Ex: 250. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    secondToLastValue?: number;
    /**
     * Would you like to make your measurements publicly visible?
     * @type {boolean}
     * @memberof Variable
     */
    shareUserMeasurements?: boolean;
    /**
     * Skewness
     * @type {number}
     * @memberof Variable
     */
    skewness?: number;
    /**
     * Standard deviation Ex: 0.46483219855434
     * @type {number}
     * @memberof Variable
     */
    standardDeviation?: number;
    /**
     * status
     * @type {string}
     * @memberof Variable
     */
    status?: string;
    /**
     * Based on sort filter and can be shown beneath variable name on search list
     * @type {string}
     * @memberof Variable
     */
    subtitle?: string;
    /**
     * Ex: https://web.quantimo.do/img/variable_categories/treatments.svg
     * @type {string}
     * @memberof Variable
     */
    svgUrl?: string;
    /**
     * Calculated Statistic: Ex: 6. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    thirdMostCommonValue?: number;
    /**
     * Calculated Statistic: Ex: 250. Unit: User-specified or common.
     * @type {number}
     * @memberof Variable
     */
    thirdToLastValue?: number;
    /**
     * HTML instructions for tracking
     * @type {string}
     * @memberof Variable
     */
    trackingInstructions?: string;
    /**
     * Instructions for tracking with buttons and images
     * @type {Card}
     * @memberof Variable
     */
    trackingInstructionsCard?: Card;
    /**
     * 
     * @type {Unit}
     * @memberof Variable
     */
    unit?: Unit;
    /**
     * Ex: count
     * @type {string}
     * @memberof Variable
     */
    unitAbbreviatedName?: string;
    /**
     * Ex: 6
     * @type {number}
     * @memberof Variable
     */
    unitCategoryId?: number;
    /**
     * Ex: Miscellany
     * @type {string}
     * @memberof Variable
     */
    unitCategoryName?: string;
    /**
     * ID of unit to use for this variable
     * @type {number}
     * @memberof Variable
     */
    unitId?: number;
    /**
     * User-Defined Variable Setting: Count
     * @type {string}
     * @memberof Variable
     */
    unitName?: string;
    /**
     * Universal product code or similar
     * @type {string}
     * @memberof Variable
     */
    upc?: string;
    /**
     * updated
     * @type {number}
     * @memberof Variable
     */
    updated?: number;
    /**
     * When the record in the database was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format
     * @type {string}
     * @memberof Variable
     */
    updatedAt?: string;
    /**
     * Ex: 2017-07-30 14:58:26
     * @type {string}
     * @memberof Variable
     */
    updatedTime?: string;
    /**
     * User ID
     * @type {number}
     * @memberof Variable
     */
    userId: number;
    /**
     * 
     * @type {Array<Variable>}
     * @memberof Variable
     */
    userTaggedVariables?: Array<Variable>;
    /**
     * 
     * @type {Array<Variable>}
     * @memberof Variable
     */
    userTagVariables?: Array<Variable>;
    /**
     * Ex: count
     * @type {string}
     * @memberof Variable
     */
    userVariableUnitAbbreviatedName?: string;
    /**
     * Ex: 6
     * @type {number}
     * @memberof Variable
     */
    userVariableUnitCategoryId?: number;
    /**
     * Ex: Miscellany
     * @type {string}
     * @memberof Variable
     */
    userVariableUnitCategoryName?: string;
    /**
     * Ex: 23
     * @type {number}
     * @memberof Variable
     */
    userVariableUnitId?: number;
    /**
     * Ex: Count
     * @type {string}
     * @memberof Variable
     */
    userVariableUnitName?: string;
    /**
     * 
     * @type {VariableCategory}
     * @memberof Variable
     */
    variableCategory?: VariableCategory;
    /**
     * Array of Variables that are joined with this Variable
     * @type {Array<Variable>}
     * @memberof Variable
     */
    joinedVariables?: Array<Variable>;
    /**
     * Valence indicates what type of buttons should be used when recording measurements for this variable. positive - Face buttons with the happiest face equating to a 5/5 rating where higher is better like Overall Mood. negative - Face buttons with happiest face equating to a 1/5 rating where lower is better like Headache Severity. numeric - Just 1 to 5 numeric buttons for neutral variables. 
     * @type {string}
     * @memberof Variable
     */
    valence?: string;
    /**
     * Ex: 6
     * @type {number}
     * @memberof Variable
     */
    variableCategoryId?: number;
    /**
     * User-Defined Variable Setting: Variable category like Emotions, Sleep, Physical Activities, Treatments, Symptoms, etc.
     * @type {string}
     * @memberof Variable
     */
    variableCategoryName?: Variable.VariableCategoryNameEnum;
    /**
     * Ex: 96380
     * @type {number}
     * @memberof Variable
     */
    variableId: number;
    /**
     * Ex: Sleep Duration
     * @type {string}
     * @memberof Variable
     */
    variableName?: string;
    /**
     * Statistic: Ex: 115947037.40816
     * @type {number}
     * @memberof Variable
     */
    variance?: number;
    /**
     * User-Defined Variable Setting: You can help to improve the studies by pasting the title of the most appropriate Wikipedia article for this variable
     * @type {string}
     * @memberof Variable
     */
    wikipediaTitle?: string;
}

/**
 * @export
 * @namespace Variable
 */
export namespace Variable {
    /**
     * @export
     * @enum {string}
     */
    export enum CombinationOperationEnum {
        MEAN = <any> 'MEAN',
        SUM = <any> 'SUM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FillingTypeEnum {
        None = <any> 'none',
        ZeroFilling = <any> 'zero-filling',
        ValueFilling = <any> 'value-filling'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VariableCategoryNameEnum {
        Activity = <any> 'Activity',
        Books = <any> 'Books',
        CausesOfIllness = <any> 'Causes of Illness',
        CognitivePerformance = <any> 'Cognitive Performance',
        Conditions = <any> 'Conditions',
        Emotions = <any> 'Emotions',
        Environment = <any> 'Environment',
        Foods = <any> 'Foods',
        Goals = <any> 'Goals',
        Locations = <any> 'Locations',
        Miscellaneous = <any> 'Miscellaneous',
        MoviesAndTV = <any> 'Movies and TV',
        Music = <any> 'Music',
        Nutrients = <any> 'Nutrients',
        Payments = <any> 'Payments',
        PhysicalActivities = <any> 'Physical Activities',
        Physique = <any> 'Physique',
        Sleep = <any> 'Sleep',
        SocialInteractions = <any> 'Social Interactions',
        Software = <any> 'Software',
        Symptoms = <any> 'Symptoms',
        Treatments = <any> 'Treatments',
        VitalSigns = <any> 'Vital Signs'
    }
}

/**
 * 
 * @export
 * @interface VariableCategory
 */
export interface VariableCategory {
    /**
     * Ex: mood
     * @type {string}
     * @memberof VariableCategory
     */
    appType?: string;
    /**
     * Ex: false
     * @type {boolean}
     * @memberof VariableCategory
     */
    causeOnly?: boolean;
    /**
     * Ex: MEAN
     * @type {string}
     * @memberof VariableCategory
     */
    combinationOperation?: string;
    /**
     * UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof VariableCategory
     */
    createdTime?: string;
    /**
     * Ex: /5
     * @type {string}
     * @memberof VariableCategory
     */
    unitAbbreviatedName?: string;
    /**
     * Ex: 10
     * @type {number}
     * @memberof VariableCategory
     */
    unitId?: number;
    /**
     * User-Defined Variable Setting: The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.  Unit: Seconds
     * @type {number}
     * @memberof VariableCategory
     */
    durationOfAction?: number;
    /**
     * Ex: -1. Unit: Variable category default unit.
     * @type {number}
     * @memberof VariableCategory
     */
    fillingValue?: number;
    /**
     * Ex: What emotion do you want to rate?
     * @type {string}
     * @memberof VariableCategory
     */
    helpText?: string;
    /**
     * Ex: 1
     * @type {number}
     * @memberof VariableCategory
     */
    id?: number;
    /**
     * Ex: https://static.quantimo.do/img/variable_categories/theatre_mask-96.png
     * @type {string}
     * @memberof VariableCategory
     */
    imageUrl?: string;
    /**
     * Ex: ion-happy-outline
     * @type {string}
     * @memberof VariableCategory
     */
    ionIcon?: string;
    /**
     * Ex: true
     * @type {boolean}
     * @memberof VariableCategory
     */
    manualTracking?: boolean;
    /**
     * Unit: Variable category default unit.
     * @type {string}
     * @memberof VariableCategory
     */
    maximumAllowedValue?: string;
    /**
     * Ex: rating
     * @type {string}
     * @memberof VariableCategory
     */
    measurementSynonymSingularLowercase?: string;
    /**
     * Unit: Variable category default unit.
     * @type {string}
     * @memberof VariableCategory
     */
    minimumAllowedValue?: string;
    /**
     * Ex: Do you have any emotions that fluctuate regularly?  If so, add them so I can try to determine which factors are influencing them.
     * @type {string}
     * @memberof VariableCategory
     */
    moreInfo?: string;
    /**
     * Category name
     * @type {string}
     * @memberof VariableCategory
     */
    name: string;
    /**
     * Ex: 0
     * @type {number}
     * @memberof VariableCategory
     */
    onsetDelay?: number;
    /**
     * Ex: true
     * @type {boolean}
     * @memberof VariableCategory
     */
    outcome?: boolean;
    /**
     * Ex: img/variable_categories/emotions.png
     * @type {string}
     * @memberof VariableCategory
     */
    pngPath?: string;
    /**
     * Ex: https://web.quantimo.do/img/variable_categories/emotions.png
     * @type {string}
     * @memberof VariableCategory
     */
    pngUrl?: string;
    /**
     * Ex: true
     * @type {boolean}
     * @memberof VariableCategory
     */
    _public?: boolean;
    /**
     * Ex: img/variable_categories/emotions.svg
     * @type {string}
     * @memberof VariableCategory
     */
    svgPath?: string;
    /**
     * Ex: https://web.quantimo.do/img/variable_categories/emotions.svg
     * @type {string}
     * @memberof VariableCategory
     */
    svgUrl?: string;
    /**
     * Ex: 1
     * @type {number}
     * @memberof VariableCategory
     */
    updated?: number;
    /**
     * UTC ISO 8601 YYYY-MM-DDThh:mm:ss
     * @type {string}
     * @memberof VariableCategory
     */
    updatedTime?: string;
    /**
     * Ex: Emotions, Treatments, Symptoms...
     * @type {string}
     * @memberof VariableCategory
     */
    variableCategoryName?: VariableCategory.VariableCategoryNameEnum;
    /**
     * Ex: Emotion
     * @type {string}
     * @memberof VariableCategory
     */
    variableCategoryNameSingular?: string;
}

/**
 * @export
 * @namespace VariableCategory
 */
export namespace VariableCategory {
    /**
     * @export
     * @enum {string}
     */
    export enum VariableCategoryNameEnum {
        Activity = <any> 'Activity',
        Books = <any> 'Books',
        CausesOfIllness = <any> 'Causes of Illness',
        CognitivePerformance = <any> 'Cognitive Performance',
        Conditions = <any> 'Conditions',
        Emotions = <any> 'Emotions',
        Environment = <any> 'Environment',
        Foods = <any> 'Foods',
        Goals = <any> 'Goals',
        Locations = <any> 'Locations',
        Miscellaneous = <any> 'Miscellaneous',
        MoviesAndTV = <any> 'Movies and TV',
        Music = <any> 'Music',
        Nutrients = <any> 'Nutrients',
        Payments = <any> 'Payments',
        PhysicalActivities = <any> 'Physical Activities',
        Physique = <any> 'Physique',
        Sleep = <any> 'Sleep',
        SocialInteractions = <any> 'Social Interactions',
        Software = <any> 'Software',
        Symptoms = <any> 'Symptoms',
        Treatments = <any> 'Treatments',
        VitalSigns = <any> 'Vital Signs'
    }
}

/**
 * An object with various chart properties each property contain and svg and Highcharts configuration
 * @export
 * @interface VariableCharts
 */
export interface VariableCharts {
    /**
     * 
     * @type {Chart}
     * @memberof VariableCharts
     */
    hourlyColumnChart?: Chart;
    /**
     * 
     * @type {Chart}
     * @memberof VariableCharts
     */
    monthlyColumnChart?: Chart;
    /**
     * 
     * @type {Chart}
     * @memberof VariableCharts
     */
    distributionColumnChart?: Chart;
    /**
     * 
     * @type {Chart}
     * @memberof VariableCharts
     */
    weekdayColumnChart?: Chart;
    /**
     * 
     * @type {Chart}
     * @memberof VariableCharts
     */
    lineChartWithoutSmoothing?: Chart;
    /**
     * 
     * @type {Chart}
     * @memberof VariableCharts
     */
    lineChartWithSmoothing?: Chart;
}

/**
 * 
 * @export
 * @interface Vote
 */
export interface Vote {
    /**
     * Cause variable id
     * @type {number}
     * @memberof Vote
     */
    causeVariableId: number;
    /**
     * Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @type {string}
     * @memberof Vote
     */
    clientId: string;
    /**
     * When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format
     * @type {string}
     * @memberof Vote
     */
    createdAt?: string;
    /**
     * Effect variable id
     * @type {number}
     * @memberof Vote
     */
    effectVariableId: number;
    /**
     * id
     * @type {number}
     * @memberof Vote
     */
    id?: number;
    /**
     * When the record in the database was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format
     * @type {string}
     * @memberof Vote
     */
    updatedAt?: string;
    /**
     * ID of User
     * @type {number}
     * @memberof Vote
     */
    userId: number;
    /**
     * Vote down for implausible/not-useful or up for plausible/useful. Vote none to delete a previous vote.
     * @type {string}
     * @memberof Vote
     */
    value: Vote.ValueEnum;
    /**
     * Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @type {string}
     * @memberof Vote
     */
    type?: Vote.TypeEnum;
}

/**
 * @export
 * @namespace Vote
 */
export namespace Vote {
    /**
     * @export
     * @enum {string}
     */
    export enum ValueEnum {
        Up = <any> 'up',
        Down = <any> 'down',
        None = <any> 'none'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Causality = <any> 'causality',
        Usefulness = <any> 'usefulness'
    }
}

/**
 * 
 * @export
 * @interface VoteDelete
 */
export interface VoteDelete {
    /**
     * Cause variable name for the correlation to which the vote pertains
     * @type {string}
     * @memberof VoteDelete
     */
    cause: string;
    /**
     * Effect variable name for the correlation to which the vote pertains
     * @type {string}
     * @memberof VoteDelete
     */
    effect: string;
}

/**
 * 
 * @export
 * @interface XprofileDataResponse
 */
export interface XprofileDataResponse {
    /**
     * 
     * @type {Array<XprofileDatum>}
     * @memberof XprofileDataResponse
     */
    xprofileData: Array<XprofileDatum>;
    /**
     * XprofileDatum
     * @type {string}
     * @memberof XprofileDataResponse
     */
    description?: string;
    /**
     * XprofileDatum
     * @type {string}
     * @memberof XprofileDataResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof XprofileDataResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof XprofileDataResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof XprofileDataResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof XprofileDataResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof XprofileDataResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof XprofileDataResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof XprofileDataResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof XprofileDataResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof XprofileDataResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof XprofileDataResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface XprofileDatum
 */
export interface XprofileDatum {
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileDatum
     */
    id: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileDatum
     */
    fieldId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileDatum
     */
    userId: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof XprofileDatum
     */
    value: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof XprofileDatum
     */
    lastUpdated: string;
    /**
     * Additional xprofiledatum key-value data
     * @type {Array<any>}
     * @memberof XprofileDatum
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface XprofileField
 */
export interface XprofileField {
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileField
     */
    id: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileField
     */
    groupId: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileField
     */
    parentId: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof XprofileField
     */
    type: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof XprofileField
     */
    name: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof XprofileField
     */
    description: string;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileField
     */
    isRequired: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileField
     */
    isDefaultOption: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileField
     */
    fieldOrder: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileField
     */
    optionOrder: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof XprofileField
     */
    orderBy: string;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileField
     */
    canDelete: number;
    /**
     * Additional xprofilefield key-value data
     * @type {Array<any>}
     * @memberof XprofileField
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface XprofileFieldsResponse
 */
export interface XprofileFieldsResponse {
    /**
     * 
     * @type {Array<XprofileField>}
     * @memberof XprofileFieldsResponse
     */
    xprofileFields: Array<XprofileField>;
    /**
     * XprofileField
     * @type {string}
     * @memberof XprofileFieldsResponse
     */
    description?: string;
    /**
     * XprofileField
     * @type {string}
     * @memberof XprofileFieldsResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof XprofileFieldsResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof XprofileFieldsResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof XprofileFieldsResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof XprofileFieldsResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof XprofileFieldsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof XprofileFieldsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof XprofileFieldsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof XprofileFieldsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof XprofileFieldsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof XprofileFieldsResponse
     */
    card?: Card;
}

/**
 * 
 * @export
 * @interface XprofileGroup
 */
export interface XprofileGroup {
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileGroup
     */
    id: number;
    /**
     * What do you expect?
     * @type {string}
     * @memberof XprofileGroup
     */
    name: string;
    /**
     * What do you expect?
     * @type {string}
     * @memberof XprofileGroup
     */
    description: string;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileGroup
     */
    groupOrder: number;
    /**
     * What do you expect?
     * @type {number}
     * @memberof XprofileGroup
     */
    canDelete: number;
    /**
     * Additional xprofilegroup key-value data
     * @type {Array<any>}
     * @memberof XprofileGroup
     */
    metaDataArray?: Array<any>;
}

/**
 * 
 * @export
 * @interface XprofileGroupsResponse
 */
export interface XprofileGroupsResponse {
    /**
     * 
     * @type {Array<XprofileGroup>}
     * @memberof XprofileGroupsResponse
     */
    xprofileGroups: Array<XprofileGroup>;
    /**
     * XprofileGroup
     * @type {string}
     * @memberof XprofileGroupsResponse
     */
    description?: string;
    /**
     * XprofileGroup
     * @type {string}
     * @memberof XprofileGroupsResponse
     */
    summary?: string;
    /**
     * 
     * @type {Image}
     * @memberof XprofileGroupsResponse
     */
    image?: Image;
    /**
     * Square icon png url
     * @type {string}
     * @memberof XprofileGroupsResponse
     */
    avatar?: string;
    /**
     * Ex: ion-ios-person
     * @type {string}
     * @memberof XprofileGroupsResponse
     */
    ionIcon?: string;
    /**
     * Embeddable list of study summaries with explanation at the top
     * @type {string}
     * @memberof XprofileGroupsResponse
     */
    html?: string;
    /**
     * Array of error objects with message property
     * @type {Array<Error>}
     * @memberof XprofileGroupsResponse
     */
    errors?: Array<Error>;
    /**
     * ex. OK or ERROR
     * @type {string}
     * @memberof XprofileGroupsResponse
     */
    status?: string;
    /**
     * true or false
     * @type {boolean}
     * @memberof XprofileGroupsResponse
     */
    success?: boolean;
    /**
     * Response code such as 200
     * @type {number}
     * @memberof XprofileGroupsResponse
     */
    code?: number;
    /**
     * A super neat url you might want to share with your users!
     * @type {string}
     * @memberof XprofileGroupsResponse
     */
    link?: string;
    /**
     * A super neat card with buttons and HTML that you can use in your app!
     * @type {Card}
     * @memberof XprofileGroupsResponse
     */
    card?: Card;
}


/**
 * ActivitiesApi - fetch parameter creator
 * @export
 */
export const ActivitiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Activities
         * @summary Get Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post Activities
         * @summary Post Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postActivities(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Activities
         * @summary Get Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActivitiesResponse>> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).getActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post Activities
         * @summary Post Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postActivities(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActivitiesResponse>> {
            const localVarFetchArgs = ActivitiesApiFetchParamCreator(configuration).postActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get Activities
         * @summary Get Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return ActivitiesApiFp(configuration).getActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post Activities
         * @summary Post Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postActivities(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return ActivitiesApiFp(configuration).postActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};

/**
 * ActivitiesApi - interface
 * @export
 * @interface ActivitiesApi
 */
export interface ActivitiesApiInterface {
    /**
     * Get Activities
     * @summary Get Activities
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApiInterface
     */
    getActivities(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<ActivitiesResponse>>;

    /**
     * Post Activities
     * @summary Post Activities
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApiInterface
     */
    postActivities(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<ActivitiesResponse>>;

}

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI implements ActivitiesApiInterface {
    /**
     * Get Activities
     * @summary Get Activities
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getActivities(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return ActivitiesApiFp(this.configuration).getActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post Activities
     * @summary Post Activities
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public postActivities(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return ActivitiesApiFp(this.configuration).postActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

}

/**
 * AnalyticsApi - fetch parameter creator
 * @export
 */
export const AnalyticsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get explanations of  correlations based on data from a single user.
         * @summary Get correlation explanations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelationExplanations(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/correlations/explanations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }

            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }

            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }

            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }

            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }

            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
         * @summary Get correlations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [commonOnly] Return only public, anonymized and aggregated population data instead of user-specific variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelations(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, commonOnly?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v3/correlations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }

            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }

            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }

            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }

            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }

            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (correlationCoefficient !== undefined) {
                localVarQueryParameter['correlationCoefficient'] = correlationCoefficient;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (outcomesOfInterest !== undefined) {
                localVarQueryParameter['outcomesOfInterest'] = outcomesOfInterest;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (commonOnly !== undefined) {
                localVarQueryParameter['commonOnly'] = commonOnly;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get explanations of  correlations based on data from a single user.
         * @summary Get correlation explanations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelationExplanations(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Correlation>> {
            const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).getCorrelationExplanations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
         * @summary Get correlations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [commonOnly] Return only public, anonymized and aggregated population data instead of user-specific variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelations(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, commonOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCorrelationsResponse> {
            const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).getCorrelations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get explanations of  correlations based on data from a single user.
         * @summary Get correlation explanations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelationExplanations(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, options?: any) {
            return AnalyticsApiFp(configuration).getCorrelationExplanations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options)(fetch, basePath);
        },
        /**
         * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
         * @summary Get correlations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [commonOnly] Return only public, anonymized and aggregated population data instead of user-specific variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelations(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, commonOnly?: boolean, options?: any) {
            return AnalyticsApiFp(configuration).getCorrelations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options)(fetch, basePath);
        },
    };
};

/**
 * AnalyticsApi - interface
 * @export
 * @interface AnalyticsApi
 */
export interface AnalyticsApiInterface {
    /**
     * Get explanations of  correlations based on data from a single user.
     * @summary Get correlation explanations
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    getCorrelationExplanations(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, options?: any): Promise<Array<Correlation>>;

    /**
     * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
     * @summary Get correlations
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {number} [userId] User&#39;s id
     * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [commonOnly] Return only public, anonymized and aggregated population data instead of user-specific variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    getCorrelations(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, commonOnly?: boolean, options?: any): Promise<GetCorrelationsResponse>;

}

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI implements AnalyticsApiInterface {
    /**
     * Get explanations of  correlations based on data from a single user.
     * @summary Get correlation explanations
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getCorrelationExplanations(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, options?: any) {
        return AnalyticsApiFp(this.configuration).getCorrelationExplanations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
     * @summary Get correlations
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {number} [userId] User&#39;s id
     * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [commonOnly] Return only public, anonymized and aggregated population data instead of user-specific variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getCorrelations(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, commonOnly?: boolean, options?: any) {
        return AnalyticsApiFp(this.configuration).getCorrelations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options)(this.fetch, this.basePath);
    }

}

/**
 * AppSettingsApi - fetch parameter creator
 * @export
 */
export const AppSettingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the settings for your application configurable at https://builder.quantimo.do
         * @summary Get client app settings
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppSettings(clientId?: string, clientSecret?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/appSettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (clientSecret !== undefined) {
                localVarQueryParameter['client_secret'] = clientSecret;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppSettingsApi - functional programming interface
 * @export
 */
export const AppSettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the settings for your application configurable at https://builder.quantimo.do
         * @summary Get client app settings
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppSettings(clientId?: string, clientSecret?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppSettingsResponse> {
            const localVarFetchArgs = AppSettingsApiFetchParamCreator(configuration).getAppSettings(clientId, clientSecret, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AppSettingsApi - factory interface
 * @export
 */
export const AppSettingsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get the settings for your application configurable at https://builder.quantimo.do
         * @summary Get client app settings
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppSettings(clientId?: string, clientSecret?: string, options?: any) {
            return AppSettingsApiFp(configuration).getAppSettings(clientId, clientSecret, options)(fetch, basePath);
        },
    };
};

/**
 * AppSettingsApi - interface
 * @export
 * @interface AppSettingsApi
 */
export interface AppSettingsApiInterface {
    /**
     * Get the settings for your application configurable at https://builder.quantimo.do
     * @summary Get client app settings
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppSettingsApiInterface
     */
    getAppSettings(clientId?: string, clientSecret?: string, options?: any): Promise<AppSettingsResponse>;

}

/**
 * AppSettingsApi - object-oriented interface
 * @export
 * @class AppSettingsApi
 * @extends {BaseAPI}
 */
export class AppSettingsApi extends BaseAPI implements AppSettingsApiInterface {
    /**
     * Get the settings for your application configurable at https://builder.quantimo.do
     * @summary Get client app settings
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppSettingsApi
     */
    public getAppSettings(clientId?: string, clientSecret?: string, options?: any) {
        return AppSettingsApiFp(this.configuration).getAppSettings(clientId, clientSecret, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)
         * @summary Get a user access token
         * @param {string} grantType Grant Type can be &#39;authorization_code&#39; or &#39;refresh_token&#39;
         * @param {string} code Authorization code you received with the previous request.
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(grantType: string, code: string, responseType: string, scope: string, clientId?: string, clientSecret?: string, redirectUri?: string, state?: string, options: any = {}): FetchArgs {
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType','Required parameter grantType was null or undefined when calling getAccessToken.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling getAccessToken.');
            }
            // verify required parameter 'responseType' is not null or undefined
            if (responseType === null || responseType === undefined) {
                throw new RequiredError('responseType','Required parameter responseType was null or undefined when calling getAccessToken.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling getAccessToken.');
            }
            const localVarPath = `/v3/oauth2/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (clientSecret !== undefined) {
                localVarQueryParameter['client_secret'] = clientSecret;
            }

            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
         * @summary Request Authorization Code
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthAuthorizationCode(responseType: string, scope: string, clientId?: string, clientSecret?: string, redirectUri?: string, state?: string, options: any = {}): FetchArgs {
            // verify required parameter 'responseType' is not null or undefined
            if (responseType === null || responseType === undefined) {
                throw new RequiredError('responseType','Required parameter responseType was null or undefined when calling getOauthAuthorizationCode.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling getOauthAuthorizationCode.');
            }
            const localVarPath = `/v3/oauth2/authorize`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (clientSecret !== undefined) {
                localVarQueryParameter['client_secret'] = clientSecret;
            }

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post GoogleIdToken
         * @summary Post GoogleIdToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGoogleIdToken(options: any = {}): FetchArgs {
            const localVarPath = `/v3/googleIdToken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)
         * @summary Get a user access token
         * @param {string} grantType Grant Type can be &#39;authorization_code&#39; or &#39;refresh_token&#39;
         * @param {string} code Authorization code you received with the previous request.
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(grantType: string, code: string, responseType: string, scope: string, clientId?: string, clientSecret?: string, redirectUri?: string, state?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).getAccessToken(grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
         * @summary Request Authorization Code
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthAuthorizationCode(responseType: string, scope: string, clientId?: string, clientSecret?: string, redirectUri?: string, state?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).getOauthAuthorizationCode(responseType, scope, clientId, clientSecret, redirectUri, state, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post GoogleIdToken
         * @summary Post GoogleIdToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGoogleIdToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).postGoogleIdToken(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)
         * @summary Get a user access token
         * @param {string} grantType Grant Type can be &#39;authorization_code&#39; or &#39;refresh_token&#39;
         * @param {string} code Authorization code you received with the previous request.
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(grantType: string, code: string, responseType: string, scope: string, clientId?: string, clientSecret?: string, redirectUri?: string, state?: string, options?: any) {
            return AuthenticationApiFp(configuration).getAccessToken(grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options)(fetch, basePath);
        },
        /**
         * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
         * @summary Request Authorization Code
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthAuthorizationCode(responseType: string, scope: string, clientId?: string, clientSecret?: string, redirectUri?: string, state?: string, options?: any) {
            return AuthenticationApiFp(configuration).getOauthAuthorizationCode(responseType, scope, clientId, clientSecret, redirectUri, state, options)(fetch, basePath);
        },
        /**
         * Post GoogleIdToken
         * @summary Post GoogleIdToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGoogleIdToken(options?: any) {
            return AuthenticationApiFp(configuration).postGoogleIdToken(options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)
     * @summary Get a user access token
     * @param {string} grantType Grant Type can be &#39;authorization_code&#39; or &#39;refresh_token&#39;
     * @param {string} code Authorization code you received with the previous request.
     * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
     * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
     * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    getAccessToken(grantType: string, code: string, responseType: string, scope: string, clientId?: string, clientSecret?: string, redirectUri?: string, state?: string, options?: any): Promise<{}>;

    /**
     * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
     * @summary Request Authorization Code
     * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
     * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
     * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    getOauthAuthorizationCode(responseType: string, scope: string, clientId?: string, clientSecret?: string, redirectUri?: string, state?: string, options?: any): Promise<{}>;

    /**
     * Post GoogleIdToken
     * @summary Post GoogleIdToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    postGoogleIdToken(options?: any): Promise<{}>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)
     * @summary Get a user access token
     * @param {string} grantType Grant Type can be &#39;authorization_code&#39; or &#39;refresh_token&#39;
     * @param {string} code Authorization code you received with the previous request.
     * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
     * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
     * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getAccessToken(grantType: string, code: string, responseType: string, scope: string, clientId?: string, clientSecret?: string, redirectUri?: string, state?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).getAccessToken(grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options)(this.fetch, this.basePath);
    }

    /**
     * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
     * @summary Request Authorization Code
     * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
     * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
     * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getOauthAuthorizationCode(responseType: string, scope: string, clientId?: string, clientSecret?: string, redirectUri?: string, state?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).getOauthAuthorizationCode(responseType, scope, clientId, clientSecret, redirectUri, state, options)(this.fetch, this.basePath);
    }

    /**
     * Post GoogleIdToken
     * @summary Post GoogleIdToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public postGoogleIdToken(options?: any) {
        return AuthenticationApiFp(this.configuration).postGoogleIdToken(options)(this.fetch, this.basePath);
    }

}

/**
 * ConnectorsApi - fetch parameter creator
 * @export
 */
export const ConnectorsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
         * @summary Obtain a token from 3rd party data source
         * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', userId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'connectorName' is not null or undefined
            if (connectorName === null || connectorName === undefined) {
                throw new RequiredError('connectorName',
                    'Required parameter connectorName was null or undefined when calling connectConnector.');
            }
            const localVarPath = `/v3/connectors/{connectorName}/connect`
                .replace(`{${"connectorName"}}`, encodeURIComponent(String(connectorName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The disconnect method deletes any stored tokens or connection information from the connectors database.
         * @summary Delete stored connection info
         * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', options: any = {}): FetchArgs {
            // verify required parameter 'connectorName' is not null or undefined
            if (connectorName === null || connectorName === undefined) {
                throw new RequiredError('connectorName','Required parameter connectorName was null or undefined when calling disconnectConnector.');
            }
            const localVarPath = `/v3/connectors/{connectorName}/disconnect`
                .replace(`{${"connectorName"}}`, encodeURIComponent(String(connectorName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
         * @summary List of Connectors
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors(clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/connectors/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get embeddable connect javascript. Usage:   - Embedding in applications with popups for 3rd-party authentication windows.     Use `qmSetupInPopup` function after connecting `connect.js`.   - Embedding in applications with popups for 3rd-party authentication windows.     Requires a selector to block. It will be embedded in this block.     Use `qmSetupOnPage` function after connecting `connect.js`.   - Embedding in mobile applications without popups for 3rd-party authentication.     Use `qmSetupOnMobile` function after connecting `connect.js`.     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
         * @summary Get embeddable connect javascript
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationJs(clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/integration.js`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v3/connect/mobile?access_token=123
         * @summary Mobile connect page
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMobileConnectPage(userId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v3/connect/mobile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
         * @summary Sync with data source
         * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', userId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'connectorName' is not null or undefined
            if (connectorName === null || connectorName === undefined) {
                throw new RequiredError('connectorName','Required parameter connectorName was null or undefined when calling updateConnector.');
            }
            const localVarPath = `/v3/connectors/{connectorName}/update`
                .replace(`{${"connectorName"}}`, encodeURIComponent(String(connectorName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorsApi - functional programming interface
 * @export
 */
export const ConnectorsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
         * @summary Obtain a token from 3rd party data source
         * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', userId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetConnectorsResponse> {
            const localVarFetchArgs = ConnectorsApiFetchParamCreator(configuration).connectConnector(connectorName, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                window.location.href = basePath + localVarFetchArgs.url;
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The disconnect method deletes any stored tokens or connection information from the connectors database.
         * @summary Delete stored connection info
         * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetConnectorsResponse> {
            const localVarFetchArgs = ConnectorsApiFetchParamCreator(configuration).disconnectConnector(connectorName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
         * @summary List of Connectors
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors(clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetConnectorsResponse> {
            const localVarFetchArgs = ConnectorsApiFetchParamCreator(configuration).getConnectors(clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get embeddable connect javascript. Usage:   - Embedding in applications with popups for 3rd-party authentication windows.     Use `qmSetupInPopup` function after connecting `connect.js`.   - Embedding in applications with popups for 3rd-party authentication windows.     Requires a selector to block. It will be embedded in this block.     Use `qmSetupOnPage` function after connecting `connect.js`.   - Embedding in mobile applications without popups for 3rd-party authentication.     Use `qmSetupOnMobile` function after connecting `connect.js`.     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
         * @summary Get embeddable connect javascript
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationJs(clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConnectorsApiFetchParamCreator(configuration).getIntegrationJs(clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v3/connect/mobile?access_token=123
         * @summary Mobile connect page
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMobileConnectPage(userId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConnectorsApiFetchParamCreator(configuration).getMobileConnectPage(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
         * @summary Sync with data source
         * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', userId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetConnectorsResponse> {
            const localVarFetchArgs = ConnectorsApiFetchParamCreator(configuration).updateConnector(connectorName, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConnectorsApi - factory interface
 * @export
 */
export const ConnectorsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
         * @summary Obtain a token from 3rd party data source
         * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', userId?: number, options?: any) {
            return ConnectorsApiFp(configuration).connectConnector(connectorName, userId, options)(fetch, basePath);
        },
        /**
         * The disconnect method deletes any stored tokens or connection information from the connectors database.
         * @summary Delete stored connection info
         * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', options?: any) {
            return ConnectorsApiFp(configuration).disconnectConnector(connectorName, options)(fetch, basePath);
        },
        /**
         * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
         * @summary List of Connectors
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors(clientId?: string, options?: any) {
            return ConnectorsApiFp(configuration).getConnectors(clientId, options)(fetch, basePath);
        },
        /**
         * Get embeddable connect javascript. Usage:   - Embedding in applications with popups for 3rd-party authentication windows.     Use `qmSetupInPopup` function after connecting `connect.js`.   - Embedding in applications with popups for 3rd-party authentication windows.     Requires a selector to block. It will be embedded in this block.     Use `qmSetupOnPage` function after connecting `connect.js`.   - Embedding in mobile applications without popups for 3rd-party authentication.     Use `qmSetupOnMobile` function after connecting `connect.js`.     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
         * @summary Get embeddable connect javascript
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationJs(clientId?: string, options?: any) {
            return ConnectorsApiFp(configuration).getIntegrationJs(clientId, options)(fetch, basePath);
        },
        /**
         * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v3/connect/mobile?access_token=123
         * @summary Mobile connect page
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMobileConnectPage(userId?: number, options?: any) {
            return ConnectorsApiFp(configuration).getMobileConnectPage(userId, options)(fetch, basePath);
        },
        /**
         * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
         * @summary Sync with data source
         * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', userId?: number, options?: any) {
            return ConnectorsApiFp(configuration).updateConnector(connectorName, userId, options)(fetch, basePath);
        },
    };
};

/**
 * ConnectorsApi - interface
 * @export
 * @interface ConnectorsApi
 */
export interface ConnectorsApiInterface {
    /**
     * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
     * @summary Obtain a token from 3rd party data source
     * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApiInterface
     */
    connectConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', userId?: number, options?: any): Promise<GetConnectorsResponse>;

    /**
     * The disconnect method deletes any stored tokens or connection information from the connectors database.
     * @summary Delete stored connection info
     * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApiInterface
     */
    disconnectConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', options?: any): Promise<GetConnectorsResponse>;

    /**
     * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
     * @summary List of Connectors
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApiInterface
     */
    getConnectors(clientId?: string, options?: any): Promise<GetConnectorsResponse>;

    /**
     * Get embeddable connect javascript. Usage:   - Embedding in applications with popups for 3rd-party authentication windows.     Use `qmSetupInPopup` function after connecting `connect.js`.   - Embedding in applications with popups for 3rd-party authentication windows.     Requires a selector to block. It will be embedded in this block.     Use `qmSetupOnPage` function after connecting `connect.js`.   - Embedding in mobile applications without popups for 3rd-party authentication.     Use `qmSetupOnMobile` function after connecting `connect.js`.     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
     * @summary Get embeddable connect javascript
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApiInterface
     */
    getIntegrationJs(clientId?: string, options?: any): Promise<{}>;

    /**
     * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v3/connect/mobile?access_token=123
     * @summary Mobile connect page
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApiInterface
     */
    getMobileConnectPage(userId?: number, options?: any): Promise<{}>;

    /**
     * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
     * @summary Sync with data source
     * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApiInterface
     */
    updateConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', userId?: number, options?: any): Promise<GetConnectorsResponse>;

}

/**
 * ConnectorsApi - object-oriented interface
 * @export
 * @class ConnectorsApi
 * @extends {BaseAPI}
 */
export class ConnectorsApi extends BaseAPI implements ConnectorsApiInterface {
    /**
     * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
     * @summary Obtain a token from 3rd party data source
     * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public connectConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', userId?: number, options?: any) {
        return ConnectorsApiFp(this.configuration).connectConnector(connectorName, userId, options)(this.fetch, this.basePath);
    }

    /**
     * The disconnect method deletes any stored tokens or connection information from the connectors database.
     * @summary Delete stored connection info
     * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public disconnectConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', options?: any) {
        return ConnectorsApiFp(this.configuration).disconnectConnector(connectorName, options)(this.fetch, this.basePath);
    }

    /**
     * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
     * @summary List of Connectors
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getConnectors(clientId?: string, options?: any) {
        return ConnectorsApiFp(this.configuration).getConnectors(clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Get embeddable connect javascript. Usage:   - Embedding in applications with popups for 3rd-party authentication windows.     Use `qmSetupInPopup` function after connecting `connect.js`.   - Embedding in applications with popups for 3rd-party authentication windows.     Requires a selector to block. It will be embedded in this block.     Use `qmSetupOnPage` function after connecting `connect.js`.   - Embedding in mobile applications without popups for 3rd-party authentication.     Use `qmSetupOnMobile` function after connecting `connect.js`.     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
     * @summary Get embeddable connect javascript
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getIntegrationJs(clientId?: string, options?: any) {
        return ConnectorsApiFp(this.configuration).getIntegrationJs(clientId, options)(this.fetch, this.basePath);
    }

    /**
     * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v3/connect/mobile?access_token=123
     * @summary Mobile connect page
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public getMobileConnectPage(userId?: number, options?: any) {
        return ConnectorsApiFp(this.configuration).getMobileConnectPage(userId, options)(this.fetch, this.basePath);
    }

    /**
     * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
     * @summary Sync with data source
     * @param {'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail'} connectorName Lowercase system name of the source application or device. Get a list of available connectors from the /v3/connectors/list endpoint.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    public updateConnector(connectorName: 'facebook' | 'fitbit' | 'github' | 'googlecalendar' | 'googlefit' | 'medhelper' | 'mint' | 'moodpanda' | 'moodscope' | 'myfitnesspal' | 'mynetdiary' | 'netatmo' | 'rescuetime' | 'runkeeper' | 'slack' | 'sleepcloud' | 'slice' | 'up' | 'whatpulse' | 'withings' | 'worldweatheronline' | 'foursquare' | 'strava' | 'gmail', userId?: number, options?: any) {
        return ConnectorsApiFp(this.configuration).updateConnector(connectorName, userId, options)(this.fetch, this.basePath);
    }

}

/**
 * FeedApi - fetch parameter creator
 * @export
 */
export const FeedApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Tracking reminder notifications, messages, and study results
         * @summary Tracking reminder notifications, messages, and study results
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeed(sort?: string, userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/feed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post user actions on feed cards
         * @summary Post user interactions with feed
         * @param {Array<Card>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeed(body: Array<Card>, userId?: number, clientId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postFeed.');
            }
            const localVarPath = `/v3/feed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Card&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedApi - functional programming interface
 * @export
 */
export const FeedApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Tracking reminder notifications, messages, and study results
         * @summary Tracking reminder notifications, messages, and study results
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeed(sort?: string, userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FeedResponse> {
            const localVarFetchArgs = FeedApiFetchParamCreator(configuration).getFeed(sort, userId, createdAt, updatedAt, limit, offset, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post user actions on feed cards
         * @summary Post user interactions with feed
         * @param {Array<Card>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeed(body: Array<Card>, userId?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FeedResponse> {
            const localVarFetchArgs = FeedApiFetchParamCreator(configuration).postFeed(body, userId, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FeedApi - factory interface
 * @export
 */
export const FeedApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Tracking reminder notifications, messages, and study results
         * @summary Tracking reminder notifications, messages, and study results
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeed(sort?: string, userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, clientId?: string, options?: any) {
            return FeedApiFp(configuration).getFeed(sort, userId, createdAt, updatedAt, limit, offset, clientId, options)(fetch, basePath);
        },
        /**
         * Post user actions on feed cards
         * @summary Post user interactions with feed
         * @param {Array<Card>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeed(body: Array<Card>, userId?: number, clientId?: string, options?: any) {
            return FeedApiFp(configuration).postFeed(body, userId, clientId, options)(fetch, basePath);
        },
    };
};

/**
 * FeedApi - interface
 * @export
 * @interface FeedApi
 */
export interface FeedApiInterface {
    /**
     * Tracking reminder notifications, messages, and study results
     * @summary Tracking reminder notifications, messages, and study results
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApiInterface
     */
    getFeed(sort?: string, userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, clientId?: string, options?: any): Promise<FeedResponse>;

    /**
     * Post user actions on feed cards
     * @summary Post user interactions with feed
     * @param {Array<Card>} body Id of the tracking reminder notification to be snoozed
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApiInterface
     */
    postFeed(body: Array<Card>, userId?: number, clientId?: string, options?: any): Promise<FeedResponse>;

}

/**
 * FeedApi - object-oriented interface
 * @export
 * @class FeedApi
 * @extends {BaseAPI}
 */
export class FeedApi extends BaseAPI implements FeedApiInterface {
    /**
     * Tracking reminder notifications, messages, and study results
     * @summary Tracking reminder notifications, messages, and study results
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public getFeed(sort?: string, userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, clientId?: string, options?: any) {
        return FeedApiFp(this.configuration).getFeed(sort, userId, createdAt, updatedAt, limit, offset, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post user actions on feed cards
     * @summary Post user interactions with feed
     * @param {Array<Card>} body Id of the tracking reminder notification to be snoozed
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public postFeed(body: Array<Card>, userId?: number, clientId?: string, options?: any) {
        return FeedApiFp(this.configuration).postFeed(body, userId, clientId, options)(this.fetch, this.basePath);
    }

}

/**
 * FriendsApi - fetch parameter creator
 * @export
 */
export const FriendsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Friends
         * @summary Get Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/friends`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post Friends
         * @summary Post Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFriends(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/friends`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FriendsApi - functional programming interface
 * @export
 */
export const FriendsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Friends
         * @summary Get Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FriendsResponse>> {
            const localVarFetchArgs = FriendsApiFetchParamCreator(configuration).getFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post Friends
         * @summary Post Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFriends(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FriendsResponse>> {
            const localVarFetchArgs = FriendsApiFetchParamCreator(configuration).postFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FriendsApi - factory interface
 * @export
 */
export const FriendsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get Friends
         * @summary Get Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return FriendsApiFp(configuration).getFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post Friends
         * @summary Post Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFriends(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return FriendsApiFp(configuration).postFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};

/**
 * FriendsApi - interface
 * @export
 * @interface FriendsApi
 */
export interface FriendsApiInterface {
    /**
     * Get Friends
     * @summary Get Friends
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApiInterface
     */
    getFriends(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<FriendsResponse>>;

    /**
     * Post Friends
     * @summary Post Friends
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApiInterface
     */
    postFriends(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<FriendsResponse>>;

}

/**
 * FriendsApi - object-oriented interface
 * @export
 * @class FriendsApi
 * @extends {BaseAPI}
 */
export class FriendsApi extends BaseAPI implements FriendsApiInterface {
    /**
     * Get Friends
     * @summary Get Friends
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    public getFriends(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return FriendsApiFp(this.configuration).getFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post Friends
     * @summary Post Friends
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    public postFriends(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return FriendsApiFp(this.configuration).postFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

}

/**
 * GroupsApi - fetch parameter creator
 * @export
 */
export const GroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Groups
         * @summary Get Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get GroupsMembers
         * @summary Get GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsMembers(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/groupsMembers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post Groups
         * @summary Post Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post GroupsMembers
         * @summary Post GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsMembers(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/groupsMembers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Groups
         * @summary Get Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupsResponse>> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).getGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get GroupsMembers
         * @summary Get GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsMembers(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupsMembersResponse>> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).getGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post Groups
         * @summary Post Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupsResponse>> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).postGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post GroupsMembers
         * @summary Post GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsMembers(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupsMembersResponse>> {
            const localVarFetchArgs = GroupsApiFetchParamCreator(configuration).postGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get Groups
         * @summary Get Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return GroupsApiFp(configuration).getGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Get GroupsMembers
         * @summary Get GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsMembers(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return GroupsApiFp(configuration).getGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post Groups
         * @summary Post Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return GroupsApiFp(configuration).postGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post GroupsMembers
         * @summary Post GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsMembers(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return GroupsApiFp(configuration).postGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};

/**
 * GroupsApi - interface
 * @export
 * @interface GroupsApi
 */
export interface GroupsApiInterface {
    /**
     * Get Groups
     * @summary Get Groups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApiInterface
     */
    getGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<GroupsResponse>>;

    /**
     * Get GroupsMembers
     * @summary Get GroupsMembers
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApiInterface
     */
    getGroupsMembers(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<GroupsMembersResponse>>;

    /**
     * Post Groups
     * @summary Post Groups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApiInterface
     */
    postGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<GroupsResponse>>;

    /**
     * Post GroupsMembers
     * @summary Post GroupsMembers
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApiInterface
     */
    postGroupsMembers(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<GroupsMembersResponse>>;

}

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI implements GroupsApiInterface {
    /**
     * Get Groups
     * @summary Get Groups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return GroupsApiFp(this.configuration).getGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Get GroupsMembers
     * @summary Get GroupsMembers
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupsMembers(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return GroupsApiFp(this.configuration).getGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post Groups
     * @summary Post Groups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public postGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return GroupsApiFp(this.configuration).postGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post GroupsMembers
     * @summary Post GroupsMembers
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public postGroupsMembers(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return GroupsApiFp(this.configuration).postGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

}

/**
 * MeasurementsApi - fetch parameter creator
 * @export
 */
export const MeasurementsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a previously submitted measurement
         * @summary Delete a measurement
         * @param {MeasurementDelete} body The startTime and variableId of the measurement to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeasurement(body: MeasurementDelete, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteMeasurement.');
            }
            const localVarPath = `/v3/measurements/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MeasurementDelete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
         * @summary Get measurements for this user
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [connectorName] Ex: facebook
         * @param {string} [value] Value of measurement
         * @param {'% Recommended Daily Allowance' | '-4 to 4 Rating' | '0 to 1 Rating' | '0 to 5 Rating' | '1 to 10 Rating' | '1 to 5 Rating' | 'Applications' | 'Beats per Minute' | 'Calories' | 'Capsules' | 'Centimeters' | 'Count' | 'Degrees Celsius' | 'Degrees East' | 'Degrees Fahrenheit' | 'Degrees North' | 'Dollars' | 'Drops' | 'Event' | 'Feet' | 'Grams' | 'Hours' | 'Inches' | 'Index' | 'Kilocalories' | 'Kilograms' | 'Kilometers' | 'Liters' | 'Meters' | 'Micrograms' | 'Micrograms per decilitre' | 'Miles' | 'Milligrams' | 'Milliliters' | 'Millimeters' | 'Millimeters Merc' | 'Milliseconds' | 'Minutes' | 'Pascal' | 'Percent' | 'Pieces' | 'Pills' | 'Pounds' | 'Puffs' | 'Seconds' | 'Serving' | 'Sprays' | 'Tablets' | 'Torr' | 'Units' | 'Yes/No' | 'per Minute' | 'Doses' | 'Quarts' | 'Ounces' | 'International Units' | 'Meters per Second'} [unitName] Ex: Milligrams
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Measurement id
         * @param {number} [groupingWidth] The time (in seconds) over which measurements are grouped together
         * @param {string} [groupingTimezone] The time (in seconds) over which measurements are grouped together
         * @param {boolean} [doNotProcess] Ex: true
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [doNotConvert] Ex: 1
         * @param {boolean} [minMaxFilter] Ex: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeasurements(variableName?: string, sort?: string, limit?: number, offset?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', updatedAt?: string, userId?: number, sourceName?: string, connectorName?: string, value?: string, unitName?: '% Recommended Daily Allowance' | '-4 to 4 Rating' | '0 to 1 Rating' | '0 to 5 Rating' | '1 to 10 Rating' | '1 to 5 Rating' | 'Applications' | 'Beats per Minute' | 'Calories' | 'Capsules' | 'Centimeters' | 'Count' | 'Degrees Celsius' | 'Degrees East' | 'Degrees Fahrenheit' | 'Degrees North' | 'Dollars' | 'Drops' | 'Event' | 'Feet' | 'Grams' | 'Hours' | 'Inches' | 'Index' | 'Kilocalories' | 'Kilograms' | 'Kilometers' | 'Liters' | 'Meters' | 'Micrograms' | 'Micrograms per decilitre' | 'Miles' | 'Milligrams' | 'Milliliters' | 'Millimeters' | 'Millimeters Merc' | 'Milliseconds' | 'Minutes' | 'Pascal' | 'Percent' | 'Pieces' | 'Pills' | 'Pounds' | 'Puffs' | 'Seconds' | 'Serving' | 'Sprays' | 'Tablets' | 'Torr' | 'Units' | 'Yes/No' | 'per Minute' | 'Doses' | 'Quarts' | 'Ounces' | 'International Units' | 'Meters per Second', earliestMeasurementTime?: string, latestMeasurementTime?: string, createdAt?: string, id?: number, groupingWidth?: number, groupingTimezone?: string, doNotProcess?: boolean, clientId?: string, doNotConvert?: boolean, minMaxFilter?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v3/measurements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (variableName !== undefined) {
                localVarQueryParameter['variableName'] = variableName;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (variableCategoryName !== undefined) {
                localVarQueryParameter['variableCategoryName'] = variableCategoryName;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (sourceName !== undefined) {
                localVarQueryParameter['sourceName'] = sourceName;
            }

            if (connectorName !== undefined) {
                localVarQueryParameter['connectorName'] = connectorName;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (unitName !== undefined) {
                localVarQueryParameter['unitName'] = unitName;
            }

            if (earliestMeasurementTime !== undefined) {
                localVarQueryParameter['earliestMeasurementTime'] = earliestMeasurementTime;
            }

            if (latestMeasurementTime !== undefined) {
                localVarQueryParameter['latestMeasurementTime'] = latestMeasurementTime;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (groupingWidth !== undefined) {
                localVarQueryParameter['groupingWidth'] = groupingWidth;
            }

            if (groupingTimezone !== undefined) {
                localVarQueryParameter['groupingTimezone'] = groupingTimezone;
            }

            if (doNotProcess !== undefined) {
                localVarQueryParameter['doNotProcess'] = doNotProcess;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (doNotConvert !== undefined) {
                localVarQueryParameter['doNotConvert'] = doNotConvert;
            }

            if (minMaxFilter !== undefined) {
                localVarQueryParameter['minMaxFilter'] = minMaxFilter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.
         * @summary Get pairs of measurements for correlational analysis
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [effectUnitName] Name for the unit effect measurements to be returned in
         * @param {number} [userId] User&#39;s id
         * @param {string} [causeUnitName] Name for the unit cause measurements to be returned in
         * @param {string} [onsetDelay] The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
         * @param {string} [durationOfAction] The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPairs(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, effectUnitName?: string, userId?: number, causeUnitName?: string, onsetDelay?: string, durationOfAction?: string, earliestMeasurementTime?: string, latestMeasurementTime?: string, limit?: number, offset?: number, sort?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/pairs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }

            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }

            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }

            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }

            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }

            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }

            if (effectUnitName !== undefined) {
                localVarQueryParameter['effectUnitName'] = effectUnitName;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (causeUnitName !== undefined) {
                localVarQueryParameter['causeUnitName'] = causeUnitName;
            }

            if (onsetDelay !== undefined) {
                localVarQueryParameter['onsetDelay'] = onsetDelay;
            }

            if (durationOfAction !== undefined) {
                localVarQueryParameter['durationOfAction'] = durationOfAction;
            }

            if (earliestMeasurementTime !== undefined) {
                localVarQueryParameter['earliestMeasurementTime'] = earliestMeasurementTime;
            }

            if (latestMeasurementTime !== undefined) {
                localVarQueryParameter['latestMeasurementTime'] = latestMeasurementTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
         * @summary Post Request for Measurements CSV
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementExportRequest(userId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v2/measurements/exportRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
         * @summary Post a new set or update existing measurements to the database
         * @param {Array<MeasurementSet>} body An array of measurement sets containing measurement items you want to insert.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMeasurements(body: Array<MeasurementSet>, userId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postMeasurements.');
            }
            const localVarPath = `/v3/measurements/post`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;MeasurementSet&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a previously submitted measurement
         * @summary Update a measurement
         * @param {MeasurementUpdate} body The id as well as the new startTime, note, and/or value of the measurement to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeasurement(body: MeasurementUpdate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateMeasurement.');
            }
            const localVarPath = `/v3/measurements/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MeasurementUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeasurementsApi - functional programming interface
 * @export
 */
export const MeasurementsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a previously submitted measurement
         * @summary Delete a measurement
         * @param {MeasurementDelete} body The startTime and variableId of the measurement to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeasurement(body: MeasurementDelete, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommonResponse> {
            const localVarFetchArgs = MeasurementsApiFetchParamCreator(configuration).deleteMeasurement(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
         * @summary Get measurements for this user
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [connectorName] Ex: facebook
         * @param {string} [value] Value of measurement
         * @param {'% Recommended Daily Allowance' | '-4 to 4 Rating' | '0 to 1 Rating' | '0 to 5 Rating' | '1 to 10 Rating' | '1 to 5 Rating' | 'Applications' | 'Beats per Minute' | 'Calories' | 'Capsules' | 'Centimeters' | 'Count' | 'Degrees Celsius' | 'Degrees East' | 'Degrees Fahrenheit' | 'Degrees North' | 'Dollars' | 'Drops' | 'Event' | 'Feet' | 'Grams' | 'Hours' | 'Inches' | 'Index' | 'Kilocalories' | 'Kilograms' | 'Kilometers' | 'Liters' | 'Meters' | 'Micrograms' | 'Micrograms per decilitre' | 'Miles' | 'Milligrams' | 'Milliliters' | 'Millimeters' | 'Millimeters Merc' | 'Milliseconds' | 'Minutes' | 'Pascal' | 'Percent' | 'Pieces' | 'Pills' | 'Pounds' | 'Puffs' | 'Seconds' | 'Serving' | 'Sprays' | 'Tablets' | 'Torr' | 'Units' | 'Yes/No' | 'per Minute' | 'Doses' | 'Quarts' | 'Ounces' | 'International Units' | 'Meters per Second'} [unitName] Ex: Milligrams
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Measurement id
         * @param {number} [groupingWidth] The time (in seconds) over which measurements are grouped together
         * @param {string} [groupingTimezone] The time (in seconds) over which measurements are grouped together
         * @param {boolean} [doNotProcess] Ex: true
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [doNotConvert] Ex: 1
         * @param {boolean} [minMaxFilter] Ex: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeasurements(variableName?: string, sort?: string, limit?: number, offset?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', updatedAt?: string, userId?: number, sourceName?: string, connectorName?: string, value?: string, unitName?: '% Recommended Daily Allowance' | '-4 to 4 Rating' | '0 to 1 Rating' | '0 to 5 Rating' | '1 to 10 Rating' | '1 to 5 Rating' | 'Applications' | 'Beats per Minute' | 'Calories' | 'Capsules' | 'Centimeters' | 'Count' | 'Degrees Celsius' | 'Degrees East' | 'Degrees Fahrenheit' | 'Degrees North' | 'Dollars' | 'Drops' | 'Event' | 'Feet' | 'Grams' | 'Hours' | 'Inches' | 'Index' | 'Kilocalories' | 'Kilograms' | 'Kilometers' | 'Liters' | 'Meters' | 'Micrograms' | 'Micrograms per decilitre' | 'Miles' | 'Milligrams' | 'Milliliters' | 'Millimeters' | 'Millimeters Merc' | 'Milliseconds' | 'Minutes' | 'Pascal' | 'Percent' | 'Pieces' | 'Pills' | 'Pounds' | 'Puffs' | 'Seconds' | 'Serving' | 'Sprays' | 'Tablets' | 'Torr' | 'Units' | 'Yes/No' | 'per Minute' | 'Doses' | 'Quarts' | 'Ounces' | 'International Units' | 'Meters per Second', earliestMeasurementTime?: string, latestMeasurementTime?: string, createdAt?: string, id?: number, groupingWidth?: number, groupingTimezone?: string, doNotProcess?: boolean, clientId?: string, doNotConvert?: boolean, minMaxFilter?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Measurement>> {
            const localVarFetchArgs = MeasurementsApiFetchParamCreator(configuration).getMeasurements(variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.
         * @summary Get pairs of measurements for correlational analysis
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [effectUnitName] Name for the unit effect measurements to be returned in
         * @param {number} [userId] User&#39;s id
         * @param {string} [causeUnitName] Name for the unit cause measurements to be returned in
         * @param {string} [onsetDelay] The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
         * @param {string} [durationOfAction] The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPairs(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, effectUnitName?: string, userId?: number, causeUnitName?: string, onsetDelay?: string, durationOfAction?: string, earliestMeasurementTime?: string, latestMeasurementTime?: string, limit?: number, offset?: number, sort?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Pair>> {
            const localVarFetchArgs = MeasurementsApiFetchParamCreator(configuration).getPairs(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
         * @summary Post Request for Measurements CSV
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementExportRequest(userId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = MeasurementsApiFetchParamCreator(configuration).measurementExportRequest(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
         * @summary Post a new set or update existing measurements to the database
         * @param {Array<MeasurementSet>} body An array of measurement sets containing measurement items you want to insert.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMeasurements(body: Array<MeasurementSet>, userId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostMeasurementsResponse> {
            const localVarFetchArgs = MeasurementsApiFetchParamCreator(configuration).postMeasurements(body, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a previously submitted measurement
         * @summary Update a measurement
         * @param {MeasurementUpdate} body The id as well as the new startTime, note, and/or value of the measurement to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeasurement(body: MeasurementUpdate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommonResponse> {
            const localVarFetchArgs = MeasurementsApiFetchParamCreator(configuration).updateMeasurement(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MeasurementsApi - factory interface
 * @export
 */
export const MeasurementsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a previously submitted measurement
         * @summary Delete a measurement
         * @param {MeasurementDelete} body The startTime and variableId of the measurement to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeasurement(body: MeasurementDelete, options?: any) {
            return MeasurementsApiFp(configuration).deleteMeasurement(body, options)(fetch, basePath);
        },
        /**
         * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
         * @summary Get measurements for this user
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [connectorName] Ex: facebook
         * @param {string} [value] Value of measurement
         * @param {'% Recommended Daily Allowance' | '-4 to 4 Rating' | '0 to 1 Rating' | '0 to 5 Rating' | '1 to 10 Rating' | '1 to 5 Rating' | 'Applications' | 'Beats per Minute' | 'Calories' | 'Capsules' | 'Centimeters' | 'Count' | 'Degrees Celsius' | 'Degrees East' | 'Degrees Fahrenheit' | 'Degrees North' | 'Dollars' | 'Drops' | 'Event' | 'Feet' | 'Grams' | 'Hours' | 'Inches' | 'Index' | 'Kilocalories' | 'Kilograms' | 'Kilometers' | 'Liters' | 'Meters' | 'Micrograms' | 'Micrograms per decilitre' | 'Miles' | 'Milligrams' | 'Milliliters' | 'Millimeters' | 'Millimeters Merc' | 'Milliseconds' | 'Minutes' | 'Pascal' | 'Percent' | 'Pieces' | 'Pills' | 'Pounds' | 'Puffs' | 'Seconds' | 'Serving' | 'Sprays' | 'Tablets' | 'Torr' | 'Units' | 'Yes/No' | 'per Minute' | 'Doses' | 'Quarts' | 'Ounces' | 'International Units' | 'Meters per Second'} [unitName] Ex: Milligrams
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Measurement id
         * @param {number} [groupingWidth] The time (in seconds) over which measurements are grouped together
         * @param {string} [groupingTimezone] The time (in seconds) over which measurements are grouped together
         * @param {boolean} [doNotProcess] Ex: true
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [doNotConvert] Ex: 1
         * @param {boolean} [minMaxFilter] Ex: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeasurements(variableName?: string, sort?: string, limit?: number, offset?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', updatedAt?: string, userId?: number, sourceName?: string, connectorName?: string, value?: string, unitName?: '% Recommended Daily Allowance' | '-4 to 4 Rating' | '0 to 1 Rating' | '0 to 5 Rating' | '1 to 10 Rating' | '1 to 5 Rating' | 'Applications' | 'Beats per Minute' | 'Calories' | 'Capsules' | 'Centimeters' | 'Count' | 'Degrees Celsius' | 'Degrees East' | 'Degrees Fahrenheit' | 'Degrees North' | 'Dollars' | 'Drops' | 'Event' | 'Feet' | 'Grams' | 'Hours' | 'Inches' | 'Index' | 'Kilocalories' | 'Kilograms' | 'Kilometers' | 'Liters' | 'Meters' | 'Micrograms' | 'Micrograms per decilitre' | 'Miles' | 'Milligrams' | 'Milliliters' | 'Millimeters' | 'Millimeters Merc' | 'Milliseconds' | 'Minutes' | 'Pascal' | 'Percent' | 'Pieces' | 'Pills' | 'Pounds' | 'Puffs' | 'Seconds' | 'Serving' | 'Sprays' | 'Tablets' | 'Torr' | 'Units' | 'Yes/No' | 'per Minute' | 'Doses' | 'Quarts' | 'Ounces' | 'International Units' | 'Meters per Second', earliestMeasurementTime?: string, latestMeasurementTime?: string, createdAt?: string, id?: number, groupingWidth?: number, groupingTimezone?: string, doNotProcess?: boolean, clientId?: string, doNotConvert?: boolean, minMaxFilter?: boolean, options?: any) {
            return MeasurementsApiFp(configuration).getMeasurements(variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options)(fetch, basePath);
        },
        /**
         * Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.
         * @summary Get pairs of measurements for correlational analysis
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [effectUnitName] Name for the unit effect measurements to be returned in
         * @param {number} [userId] User&#39;s id
         * @param {string} [causeUnitName] Name for the unit cause measurements to be returned in
         * @param {string} [onsetDelay] The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
         * @param {string} [durationOfAction] The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPairs(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, effectUnitName?: string, userId?: number, causeUnitName?: string, onsetDelay?: string, durationOfAction?: string, earliestMeasurementTime?: string, latestMeasurementTime?: string, limit?: number, offset?: number, sort?: string, options?: any) {
            return MeasurementsApiFp(configuration).getPairs(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
         * @summary Post Request for Measurements CSV
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementExportRequest(userId?: number, options?: any) {
            return MeasurementsApiFp(configuration).measurementExportRequest(userId, options)(fetch, basePath);
        },
        /**
         * You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
         * @summary Post a new set or update existing measurements to the database
         * @param {Array<MeasurementSet>} body An array of measurement sets containing measurement items you want to insert.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMeasurements(body: Array<MeasurementSet>, userId?: number, options?: any) {
            return MeasurementsApiFp(configuration).postMeasurements(body, userId, options)(fetch, basePath);
        },
        /**
         * Update a previously submitted measurement
         * @summary Update a measurement
         * @param {MeasurementUpdate} body The id as well as the new startTime, note, and/or value of the measurement to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeasurement(body: MeasurementUpdate, options?: any) {
            return MeasurementsApiFp(configuration).updateMeasurement(body, options)(fetch, basePath);
        },
    };
};

/**
 * MeasurementsApi - interface
 * @export
 * @interface MeasurementsApi
 */
export interface MeasurementsApiInterface {
    /**
     * Delete a previously submitted measurement
     * @summary Delete a measurement
     * @param {MeasurementDelete} body The startTime and variableId of the measurement to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApiInterface
     */
    deleteMeasurement(body: MeasurementDelete, options?: any): Promise<CommonResponse>;

    /**
     * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
     * @summary Get measurements for this user
     * @param {string} [variableName] Name of the variable you want measurements for
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
     * @param {string} [connectorName] Ex: facebook
     * @param {string} [value] Value of measurement
     * @param {'% Recommended Daily Allowance' | '-4 to 4 Rating' | '0 to 1 Rating' | '0 to 5 Rating' | '1 to 10 Rating' | '1 to 5 Rating' | 'Applications' | 'Beats per Minute' | 'Calories' | 'Capsules' | 'Centimeters' | 'Count' | 'Degrees Celsius' | 'Degrees East' | 'Degrees Fahrenheit' | 'Degrees North' | 'Dollars' | 'Drops' | 'Event' | 'Feet' | 'Grams' | 'Hours' | 'Inches' | 'Index' | 'Kilocalories' | 'Kilograms' | 'Kilometers' | 'Liters' | 'Meters' | 'Micrograms' | 'Micrograms per decilitre' | 'Miles' | 'Milligrams' | 'Milliliters' | 'Millimeters' | 'Millimeters Merc' | 'Milliseconds' | 'Minutes' | 'Pascal' | 'Percent' | 'Pieces' | 'Pills' | 'Pounds' | 'Puffs' | 'Seconds' | 'Serving' | 'Sprays' | 'Tablets' | 'Torr' | 'Units' | 'Yes/No' | 'per Minute' | 'Doses' | 'Quarts' | 'Ounces' | 'International Units' | 'Meters per Second'} [unitName] Ex: Milligrams
     * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Measurement id
     * @param {number} [groupingWidth] The time (in seconds) over which measurements are grouped together
     * @param {string} [groupingTimezone] The time (in seconds) over which measurements are grouped together
     * @param {boolean} [doNotProcess] Ex: true
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [doNotConvert] Ex: 1
     * @param {boolean} [minMaxFilter] Ex: 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApiInterface
     */
    getMeasurements(variableName?: string, sort?: string, limit?: number, offset?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', updatedAt?: string, userId?: number, sourceName?: string, connectorName?: string, value?: string, unitName?: '% Recommended Daily Allowance' | '-4 to 4 Rating' | '0 to 1 Rating' | '0 to 5 Rating' | '1 to 10 Rating' | '1 to 5 Rating' | 'Applications' | 'Beats per Minute' | 'Calories' | 'Capsules' | 'Centimeters' | 'Count' | 'Degrees Celsius' | 'Degrees East' | 'Degrees Fahrenheit' | 'Degrees North' | 'Dollars' | 'Drops' | 'Event' | 'Feet' | 'Grams' | 'Hours' | 'Inches' | 'Index' | 'Kilocalories' | 'Kilograms' | 'Kilometers' | 'Liters' | 'Meters' | 'Micrograms' | 'Micrograms per decilitre' | 'Miles' | 'Milligrams' | 'Milliliters' | 'Millimeters' | 'Millimeters Merc' | 'Milliseconds' | 'Minutes' | 'Pascal' | 'Percent' | 'Pieces' | 'Pills' | 'Pounds' | 'Puffs' | 'Seconds' | 'Serving' | 'Sprays' | 'Tablets' | 'Torr' | 'Units' | 'Yes/No' | 'per Minute' | 'Doses' | 'Quarts' | 'Ounces' | 'International Units' | 'Meters per Second', earliestMeasurementTime?: string, latestMeasurementTime?: string, createdAt?: string, id?: number, groupingWidth?: number, groupingTimezone?: string, doNotProcess?: boolean, clientId?: string, doNotConvert?: boolean, minMaxFilter?: boolean, options?: any): Promise<Array<Measurement>>;

    /**
     * Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.
     * @summary Get pairs of measurements for correlational analysis
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [effectUnitName] Name for the unit effect measurements to be returned in
     * @param {number} [userId] User&#39;s id
     * @param {string} [causeUnitName] Name for the unit cause measurements to be returned in
     * @param {string} [onsetDelay] The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
     * @param {string} [durationOfAction] The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
     * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApiInterface
     */
    getPairs(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, effectUnitName?: string, userId?: number, causeUnitName?: string, onsetDelay?: string, durationOfAction?: string, earliestMeasurementTime?: string, latestMeasurementTime?: string, limit?: number, offset?: number, sort?: string, options?: any): Promise<Array<Pair>>;

    /**
     * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
     * @summary Post Request for Measurements CSV
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApiInterface
     */
    measurementExportRequest(userId?: number, options?: any): Promise<number>;

    /**
     * You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
     * @summary Post a new set or update existing measurements to the database
     * @param {Array<MeasurementSet>} body An array of measurement sets containing measurement items you want to insert.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApiInterface
     */
    postMeasurements(body: Array<MeasurementSet>, userId?: number, options?: any): Promise<PostMeasurementsResponse>;

    /**
     * Update a previously submitted measurement
     * @summary Update a measurement
     * @param {MeasurementUpdate} body The id as well as the new startTime, note, and/or value of the measurement to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApiInterface
     */
    updateMeasurement(body: MeasurementUpdate, options?: any): Promise<CommonResponse>;

}

/**
 * MeasurementsApi - object-oriented interface
 * @export
 * @class MeasurementsApi
 * @extends {BaseAPI}
 */
export class MeasurementsApi extends BaseAPI implements MeasurementsApiInterface {
    /**
     * Delete a previously submitted measurement
     * @summary Delete a measurement
     * @param {MeasurementDelete} body The startTime and variableId of the measurement to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    public deleteMeasurement(body: MeasurementDelete, options?: any) {
        return MeasurementsApiFp(this.configuration).deleteMeasurement(body, options)(this.fetch, this.basePath);
    }

    /**
     * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
     * @summary Get measurements for this user
     * @param {string} [variableName] Name of the variable you want measurements for
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
     * @param {string} [connectorName] Ex: facebook
     * @param {string} [value] Value of measurement
     * @param {'% Recommended Daily Allowance' | '-4 to 4 Rating' | '0 to 1 Rating' | '0 to 5 Rating' | '1 to 10 Rating' | '1 to 5 Rating' | 'Applications' | 'Beats per Minute' | 'Calories' | 'Capsules' | 'Centimeters' | 'Count' | 'Degrees Celsius' | 'Degrees East' | 'Degrees Fahrenheit' | 'Degrees North' | 'Dollars' | 'Drops' | 'Event' | 'Feet' | 'Grams' | 'Hours' | 'Inches' | 'Index' | 'Kilocalories' | 'Kilograms' | 'Kilometers' | 'Liters' | 'Meters' | 'Micrograms' | 'Micrograms per decilitre' | 'Miles' | 'Milligrams' | 'Milliliters' | 'Millimeters' | 'Millimeters Merc' | 'Milliseconds' | 'Minutes' | 'Pascal' | 'Percent' | 'Pieces' | 'Pills' | 'Pounds' | 'Puffs' | 'Seconds' | 'Serving' | 'Sprays' | 'Tablets' | 'Torr' | 'Units' | 'Yes/No' | 'per Minute' | 'Doses' | 'Quarts' | 'Ounces' | 'International Units' | 'Meters per Second'} [unitName] Ex: Milligrams
     * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Measurement id
     * @param {number} [groupingWidth] The time (in seconds) over which measurements are grouped together
     * @param {string} [groupingTimezone] The time (in seconds) over which measurements are grouped together
     * @param {boolean} [doNotProcess] Ex: true
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [doNotConvert] Ex: 1
     * @param {boolean} [minMaxFilter] Ex: 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    public getMeasurements(variableName?: string, sort?: string, limit?: number, offset?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', updatedAt?: string, userId?: number, sourceName?: string, connectorName?: string, value?: string, unitName?: '% Recommended Daily Allowance' | '-4 to 4 Rating' | '0 to 1 Rating' | '0 to 5 Rating' | '1 to 10 Rating' | '1 to 5 Rating' | 'Applications' | 'Beats per Minute' | 'Calories' | 'Capsules' | 'Centimeters' | 'Count' | 'Degrees Celsius' | 'Degrees East' | 'Degrees Fahrenheit' | 'Degrees North' | 'Dollars' | 'Drops' | 'Event' | 'Feet' | 'Grams' | 'Hours' | 'Inches' | 'Index' | 'Kilocalories' | 'Kilograms' | 'Kilometers' | 'Liters' | 'Meters' | 'Micrograms' | 'Micrograms per decilitre' | 'Miles' | 'Milligrams' | 'Milliliters' | 'Millimeters' | 'Millimeters Merc' | 'Milliseconds' | 'Minutes' | 'Pascal' | 'Percent' | 'Pieces' | 'Pills' | 'Pounds' | 'Puffs' | 'Seconds' | 'Serving' | 'Sprays' | 'Tablets' | 'Torr' | 'Units' | 'Yes/No' | 'per Minute' | 'Doses' | 'Quarts' | 'Ounces' | 'International Units' | 'Meters per Second', earliestMeasurementTime?: string, latestMeasurementTime?: string, createdAt?: string, id?: number, groupingWidth?: number, groupingTimezone?: string, doNotProcess?: boolean, clientId?: string, doNotConvert?: boolean, minMaxFilter?: boolean, options?: any) {
        return MeasurementsApiFp(this.configuration).getMeasurements(variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options)(this.fetch, this.basePath);
    }

    /**
     * Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.
     * @summary Get pairs of measurements for correlational analysis
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [effectUnitName] Name for the unit effect measurements to be returned in
     * @param {number} [userId] User&#39;s id
     * @param {string} [causeUnitName] Name for the unit cause measurements to be returned in
     * @param {string} [onsetDelay] The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
     * @param {string} [durationOfAction] The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
     * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    public getPairs(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, effectUnitName?: string, userId?: number, causeUnitName?: string, onsetDelay?: string, durationOfAction?: string, earliestMeasurementTime?: string, latestMeasurementTime?: string, limit?: number, offset?: number, sort?: string, options?: any) {
        return MeasurementsApiFp(this.configuration).getPairs(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
     * @summary Post Request for Measurements CSV
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    public measurementExportRequest(userId?: number, options?: any) {
        return MeasurementsApiFp(this.configuration).measurementExportRequest(userId, options)(this.fetch, this.basePath);
    }

    /**
     * You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
     * @summary Post a new set or update existing measurements to the database
     * @param {Array<MeasurementSet>} body An array of measurement sets containing measurement items you want to insert.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    public postMeasurements(body: Array<MeasurementSet>, userId?: number, options?: any) {
        return MeasurementsApiFp(this.configuration).postMeasurements(body, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Update a previously submitted measurement
     * @summary Update a measurement
     * @param {MeasurementUpdate} body The id as well as the new startTime, note, and/or value of the measurement to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    public updateMeasurement(body: MeasurementUpdate, options?: any) {
        return MeasurementsApiFp(this.configuration).updateMeasurement(body, options)(this.fetch, this.basePath);
    }

}

/**
 * MessagesApi - fetch parameter creator
 * @export
 */
export const MessagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get MessagesMessages
         * @summary Get MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesMessages(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/messagesMessages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MessagesNotices
         * @summary Get MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesNotices(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/messagesNotices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MessagesRecipients
         * @summary Get MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesRecipients(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/messagesRecipients`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post MessagesMessages
         * @summary Post MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesMessages(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/messagesMessages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post MessagesNotices
         * @summary Post MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesNotices(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/messagesNotices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post MessagesRecipients
         * @summary Post MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesRecipients(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/messagesRecipients`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get MessagesMessages
         * @summary Get MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesMessages(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MessagesMessagesResponse>> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).getMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get MessagesNotices
         * @summary Get MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesNotices(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MessagesNoticesResponse>> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).getMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get MessagesRecipients
         * @summary Get MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesRecipients(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MessagesRecipientsResponse>> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).getMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post MessagesMessages
         * @summary Post MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesMessages(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MessagesMessagesResponse>> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).postMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post MessagesNotices
         * @summary Post MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesNotices(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MessagesNoticesResponse>> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).postMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post MessagesRecipients
         * @summary Post MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesRecipients(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MessagesRecipientsResponse>> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).postMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get MessagesMessages
         * @summary Get MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesMessages(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return MessagesApiFp(configuration).getMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Get MessagesNotices
         * @summary Get MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesNotices(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return MessagesApiFp(configuration).getMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Get MessagesRecipients
         * @summary Get MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesRecipients(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return MessagesApiFp(configuration).getMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post MessagesMessages
         * @summary Post MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesMessages(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return MessagesApiFp(configuration).postMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post MessagesNotices
         * @summary Post MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesNotices(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return MessagesApiFp(configuration).postMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post MessagesRecipients
         * @summary Post MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesRecipients(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return MessagesApiFp(configuration).postMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};

/**
 * MessagesApi - interface
 * @export
 * @interface MessagesApi
 */
export interface MessagesApiInterface {
    /**
     * Get MessagesMessages
     * @summary Get MessagesMessages
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    getMessagesMessages(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<MessagesMessagesResponse>>;

    /**
     * Get MessagesNotices
     * @summary Get MessagesNotices
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    getMessagesNotices(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<MessagesNoticesResponse>>;

    /**
     * Get MessagesRecipients
     * @summary Get MessagesRecipients
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    getMessagesRecipients(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<MessagesRecipientsResponse>>;

    /**
     * Post MessagesMessages
     * @summary Post MessagesMessages
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    postMessagesMessages(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<MessagesMessagesResponse>>;

    /**
     * Post MessagesNotices
     * @summary Post MessagesNotices
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    postMessagesNotices(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<MessagesNoticesResponse>>;

    /**
     * Post MessagesRecipients
     * @summary Post MessagesRecipients
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiInterface
     */
    postMessagesRecipients(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<MessagesRecipientsResponse>>;

}

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI implements MessagesApiInterface {
    /**
     * Get MessagesMessages
     * @summary Get MessagesMessages
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessagesMessages(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return MessagesApiFp(this.configuration).getMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Get MessagesNotices
     * @summary Get MessagesNotices
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessagesNotices(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return MessagesApiFp(this.configuration).getMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Get MessagesRecipients
     * @summary Get MessagesRecipients
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessagesRecipients(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return MessagesApiFp(this.configuration).getMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post MessagesMessages
     * @summary Post MessagesMessages
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public postMessagesMessages(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return MessagesApiFp(this.configuration).postMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post MessagesNotices
     * @summary Post MessagesNotices
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public postMessagesNotices(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return MessagesApiFp(this.configuration).postMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post MessagesRecipients
     * @summary Post MessagesRecipients
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public postMessagesRecipients(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return MessagesApiFp(this.configuration).postMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

}

/**
 * NotificationsApi - fetch parameter creator
 * @export
 */
export const NotificationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get NotificationPreferences
         * @summary Get NotificationPreferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationPreferences(options: any = {}): FetchArgs {
            const localVarPath = `/v3/notificationPreferences`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Notifications
         * @summary Get Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/notifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post user token for Android, iOS, or web push notifications
         * @summary Post DeviceTokens
         * @param {DeviceToken} body The platform and token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeviceToken(body: DeviceToken, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postDeviceToken.');
            }
            const localVarPath = `/v3/deviceTokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post Notifications
         * @summary Post Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotifications(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/notifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get NotificationPreferences
         * @summary Get NotificationPreferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationPreferences(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NotificationsApiFetchParamCreator(configuration).getNotificationPreferences(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Notifications
         * @summary Get Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NotificationsResponse>> {
            const localVarFetchArgs = NotificationsApiFetchParamCreator(configuration).getNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post user token for Android, iOS, or web push notifications
         * @summary Post DeviceTokens
         * @param {DeviceToken} body The platform and token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeviceToken(body: DeviceToken, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NotificationsApiFetchParamCreator(configuration).postDeviceToken(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post Notifications
         * @summary Post Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotifications(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NotificationsResponse>> {
            const localVarFetchArgs = NotificationsApiFetchParamCreator(configuration).postNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get NotificationPreferences
         * @summary Get NotificationPreferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationPreferences(options?: any) {
            return NotificationsApiFp(configuration).getNotificationPreferences(options)(fetch, basePath);
        },
        /**
         * Get Notifications
         * @summary Get Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return NotificationsApiFp(configuration).getNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post user token for Android, iOS, or web push notifications
         * @summary Post DeviceTokens
         * @param {DeviceToken} body The platform and token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeviceToken(body: DeviceToken, options?: any) {
            return NotificationsApiFp(configuration).postDeviceToken(body, options)(fetch, basePath);
        },
        /**
         * Post Notifications
         * @summary Post Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotifications(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return NotificationsApiFp(configuration).postNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};

/**
 * NotificationsApi - interface
 * @export
 * @interface NotificationsApi
 */
export interface NotificationsApiInterface {
    /**
     * Get NotificationPreferences
     * @summary Get NotificationPreferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    getNotificationPreferences(options?: any): Promise<{}>;

    /**
     * Get Notifications
     * @summary Get Notifications
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    getNotifications(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<NotificationsResponse>>;

    /**
     * Post user token for Android, iOS, or web push notifications
     * @summary Post DeviceTokens
     * @param {DeviceToken} body The platform and token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    postDeviceToken(body: DeviceToken, options?: any): Promise<{}>;

    /**
     * Post Notifications
     * @summary Post Notifications
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApiInterface
     */
    postNotifications(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<NotificationsResponse>>;

}

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI implements NotificationsApiInterface {
    /**
     * Get NotificationPreferences
     * @summary Get NotificationPreferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotificationPreferences(options?: any) {
        return NotificationsApiFp(this.configuration).getNotificationPreferences(options)(this.fetch, this.basePath);
    }

    /**
     * Get Notifications
     * @summary Get Notifications
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotifications(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return NotificationsApiFp(this.configuration).getNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post user token for Android, iOS, or web push notifications
     * @summary Post DeviceTokens
     * @param {DeviceToken} body The platform and token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public postDeviceToken(body: DeviceToken, options?: any) {
        return NotificationsApiFp(this.configuration).postDeviceToken(body, options)(this.fetch, this.basePath);
    }

    /**
     * Post Notifications
     * @summary Post Notifications
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public postNotifications(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return NotificationsApiFp(this.configuration).postNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

}

/**
 * RemindersApi - fetch parameter creator
 * @export
 */
export const RemindersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
         * @summary Delete Tracking Reminder
         * @param {TrackingReminderDelete} body Id of reminder to be deleted
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackingReminder(body: TrackingReminderDelete, userId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteTrackingReminder.');
            }
            const localVarPath = `/v3/trackingReminders/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TrackingReminderDelete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specific tracking reminder notification instances that still need to be tracked.
         * @summary Get specific tracking reminder notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [reminderTime] Ex: (lt)2017-07-31 21:43:26
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [onlyPast] Ex: 1
         * @param {boolean} [includeDeleted] Include deleted variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminderNotifications(sort?: string, userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', reminderTime?: string, clientId?: string, onlyPast?: boolean, includeDeleted?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v3/trackingReminderNotifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (variableCategoryName !== undefined) {
                localVarQueryParameter['variableCategoryName'] = variableCategoryName;
            }

            if (reminderTime !== undefined) {
                localVarQueryParameter['reminderTime'] = reminderTime;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (onlyPast !== undefined) {
                localVarQueryParameter['onlyPast'] = onlyPast;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['includeDeleted'] = includeDeleted;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can be reminded to track certain variables at a specified frequency with a default value.
         * @summary Get repeating tracking reminder settings
         * @param {number} [userId] User&#39;s id
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminders(userId?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/trackingReminders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (variableCategoryName !== undefined) {
                localVarQueryParameter['variableCategoryName'] = variableCategoryName;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Snooze, skip, or track a tracking reminder notification
         * @summary Snooze, skip, or track a tracking reminder notification
         * @param {Array<TrackingReminderNotificationPost>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminderNotifications(body: Array<TrackingReminderNotificationPost>, userId?: number, clientId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postTrackingReminderNotifications.');
            }
            const localVarPath = `/v3/trackingReminderNotifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;TrackingReminderNotificationPost&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is to enable users to create reminders to track a variable with a default value at a specified frequency
         * @summary Store a Tracking Reminder
         * @param {Array<TrackingReminder>} body TrackingReminder that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminders(body: Array<TrackingReminder>, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postTrackingReminders.');
            }
            const localVarPath = `/v3/trackingReminders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;TrackingReminder&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemindersApi - functional programming interface
 * @export
 */
export const RemindersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
         * @summary Delete Tracking Reminder
         * @param {TrackingReminderDelete} body Id of reminder to be deleted
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackingReminder(body: TrackingReminderDelete, userId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommonResponse> {
            const localVarFetchArgs = RemindersApiFetchParamCreator(configuration).deleteTrackingReminder(body, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Specific tracking reminder notification instances that still need to be tracked.
         * @summary Get specific tracking reminder notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [reminderTime] Ex: (lt)2017-07-31 21:43:26
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [onlyPast] Ex: 1
         * @param {boolean} [includeDeleted] Include deleted variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminderNotifications(sort?: string, userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', reminderTime?: string, clientId?: string, onlyPast?: boolean, includeDeleted?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetTrackingReminderNotificationsResponse> {
            const localVarFetchArgs = RemindersApiFetchParamCreator(configuration).getTrackingReminderNotifications(sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Users can be reminded to track certain variables at a specified frequency with a default value.
         * @summary Get repeating tracking reminder settings
         * @param {number} [userId] User&#39;s id
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminders(userId?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TrackingReminder>> {
            const localVarFetchArgs = RemindersApiFetchParamCreator(configuration).getTrackingReminders(userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Snooze, skip, or track a tracking reminder notification
         * @summary Snooze, skip, or track a tracking reminder notification
         * @param {Array<TrackingReminderNotificationPost>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminderNotifications(body: Array<TrackingReminderNotificationPost>, userId?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommonResponse> {
            const localVarFetchArgs = RemindersApiFetchParamCreator(configuration).postTrackingReminderNotifications(body, userId, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This is to enable users to create reminders to track a variable with a default value at a specified frequency
         * @summary Store a Tracking Reminder
         * @param {Array<TrackingReminder>} body TrackingReminder that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminders(body: Array<TrackingReminder>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostTrackingRemindersResponse> {
            const localVarFetchArgs = RemindersApiFetchParamCreator(configuration).postTrackingReminders(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RemindersApi - factory interface
 * @export
 */
export const RemindersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
         * @summary Delete Tracking Reminder
         * @param {TrackingReminderDelete} body Id of reminder to be deleted
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackingReminder(body: TrackingReminderDelete, userId?: number, options?: any) {
            return RemindersApiFp(configuration).deleteTrackingReminder(body, userId, options)(fetch, basePath);
        },
        /**
         * Specific tracking reminder notification instances that still need to be tracked.
         * @summary Get specific tracking reminder notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [reminderTime] Ex: (lt)2017-07-31 21:43:26
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [onlyPast] Ex: 1
         * @param {boolean} [includeDeleted] Include deleted variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminderNotifications(sort?: string, userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', reminderTime?: string, clientId?: string, onlyPast?: boolean, includeDeleted?: boolean, options?: any) {
            return RemindersApiFp(configuration).getTrackingReminderNotifications(sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options)(fetch, basePath);
        },
        /**
         * Users can be reminded to track certain variables at a specified frequency with a default value.
         * @summary Get repeating tracking reminder settings
         * @param {number} [userId] User&#39;s id
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminders(userId?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, options?: any) {
            return RemindersApiFp(configuration).getTrackingReminders(userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options)(fetch, basePath);
        },
        /**
         * Snooze, skip, or track a tracking reminder notification
         * @summary Snooze, skip, or track a tracking reminder notification
         * @param {Array<TrackingReminderNotificationPost>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminderNotifications(body: Array<TrackingReminderNotificationPost>, userId?: number, clientId?: string, options?: any) {
            return RemindersApiFp(configuration).postTrackingReminderNotifications(body, userId, clientId, options)(fetch, basePath);
        },
        /**
         * This is to enable users to create reminders to track a variable with a default value at a specified frequency
         * @summary Store a Tracking Reminder
         * @param {Array<TrackingReminder>} body TrackingReminder that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminders(body: Array<TrackingReminder>, options?: any) {
            return RemindersApiFp(configuration).postTrackingReminders(body, options)(fetch, basePath);
        },
    };
};

/**
 * RemindersApi - interface
 * @export
 * @interface RemindersApi
 */
export interface RemindersApiInterface {
    /**
     * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
     * @summary Delete Tracking Reminder
     * @param {TrackingReminderDelete} body Id of reminder to be deleted
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApiInterface
     */
    deleteTrackingReminder(body: TrackingReminderDelete, userId?: number, options?: any): Promise<CommonResponse>;

    /**
     * Specific tracking reminder notification instances that still need to be tracked.
     * @summary Get specific tracking reminder notifications
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
     * @param {string} [reminderTime] Ex: (lt)2017-07-31 21:43:26
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [onlyPast] Ex: 1
     * @param {boolean} [includeDeleted] Include deleted variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApiInterface
     */
    getTrackingReminderNotifications(sort?: string, userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', reminderTime?: string, clientId?: string, onlyPast?: boolean, includeDeleted?: boolean, options?: any): Promise<GetTrackingReminderNotificationsResponse>;

    /**
     * Users can be reminded to track certain variables at a specified frequency with a default value.
     * @summary Get repeating tracking reminder settings
     * @param {number} [userId] User&#39;s id
     * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApiInterface
     */
    getTrackingReminders(userId?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, options?: any): Promise<Array<TrackingReminder>>;

    /**
     * Snooze, skip, or track a tracking reminder notification
     * @summary Snooze, skip, or track a tracking reminder notification
     * @param {Array<TrackingReminderNotificationPost>} body Id of the tracking reminder notification to be snoozed
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApiInterface
     */
    postTrackingReminderNotifications(body: Array<TrackingReminderNotificationPost>, userId?: number, clientId?: string, options?: any): Promise<CommonResponse>;

    /**
     * This is to enable users to create reminders to track a variable with a default value at a specified frequency
     * @summary Store a Tracking Reminder
     * @param {Array<TrackingReminder>} body TrackingReminder that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApiInterface
     */
    postTrackingReminders(body: Array<TrackingReminder>, options?: any): Promise<PostTrackingRemindersResponse>;

}

/**
 * RemindersApi - object-oriented interface
 * @export
 * @class RemindersApi
 * @extends {BaseAPI}
 */
export class RemindersApi extends BaseAPI implements RemindersApiInterface {
    /**
     * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
     * @summary Delete Tracking Reminder
     * @param {TrackingReminderDelete} body Id of reminder to be deleted
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApi
     */
    public deleteTrackingReminder(body: TrackingReminderDelete, userId?: number, options?: any) {
        return RemindersApiFp(this.configuration).deleteTrackingReminder(body, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Specific tracking reminder notification instances that still need to be tracked.
     * @summary Get specific tracking reminder notifications
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
     * @param {string} [reminderTime] Ex: (lt)2017-07-31 21:43:26
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [onlyPast] Ex: 1
     * @param {boolean} [includeDeleted] Include deleted variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApi
     */
    public getTrackingReminderNotifications(sort?: string, userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', reminderTime?: string, clientId?: string, onlyPast?: boolean, includeDeleted?: boolean, options?: any) {
        return RemindersApiFp(this.configuration).getTrackingReminderNotifications(sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options)(this.fetch, this.basePath);
    }

    /**
     * Users can be reminded to track certain variables at a specified frequency with a default value.
     * @summary Get repeating tracking reminder settings
     * @param {number} [userId] User&#39;s id
     * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApi
     */
    public getTrackingReminders(userId?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, options?: any) {
        return RemindersApiFp(this.configuration).getTrackingReminders(userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options)(this.fetch, this.basePath);
    }

    /**
     * Snooze, skip, or track a tracking reminder notification
     * @summary Snooze, skip, or track a tracking reminder notification
     * @param {Array<TrackingReminderNotificationPost>} body Id of the tracking reminder notification to be snoozed
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApi
     */
    public postTrackingReminderNotifications(body: Array<TrackingReminderNotificationPost>, userId?: number, clientId?: string, options?: any) {
        return RemindersApiFp(this.configuration).postTrackingReminderNotifications(body, userId, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * This is to enable users to create reminders to track a variable with a default value at a specified frequency
     * @summary Store a Tracking Reminder
     * @param {Array<TrackingReminder>} body TrackingReminder that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApi
     */
    public postTrackingReminders(body: Array<TrackingReminder>, options?: any) {
        return RemindersApiFp(this.configuration).postTrackingReminders(body, options)(this.fetch, this.basePath);
    }

}

/**
 * SharesApi - fetch parameter creator
 * @export
 */
export const SharesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove access to user data for a given client_id associated with a given individual, app, or study
         * @summary Delete share
         * @param {string} clientIdToRevoke Client id of the individual, study, or app that the user wishes to no longer have access to their data
         * @param {string} [reason] Ex: I hate you!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShare(clientIdToRevoke: string, reason?: string, options: any = {}): FetchArgs {
            // verify required parameter 'clientIdToRevoke' is not null or undefined
            if (clientIdToRevoke === null || clientIdToRevoke === undefined) {
                throw new RequiredError('clientIdToRevoke','Required parameter clientIdToRevoke was null or undefined when calling deleteShare.');
            }
            const localVarPath = `/v3/shares/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (clientIdToRevoke !== undefined) {
                localVarQueryParameter['clientIdToRevoke'] = clientIdToRevoke;
            }

            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a list of individuals, apps, or studies with access to your measurements.
         * @summary Get Authorized Apps, Studies, and Individuals
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShares(userId?: number, createdAt?: string, updatedAt?: string, clientId?: string, appVersion?: string, log?: string, pwd?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/shares`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }

            if (log !== undefined) {
                localVarQueryParameter['log'] = log;
            }

            if (pwd !== undefined) {
                localVarQueryParameter['pwd'] = pwd;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite someone to view your measurements
         * @summary Delete share
         * @param {ShareInvitationBody} body Details about person to share with
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteShare(body: ShareInvitationBody, clientId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling inviteShare.');
            }
            const localVarPath = `/v3/shares/invite`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShareInvitationBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SharesApi - functional programming interface
 * @export
 */
export const SharesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove access to user data for a given client_id associated with a given individual, app, or study
         * @summary Delete share
         * @param {string} clientIdToRevoke Client id of the individual, study, or app that the user wishes to no longer have access to their data
         * @param {string} [reason] Ex: I hate you!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShare(clientIdToRevoke: string, reason?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = SharesApiFetchParamCreator(configuration).deleteShare(clientIdToRevoke, reason, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This is a list of individuals, apps, or studies with access to your measurements.
         * @summary Get Authorized Apps, Studies, and Individuals
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShares(userId?: number, createdAt?: string, updatedAt?: string, clientId?: string, appVersion?: string, log?: string, pwd?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSharesResponse> {
            const localVarFetchArgs = SharesApiFetchParamCreator(configuration).getShares(userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Invite someone to view your measurements
         * @summary Delete share
         * @param {ShareInvitationBody} body Details about person to share with
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteShare(body: ShareInvitationBody, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = SharesApiFetchParamCreator(configuration).inviteShare(body, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SharesApi - factory interface
 * @export
 */
export const SharesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remove access to user data for a given client_id associated with a given individual, app, or study
         * @summary Delete share
         * @param {string} clientIdToRevoke Client id of the individual, study, or app that the user wishes to no longer have access to their data
         * @param {string} [reason] Ex: I hate you!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShare(clientIdToRevoke: string, reason?: string, options?: any) {
            return SharesApiFp(configuration).deleteShare(clientIdToRevoke, reason, options)(fetch, basePath);
        },
        /**
         * This is a list of individuals, apps, or studies with access to your measurements.
         * @summary Get Authorized Apps, Studies, and Individuals
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShares(userId?: number, createdAt?: string, updatedAt?: string, clientId?: string, appVersion?: string, log?: string, pwd?: string, options?: any) {
            return SharesApiFp(configuration).getShares(userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options)(fetch, basePath);
        },
        /**
         * Invite someone to view your measurements
         * @summary Delete share
         * @param {ShareInvitationBody} body Details about person to share with
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteShare(body: ShareInvitationBody, clientId?: string, options?: any) {
            return SharesApiFp(configuration).inviteShare(body, clientId, options)(fetch, basePath);
        },
    };
};

/**
 * SharesApi - interface
 * @export
 * @interface SharesApi
 */
export interface SharesApiInterface {
    /**
     * Remove access to user data for a given client_id associated with a given individual, app, or study
     * @summary Delete share
     * @param {string} clientIdToRevoke Client id of the individual, study, or app that the user wishes to no longer have access to their data
     * @param {string} [reason] Ex: I hate you!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApiInterface
     */
    deleteShare(clientIdToRevoke: string, reason?: string, options?: any): Promise<User>;

    /**
     * This is a list of individuals, apps, or studies with access to your measurements.
     * @summary Get Authorized Apps, Studies, and Individuals
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {string} [log] Username or email
     * @param {string} [pwd] User password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApiInterface
     */
    getShares(userId?: number, createdAt?: string, updatedAt?: string, clientId?: string, appVersion?: string, log?: string, pwd?: string, options?: any): Promise<GetSharesResponse>;

    /**
     * Invite someone to view your measurements
     * @summary Delete share
     * @param {ShareInvitationBody} body Details about person to share with
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApiInterface
     */
    inviteShare(body: ShareInvitationBody, clientId?: string, options?: any): Promise<User>;

}

/**
 * SharesApi - object-oriented interface
 * @export
 * @class SharesApi
 * @extends {BaseAPI}
 */
export class SharesApi extends BaseAPI implements SharesApiInterface {
    /**
     * Remove access to user data for a given client_id associated with a given individual, app, or study
     * @summary Delete share
     * @param {string} clientIdToRevoke Client id of the individual, study, or app that the user wishes to no longer have access to their data
     * @param {string} [reason] Ex: I hate you!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApi
     */
    public deleteShare(clientIdToRevoke: string, reason?: string, options?: any) {
        return SharesApiFp(this.configuration).deleteShare(clientIdToRevoke, reason, options)(this.fetch, this.basePath);
    }

    /**
     * This is a list of individuals, apps, or studies with access to your measurements.
     * @summary Get Authorized Apps, Studies, and Individuals
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {string} [log] Username or email
     * @param {string} [pwd] User password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApi
     */
    public getShares(userId?: number, createdAt?: string, updatedAt?: string, clientId?: string, appVersion?: string, log?: string, pwd?: string, options?: any) {
        return SharesApiFp(this.configuration).getShares(userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options)(this.fetch, this.basePath);
    }

    /**
     * Invite someone to view your measurements
     * @summary Delete share
     * @param {ShareInvitationBody} body Details about person to share with
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApi
     */
    public inviteShare(body: ShareInvitationBody, clientId?: string, options?: any) {
        return SharesApiFp(this.configuration).inviteShare(body, clientId, options)(this.fetch, this.basePath);
    }

}

/**
 * StudiesApi - fetch parameter creator
 * @export
 */
export const StudiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
         * @summary Create a Study
         * @param {StudyCreationBody} body Details about the study you want to create
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudy(body: StudyCreationBody, clientId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createStudy.');
            }
            const localVarPath = `/v3/study/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StudyCreationBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete previously posted vote
         * @summary Delete vote
         * @param {VoteDelete} body The cause and effect variable names for the predictor vote to be deleted.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVote(body: VoteDelete, userId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteVote.');
            }
            const localVarPath = `/v3/votes/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VoteDelete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
         * @summary These are open studies that anyone can join
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/studies/open`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }

            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }

            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }

            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }

            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }

            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (includeCharts !== undefined) {
                localVarQueryParameter['includeCharts'] = includeCharts;
            }

            if (recalculate !== undefined) {
                localVarQueryParameter['recalculate'] = recalculate;
            }

            if (studyId !== undefined) {
                localVarQueryParameter['studyId'] = studyId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
         * @summary Get Personal or Population Studies
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {number} [principalInvestigatorUserId] These are studies created by a specific principal investigator
         * @param {boolean} [open] These are studies that anyone can join
         * @param {boolean} [joined] These are studies that you have joined
         * @param {boolean} [created] These are studies that you have created
         * @param {boolean} [population] These are studies based on the entire population of users that have shared their data
         * @param {boolean} [downvoted] These are studies that you have down-voted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, sort?: string, limit?: number, offset?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, principalInvestigatorUserId?: number, open?: boolean, joined?: boolean, created?: boolean, population?: boolean, downvoted?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v3/studies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }

            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }

            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }

            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }

            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }

            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (includeCharts !== undefined) {
                localVarQueryParameter['includeCharts'] = includeCharts;
            }

            if (recalculate !== undefined) {
                localVarQueryParameter['recalculate'] = recalculate;
            }

            if (studyId !== undefined) {
                localVarQueryParameter['studyId'] = studyId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (correlationCoefficient !== undefined) {
                localVarQueryParameter['correlationCoefficient'] = correlationCoefficient;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (outcomesOfInterest !== undefined) {
                localVarQueryParameter['outcomesOfInterest'] = outcomesOfInterest;
            }

            if (principalInvestigatorUserId !== undefined) {
                localVarQueryParameter['principalInvestigatorUserId'] = principalInvestigatorUserId;
            }

            if (open !== undefined) {
                localVarQueryParameter['open'] = open;
            }

            if (joined !== undefined) {
                localVarQueryParameter['joined'] = joined;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (population !== undefined) {
                localVarQueryParameter['population'] = population;
            }

            if (downvoted !== undefined) {
                localVarQueryParameter['downvoted'] = downvoted;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * These are studies that you have created.
         * @summary Get studies you have created
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesCreated(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, updatedAt?: string, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/studies/created`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }

            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }

            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }

            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }

            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }

            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * These are studies that you are currently sharing your data with.
         * @summary Studies You Have Joined
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesJoined(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/studies/joined`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }

            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }

            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }

            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }

            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }

            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (correlationCoefficient !== undefined) {
                localVarQueryParameter['correlationCoefficient'] = correlationCoefficient;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (outcomesOfInterest !== undefined) {
                localVarQueryParameter['outcomesOfInterest'] = outcomesOfInterest;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Study
         * @summary Get Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v4/study`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }

            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }

            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }

            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }

            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }

            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (includeCharts !== undefined) {
                localVarQueryParameter['includeCharts'] = includeCharts;
            }

            if (recalculate !== undefined) {
                localVarQueryParameter['recalculate'] = recalculate;
            }

            if (studyId !== undefined) {
                localVarQueryParameter['studyId'] = studyId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Anonymously share measurements for specified variables
         * @summary Join a Study
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinStudy(studyId?: string, causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/study/join`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (studyId !== undefined) {
                localVarQueryParameter['studyId'] = studyId;
            }

            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }

            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }

            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }

            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }

            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }

            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
         * @summary Post or update vote
         * @param {Vote} body Contains the cause variable, effect variable, and vote value.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVote(body: Vote, userId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postVote.');
            }
            const localVarPath = `/v3/votes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Vote" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a study and all related measurements publicly visible by anyone
         * @summary Publish Your Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/study/publish`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }

            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }

            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }

            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }

            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }

            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (includeCharts !== undefined) {
                localVarQueryParameter['includeCharts'] = includeCharts;
            }

            if (recalculate !== undefined) {
                localVarQueryParameter['recalculate'] = recalculate;
            }

            if (studyId !== undefined) {
                localVarQueryParameter['studyId'] = studyId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiesApi - functional programming interface
 * @export
 */
export const StudiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
         * @summary Create a Study
         * @param {StudyCreationBody} body Details about the study you want to create
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudy(body: StudyCreationBody, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostStudyCreateResponse> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).createStudy(body, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete previously posted vote
         * @summary Delete vote
         * @param {VoteDelete} body The cause and effect variable names for the predictor vote to be deleted.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVote(body: VoteDelete, userId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommonResponse> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).deleteVote(body, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
         * @summary These are open studies that anyone can join
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetStudiesResponse> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).getOpenStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
         * @summary Get Personal or Population Studies
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {number} [principalInvestigatorUserId] These are studies created by a specific principal investigator
         * @param {boolean} [open] These are studies that anyone can join
         * @param {boolean} [joined] These are studies that you have joined
         * @param {boolean} [created] These are studies that you have created
         * @param {boolean} [population] These are studies based on the entire population of users that have shared their data
         * @param {boolean} [downvoted] These are studies that you have down-voted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, sort?: string, limit?: number, offset?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, principalInvestigatorUserId?: number, open?: boolean, joined?: boolean, created?: boolean, population?: boolean, downvoted?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetStudiesResponse> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).getStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * These are studies that you have created.
         * @summary Get studies you have created
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesCreated(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, updatedAt?: string, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetStudiesResponse> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).getStudiesCreated(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * These are studies that you are currently sharing your data with.
         * @summary Studies You Have Joined
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesJoined(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetStudiesResponse> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).getStudiesJoined(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Study
         * @summary Get Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Study> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).getStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Anonymously share measurements for specified variables
         * @summary Join a Study
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinStudy(studyId?: string, causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StudyJoinResponse> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).joinStudy(studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
         * @summary Post or update vote
         * @param {Vote} body Contains the cause variable, effect variable, and vote value.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVote(body: Vote, userId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommonResponse> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).postVote(body, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Make a study and all related measurements publicly visible by anyone
         * @summary Publish Your Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostStudyPublishResponse> {
            const localVarFetchArgs = StudiesApiFetchParamCreator(configuration).publishStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StudiesApi - factory interface
 * @export
 */
export const StudiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
         * @summary Create a Study
         * @param {StudyCreationBody} body Details about the study you want to create
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudy(body: StudyCreationBody, clientId?: string, options?: any) {
            return StudiesApiFp(configuration).createStudy(body, clientId, options)(fetch, basePath);
        },
        /**
         * Delete previously posted vote
         * @summary Delete vote
         * @param {VoteDelete} body The cause and effect variable names for the predictor vote to be deleted.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVote(body: VoteDelete, userId?: number, options?: any) {
            return StudiesApiFp(configuration).deleteVote(body, userId, options)(fetch, basePath);
        },
        /**
         * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
         * @summary These are open studies that anyone can join
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any) {
            return StudiesApiFp(configuration).getOpenStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(fetch, basePath);
        },
        /**
         * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
         * @summary Get Personal or Population Studies
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {number} [principalInvestigatorUserId] These are studies created by a specific principal investigator
         * @param {boolean} [open] These are studies that anyone can join
         * @param {boolean} [joined] These are studies that you have joined
         * @param {boolean} [created] These are studies that you have created
         * @param {boolean} [population] These are studies based on the entire population of users that have shared their data
         * @param {boolean} [downvoted] These are studies that you have down-voted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, sort?: string, limit?: number, offset?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, principalInvestigatorUserId?: number, open?: boolean, joined?: boolean, created?: boolean, population?: boolean, downvoted?: boolean, options?: any) {
            return StudiesApiFp(configuration).getStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options)(fetch, basePath);
        },
        /**
         * These are studies that you have created.
         * @summary Get studies you have created
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesCreated(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, updatedAt?: string, clientId?: string, options?: any) {
            return StudiesApiFp(configuration).getStudiesCreated(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options)(fetch, basePath);
        },
        /**
         * These are studies that you are currently sharing your data with.
         * @summary Studies You Have Joined
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesJoined(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, options?: any) {
            return StudiesApiFp(configuration).getStudiesJoined(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options)(fetch, basePath);
        },
        /**
         * Get Study
         * @summary Get Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any) {
            return StudiesApiFp(configuration).getStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(fetch, basePath);
        },
        /**
         * Anonymously share measurements for specified variables
         * @summary Join a Study
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinStudy(studyId?: string, causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, options?: any) {
            return StudiesApiFp(configuration).joinStudy(studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options)(fetch, basePath);
        },
        /**
         * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
         * @summary Post or update vote
         * @param {Vote} body Contains the cause variable, effect variable, and vote value.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVote(body: Vote, userId?: number, options?: any) {
            return StudiesApiFp(configuration).postVote(body, userId, options)(fetch, basePath);
        },
        /**
         * Make a study and all related measurements publicly visible by anyone
         * @summary Publish Your Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any) {
            return StudiesApiFp(configuration).publishStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(fetch, basePath);
        },
    };
};

/**
 * StudiesApi - interface
 * @export
 * @interface StudiesApi
 */
export interface StudiesApiInterface {
    /**
     * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
     * @summary Create a Study
     * @param {StudyCreationBody} body Details about the study you want to create
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApiInterface
     */
    createStudy(body: StudyCreationBody, clientId?: string, options?: any): Promise<PostStudyCreateResponse>;

    /**
     * Delete previously posted vote
     * @summary Delete vote
     * @param {VoteDelete} body The cause and effect variable names for the predictor vote to be deleted.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApiInterface
     */
    deleteVote(body: VoteDelete, userId?: number, options?: any): Promise<CommonResponse>;

    /**
     * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
     * @summary These are open studies that anyone can join
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApiInterface
     */
    getOpenStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any): Promise<GetStudiesResponse>;

    /**
     * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
     * @summary Get Personal or Population Studies
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
     * @param {number} [principalInvestigatorUserId] These are studies created by a specific principal investigator
     * @param {boolean} [open] These are studies that anyone can join
     * @param {boolean} [joined] These are studies that you have joined
     * @param {boolean} [created] These are studies that you have created
     * @param {boolean} [population] These are studies based on the entire population of users that have shared their data
     * @param {boolean} [downvoted] These are studies that you have down-voted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApiInterface
     */
    getStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, sort?: string, limit?: number, offset?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, principalInvestigatorUserId?: number, open?: boolean, joined?: boolean, created?: boolean, population?: boolean, downvoted?: boolean, options?: any): Promise<GetStudiesResponse>;

    /**
     * These are studies that you have created.
     * @summary Get studies you have created
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {number} [userId] User&#39;s id
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApiInterface
     */
    getStudiesCreated(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, updatedAt?: string, clientId?: string, options?: any): Promise<GetStudiesResponse>;

    /**
     * These are studies that you are currently sharing your data with.
     * @summary Studies You Have Joined
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {number} [userId] User&#39;s id
     * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApiInterface
     */
    getStudiesJoined(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, options?: any): Promise<GetStudiesResponse>;

    /**
     * Get Study
     * @summary Get Study
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApiInterface
     */
    getStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any): Promise<Study>;

    /**
     * Anonymously share measurements for specified variables
     * @summary Join a Study
     * @param {string} [studyId] Client id for the study you want
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApiInterface
     */
    joinStudy(studyId?: string, causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, options?: any): Promise<StudyJoinResponse>;

    /**
     * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
     * @summary Post or update vote
     * @param {Vote} body Contains the cause variable, effect variable, and vote value.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApiInterface
     */
    postVote(body: Vote, userId?: number, options?: any): Promise<CommonResponse>;

    /**
     * Make a study and all related measurements publicly visible by anyone
     * @summary Publish Your Study
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApiInterface
     */
    publishStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any): Promise<PostStudyPublishResponse>;

}

/**
 * StudiesApi - object-oriented interface
 * @export
 * @class StudiesApi
 * @extends {BaseAPI}
 */
export class StudiesApi extends BaseAPI implements StudiesApiInterface {
    /**
     * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
     * @summary Create a Study
     * @param {StudyCreationBody} body Details about the study you want to create
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public createStudy(body: StudyCreationBody, clientId?: string, options?: any) {
        return StudiesApiFp(this.configuration).createStudy(body, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Delete previously posted vote
     * @summary Delete vote
     * @param {VoteDelete} body The cause and effect variable names for the predictor vote to be deleted.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public deleteVote(body: VoteDelete, userId?: number, options?: any) {
        return StudiesApiFp(this.configuration).deleteVote(body, userId, options)(this.fetch, this.basePath);
    }

    /**
     * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
     * @summary These are open studies that anyone can join
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getOpenStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any) {
        return StudiesApiFp(this.configuration).getOpenStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(this.fetch, this.basePath);
    }

    /**
     * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
     * @summary Get Personal or Population Studies
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
     * @param {number} [principalInvestigatorUserId] These are studies created by a specific principal investigator
     * @param {boolean} [open] These are studies that anyone can join
     * @param {boolean} [joined] These are studies that you have joined
     * @param {boolean} [created] These are studies that you have created
     * @param {boolean} [population] These are studies based on the entire population of users that have shared their data
     * @param {boolean} [downvoted] These are studies that you have down-voted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, sort?: string, limit?: number, offset?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, principalInvestigatorUserId?: number, open?: boolean, joined?: boolean, created?: boolean, population?: boolean, downvoted?: boolean, options?: any) {
        return StudiesApiFp(this.configuration).getStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options)(this.fetch, this.basePath);
    }

    /**
     * These are studies that you have created.
     * @summary Get studies you have created
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {number} [userId] User&#39;s id
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudiesCreated(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, updatedAt?: string, clientId?: string, options?: any) {
        return StudiesApiFp(this.configuration).getStudiesCreated(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * These are studies that you are currently sharing your data with.
     * @summary Studies You Have Joined
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {number} [userId] User&#39;s id
     * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudiesJoined(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, options?: any) {
        return StudiesApiFp(this.configuration).getStudiesJoined(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Get Study
     * @summary Get Study
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public getStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any) {
        return StudiesApiFp(this.configuration).getStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(this.fetch, this.basePath);
    }

    /**
     * Anonymously share measurements for specified variables
     * @summary Join a Study
     * @param {string} [studyId] Client id for the study you want
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public joinStudy(studyId?: string, causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, options?: any) {
        return StudiesApiFp(this.configuration).joinStudy(studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
     * @summary Post or update vote
     * @param {Vote} body Contains the cause variable, effect variable, and vote value.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public postVote(body: Vote, userId?: number, options?: any) {
        return StudiesApiFp(this.configuration).postVote(body, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Make a study and all related measurements publicly visible by anyone
     * @summary Publish Your Study
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    public publishStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, options?: any) {
        return StudiesApiFp(this.configuration).publishStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(this.fetch, this.basePath);
    }

}

/**
 * UnitsApi - fetch parameter creator
 * @export
 */
export const UnitsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
         * @summary Get unit categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnitCategories(options: any = {}): FetchArgs {
            const localVarPath = `/v3/unitCategories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the available measurement units
         * @summary Get units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnits(options: any = {}): FetchArgs {
            const localVarPath = `/v3/units`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnitsApi - functional programming interface
 * @export
 */
export const UnitsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
         * @summary Get unit categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnitCategories(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UnitCategory>> {
            const localVarFetchArgs = UnitsApiFetchParamCreator(configuration).getUnitCategories(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of the available measurement units
         * @summary Get units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnits(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Unit>> {
            const localVarFetchArgs = UnitsApiFetchParamCreator(configuration).getUnits(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UnitsApi - factory interface
 * @export
 */
export const UnitsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
         * @summary Get unit categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnitCategories(options?: any) {
            return UnitsApiFp(configuration).getUnitCategories(options)(fetch, basePath);
        },
        /**
         * Get a list of the available measurement units
         * @summary Get units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnits(options?: any) {
            return UnitsApiFp(configuration).getUnits(options)(fetch, basePath);
        },
    };
};

/**
 * UnitsApi - interface
 * @export
 * @interface UnitsApi
 */
export interface UnitsApiInterface {
    /**
     * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
     * @summary Get unit categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApiInterface
     */
    getUnitCategories(options?: any): Promise<Array<UnitCategory>>;

    /**
     * Get a list of the available measurement units
     * @summary Get units
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApiInterface
     */
    getUnits(options?: any): Promise<Array<Unit>>;

}

/**
 * UnitsApi - object-oriented interface
 * @export
 * @class UnitsApi
 * @extends {BaseAPI}
 */
export class UnitsApi extends BaseAPI implements UnitsApiInterface {
    /**
     * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
     * @summary Get unit categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    public getUnitCategories(options?: any) {
        return UnitsApiFp(this.configuration).getUnitCategories(options)(this.fetch, this.basePath);
    }

    /**
     * Get a list of the available measurement units
     * @summary Get units
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    public getUnits(options?: any) {
        return UnitsApiFp(this.configuration).getUnits(options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete user account. Only the client app that created a user can delete that user.
         * @summary Delete user
         * @param {string} reason Ex: I hate you!
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(reason: string, clientId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'reason' is not null or undefined
            if (reason === null || reason === undefined) {
                throw new RequiredError('reason','Required parameter reason was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/v3/user/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns user info.  If no userId is specified, returns info for currently authenticated user
         * @summary Get user info
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {boolean} [includeAuthorizedClients] Return list of apps, studies, and individuals with access to user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, clientUserId?: number, log?: string, pwd?: string, includeAuthorizedClients?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v3/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }

            if (clientUserId !== undefined) {
                localVarQueryParameter['clientUserId'] = clientUserId;
            }

            if (log !== undefined) {
                localVarQueryParameter['log'] = log;
            }

            if (pwd !== undefined) {
                localVarQueryParameter['pwd'] = pwd;
            }

            if (includeAuthorizedClients !== undefined) {
                localVarQueryParameter['includeAuthorizedClients'] = includeAuthorizedClients;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UserBlogs
         * @summary Get UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBlogs(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/userBlogs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns users who have granted access to their data
         * @summary Get users who shared data
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, clientUserId?: number, log?: string, pwd?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }

            if (clientUserId !== undefined) {
                localVarQueryParameter['clientUserId'] = clientUserId;
            }

            if (log !== undefined) {
                localVarQueryParameter['log'] = log;
            }

            if (pwd !== undefined) {
                localVarQueryParameter['pwd'] = pwd;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post UserBlogs
         * @summary Post UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserBlogs(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/userBlogs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post UserSettings
         * @summary Post UserSettings
         * @param {User} body User settings to update
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSettings(body: User, clientId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postUserSettings.');
            }
            const localVarPath = `/v3/userSettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete user account. Only the client app that created a user can delete that user.
         * @summary Delete user
         * @param {string} reason Ex: I hate you!
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(reason: string, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommonResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUser(reason, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns user info.  If no userId is specified, returns info for currently authenticated user
         * @summary Get user info
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {boolean} [includeAuthorizedClients] Return list of apps, studies, and individuals with access to user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, clientUserId?: number, log?: string, pwd?: string, includeAuthorizedClients?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUser(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UserBlogs
         * @summary Get UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBlogs(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserBlogsResponse>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns users who have granted access to their data
         * @summary Get users who shared data
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, clientUserId?: number, log?: string, pwd?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UsersResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUsers(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post UserBlogs
         * @summary Post UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserBlogs(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserBlogsResponse>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).postUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post UserSettings
         * @summary Post UserSettings
         * @param {User} body User settings to update
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSettings(body: User, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostUserSettingsResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).postUserSettings(body, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete user account. Only the client app that created a user can delete that user.
         * @summary Delete user
         * @param {string} reason Ex: I hate you!
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(reason: string, clientId?: string, options?: any) {
            return UserApiFp(configuration).deleteUser(reason, clientId, options)(fetch, basePath);
        },
        /**
         * Returns user info.  If no userId is specified, returns info for currently authenticated user
         * @summary Get user info
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {boolean} [includeAuthorizedClients] Return list of apps, studies, and individuals with access to user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, clientUserId?: number, log?: string, pwd?: string, includeAuthorizedClients?: boolean, options?: any) {
            return UserApiFp(configuration).getUser(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options)(fetch, basePath);
        },
        /**
         * Get UserBlogs
         * @summary Get UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBlogs(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return UserApiFp(configuration).getUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Returns users who have granted access to their data
         * @summary Get users who shared data
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, clientUserId?: number, log?: string, pwd?: string, options?: any) {
            return UserApiFp(configuration).getUsers(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options)(fetch, basePath);
        },
        /**
         * Post UserBlogs
         * @summary Post UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserBlogs(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return UserApiFp(configuration).postUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post UserSettings
         * @summary Post UserSettings
         * @param {User} body User settings to update
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSettings(body: User, clientId?: string, options?: any) {
            return UserApiFp(configuration).postUserSettings(body, clientId, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * Delete user account. Only the client app that created a user can delete that user.
     * @summary Delete user
     * @param {string} reason Ex: I hate you!
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUser(reason: string, clientId?: string, options?: any): Promise<CommonResponse>;

    /**
     * Returns user info.  If no userId is specified, returns info for currently authenticated user
     * @summary Get user info
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {number} [clientUserId] Ex: 74802
     * @param {string} [log] Username or email
     * @param {string} [pwd] User password
     * @param {boolean} [includeAuthorizedClients] Return list of apps, studies, and individuals with access to user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUser(userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, clientUserId?: number, log?: string, pwd?: string, includeAuthorizedClients?: boolean, options?: any): Promise<User>;

    /**
     * Get UserBlogs
     * @summary Get UserBlogs
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserBlogs(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<UserBlogsResponse>>;

    /**
     * Returns users who have granted access to their data
     * @summary Get users who shared data
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {number} [clientUserId] Ex: 74802
     * @param {string} [log] Username or email
     * @param {string} [pwd] User password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUsers(userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, clientUserId?: number, log?: string, pwd?: string, options?: any): Promise<UsersResponse>;

    /**
     * Post UserBlogs
     * @summary Post UserBlogs
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    postUserBlogs(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<UserBlogsResponse>>;

    /**
     * Post UserSettings
     * @summary Post UserSettings
     * @param {User} body User settings to update
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    postUserSettings(body: User, clientId?: string, options?: any): Promise<PostUserSettingsResponse>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * Delete user account. Only the client app that created a user can delete that user.
     * @summary Delete user
     * @param {string} reason Ex: I hate you!
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(reason: string, clientId?: string, options?: any) {
        return UserApiFp(this.configuration).deleteUser(reason, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns user info.  If no userId is specified, returns info for currently authenticated user
     * @summary Get user info
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {number} [clientUserId] Ex: 74802
     * @param {string} [log] Username or email
     * @param {string} [pwd] User password
     * @param {boolean} [includeAuthorizedClients] Return list of apps, studies, and individuals with access to user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, clientUserId?: number, log?: string, pwd?: string, includeAuthorizedClients?: boolean, options?: any) {
        return UserApiFp(this.configuration).getUser(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options)(this.fetch, this.basePath);
    }

    /**
     * Get UserBlogs
     * @summary Get UserBlogs
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserBlogs(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return UserApiFp(this.configuration).getUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns users who have granted access to their data
     * @summary Get users who shared data
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {number} [clientUserId] Ex: 74802
     * @param {string} [log] Username or email
     * @param {string} [pwd] User password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(userId?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string, clientId?: string, appVersion?: string, clientUserId?: number, log?: string, pwd?: string, options?: any) {
        return UserApiFp(this.configuration).getUsers(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options)(this.fetch, this.basePath);
    }

    /**
     * Post UserBlogs
     * @summary Post UserBlogs
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postUserBlogs(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return UserApiFp(this.configuration).postUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post UserSettings
     * @summary Post UserSettings
     * @param {User} body User settings to update
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postUserSettings(body: User, clientId?: string, options?: any) {
        return UserApiFp(this.configuration).postUserSettings(body, clientId, options)(this.fetch, this.basePath);
    }

}

/**
 * VariablesApi - fetch parameter creator
 * @export
 */
export const VariablesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete previously created user tags or ingredients.
         * @summary Delete user tag or ingredient
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(taggedVariableId?: number, tagVariableId?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v3/userTags/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (taggedVariableId !== undefined) {
                localVarQueryParameter['taggedVariableId'] = taggedVariableId;
            }

            if (tagVariableId !== undefined) {
                localVarQueryParameter['tagVariableId'] = tagVariableId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can delete all of their measurements for a variable
         * @summary Delete All Measurements For Variable
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserVariable(variableId: UserVariableDelete, options: any = {}): FetchArgs {
            // verify required parameter 'variableId' is not null or undefined
            if (variableId === null || variableId === undefined) {
                throw new RequiredError('variableId','Required parameter variableId was null or undefined when calling deleteUserVariable.');
            }
            const localVarPath = `/v3/userVariables/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserVariableDelete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(variableId || {}) : (variableId || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
         * @summary Variable categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableCategories(options: any = {}): FetchArgs {
            const localVarPath = `/v3/variableCategories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
         * @summary Get variables along with related user-specific analysis settings and statistics
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {string} [numberOfRawMeasurements] Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
         * @param {number} [userId] User&#39;s id
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [name] Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood%
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Common variable id
         * @param {string} [lastSourceName] Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [upc] UPC or other barcode scan result
         * @param {string} [effectOrCause] Provided variable is the effect or cause
         * @param {string} [publicEffectOrCause] Ex: 
         * @param {boolean} [exactMatch] Require exact match
         * @param {number} [variableCategoryId] Ex: 13
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [joinVariableId] Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
         * @param {number} [parentUserTagVariableId] Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [childUserTagVariableId] Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [ingredientUserTagVariableId] Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {number} [ingredientOfUserTagVariableId] Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {boolean} [commonOnly] Return only public and aggregated common variable data instead of user-specific variables
         * @param {boolean} [userOnly] Return only user-specific variables and data, excluding common aggregated variable data
         * @param {boolean} [includeTags] Return parent, child, duplicate, and ingredient variables
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {number} [variableId] Ex: 13
         * @param {boolean} [concise] Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
         * @param {boolean} [refresh] Regenerate charts instead of getting from the cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(includeCharts?: boolean, numberOfRawMeasurements?: string, userId?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', name?: string, variableName?: string, updatedAt?: string, sourceName?: string, earliestMeasurementTime?: string, latestMeasurementTime?: string, id?: number, lastSourceName?: string, limit?: number, offset?: number, sort?: string, includePublic?: boolean, manualTracking?: boolean, clientId?: string, upc?: string, effectOrCause?: string, publicEffectOrCause?: string, exactMatch?: boolean, variableCategoryId?: number, includePrivate?: boolean, searchPhrase?: string, synonyms?: string, taggedVariableId?: number, tagVariableId?: number, joinVariableId?: number, parentUserTagVariableId?: number, childUserTagVariableId?: number, ingredientUserTagVariableId?: number, ingredientOfUserTagVariableId?: number, commonOnly?: boolean, userOnly?: boolean, includeTags?: boolean, recalculate?: boolean, variableId?: number, concise?: boolean, refresh?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v3/variables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (includeCharts !== undefined) {
                localVarQueryParameter['includeCharts'] = includeCharts;
            }

            if (numberOfRawMeasurements !== undefined) {
                localVarQueryParameter['numberOfRawMeasurements'] = numberOfRawMeasurements;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (variableCategoryName !== undefined) {
                localVarQueryParameter['variableCategoryName'] = variableCategoryName;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (variableName !== undefined) {
                localVarQueryParameter['variableName'] = variableName;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (sourceName !== undefined) {
                localVarQueryParameter['sourceName'] = sourceName;
            }

            if (earliestMeasurementTime !== undefined) {
                localVarQueryParameter['earliestMeasurementTime'] = earliestMeasurementTime;
            }

            if (latestMeasurementTime !== undefined) {
                localVarQueryParameter['latestMeasurementTime'] = latestMeasurementTime;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (lastSourceName !== undefined) {
                localVarQueryParameter['lastSourceName'] = lastSourceName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (includePublic !== undefined) {
                localVarQueryParameter['includePublic'] = includePublic;
            }

            if (manualTracking !== undefined) {
                localVarQueryParameter['manualTracking'] = manualTracking;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (upc !== undefined) {
                localVarQueryParameter['upc'] = upc;
            }

            if (effectOrCause !== undefined) {
                localVarQueryParameter['effectOrCause'] = effectOrCause;
            }

            if (publicEffectOrCause !== undefined) {
                localVarQueryParameter['publicEffectOrCause'] = publicEffectOrCause;
            }

            if (exactMatch !== undefined) {
                localVarQueryParameter['exactMatch'] = exactMatch;
            }

            if (variableCategoryId !== undefined) {
                localVarQueryParameter['variableCategoryId'] = variableCategoryId;
            }

            if (includePrivate !== undefined) {
                localVarQueryParameter['includePrivate'] = includePrivate;
            }

            if (searchPhrase !== undefined) {
                localVarQueryParameter['searchPhrase'] = searchPhrase;
            }

            if (synonyms !== undefined) {
                localVarQueryParameter['synonyms'] = synonyms;
            }

            if (taggedVariableId !== undefined) {
                localVarQueryParameter['taggedVariableId'] = taggedVariableId;
            }

            if (tagVariableId !== undefined) {
                localVarQueryParameter['tagVariableId'] = tagVariableId;
            }

            if (joinVariableId !== undefined) {
                localVarQueryParameter['joinVariableId'] = joinVariableId;
            }

            if (parentUserTagVariableId !== undefined) {
                localVarQueryParameter['parentUserTagVariableId'] = parentUserTagVariableId;
            }

            if (childUserTagVariableId !== undefined) {
                localVarQueryParameter['childUserTagVariableId'] = childUserTagVariableId;
            }

            if (ingredientUserTagVariableId !== undefined) {
                localVarQueryParameter['ingredientUserTagVariableId'] = ingredientUserTagVariableId;
            }

            if (ingredientOfUserTagVariableId !== undefined) {
                localVarQueryParameter['ingredientOfUserTagVariableId'] = ingredientOfUserTagVariableId;
            }

            if (commonOnly !== undefined) {
                localVarQueryParameter['commonOnly'] = commonOnly;
            }

            if (userOnly !== undefined) {
                localVarQueryParameter['userOnly'] = userOnly;
            }

            if (includeTags !== undefined) {
                localVarQueryParameter['includeTags'] = includeTags;
            }

            if (recalculate !== undefined) {
                localVarQueryParameter['recalculate'] = recalculate;
            }

            if (variableId !== undefined) {
                localVarQueryParameter['variableId'] = variableId;
            }

            if (concise !== undefined) {
                localVarQueryParameter['concise'] = concise;
            }

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
         * @summary Post or update user tags or ingredients
         * @param {UserTag} body Contains the new user tag data
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserTags(body: UserTag, userId?: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postUserTags.');
            }
            const localVarPath = `/v3/userTags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserTag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
         * @summary Update User Settings for a Variable
         * @param {Array<Variable>} userVariables Variable user settings data
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {boolean} [exactMatch] Require exact match
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {number} [variableCategoryId] Ex: 13
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserVariables(userVariables: Array<Variable>, includePrivate?: boolean, clientId?: string, includePublic?: boolean, searchPhrase?: string, exactMatch?: boolean, manualTracking?: boolean, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', variableCategoryId?: number, synonyms?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userVariables' is not null or undefined
            if (userVariables === null || userVariables === undefined) {
                throw new RequiredError('userVariables','Required parameter userVariables was null or undefined when calling postUserVariables.');
            }
            const localVarPath = `/v3/variables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (includePrivate !== undefined) {
                localVarQueryParameter['includePrivate'] = includePrivate;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (includePublic !== undefined) {
                localVarQueryParameter['includePublic'] = includePublic;
            }

            if (searchPhrase !== undefined) {
                localVarQueryParameter['searchPhrase'] = searchPhrase;
            }

            if (exactMatch !== undefined) {
                localVarQueryParameter['exactMatch'] = exactMatch;
            }

            if (manualTracking !== undefined) {
                localVarQueryParameter['manualTracking'] = manualTracking;
            }

            if (variableCategoryName !== undefined) {
                localVarQueryParameter['variableCategoryName'] = variableCategoryName;
            }

            if (variableCategoryId !== undefined) {
                localVarQueryParameter['variableCategoryId'] = variableCategoryId;
            }

            if (synonyms !== undefined) {
                localVarQueryParameter['synonyms'] = synonyms;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;Variable&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(userVariables || {}) : (userVariables || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset user settings for a variable to defaults
         * @summary Reset user settings for a variable to defaults
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserVariableSettings(variableId: UserVariableDelete, options: any = {}): FetchArgs {
            // verify required parameter 'variableId' is not null or undefined
            if (variableId === null || variableId === undefined) {
                throw new RequiredError('variableId','Required parameter variableId was null or undefined when calling resetUserVariableSettings.');
            }
            const localVarPath = `/v3/userVariables/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["basic"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserVariableDelete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(variableId || {}) : (variableId || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariablesApi - functional programming interface
 * @export
 */
export const VariablesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete previously created user tags or ingredients.
         * @summary Delete user tag or ingredient
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(taggedVariableId?: number, tagVariableId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommonResponse> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).deleteUserTag(taggedVariableId, tagVariableId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Users can delete all of their measurements for a variable
         * @summary Delete All Measurements For Variable
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserVariable(variableId: UserVariableDelete, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).deleteUserVariable(variableId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
         * @summary Variable categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableCategories(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<VariableCategory>> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).getVariableCategories(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
         * @summary Get variables along with related user-specific analysis settings and statistics
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {string} [numberOfRawMeasurements] Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
         * @param {number} [userId] User&#39;s id
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [name] Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood%
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Common variable id
         * @param {string} [lastSourceName] Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [upc] UPC or other barcode scan result
         * @param {string} [effectOrCause] Provided variable is the effect or cause
         * @param {string} [publicEffectOrCause] Ex: 
         * @param {boolean} [exactMatch] Require exact match
         * @param {number} [variableCategoryId] Ex: 13
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [joinVariableId] Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
         * @param {number} [parentUserTagVariableId] Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [childUserTagVariableId] Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [ingredientUserTagVariableId] Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {number} [ingredientOfUserTagVariableId] Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {boolean} [commonOnly] Return only public and aggregated common variable data instead of user-specific variables
         * @param {boolean} [userOnly] Return only user-specific variables and data, excluding common aggregated variable data
         * @param {boolean} [includeTags] Return parent, child, duplicate, and ingredient variables
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {number} [variableId] Ex: 13
         * @param {boolean} [concise] Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
         * @param {boolean} [refresh] Regenerate charts instead of getting from the cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(includeCharts?: boolean, numberOfRawMeasurements?: string, userId?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', name?: string, variableName?: string, updatedAt?: string, sourceName?: string, earliestMeasurementTime?: string, latestMeasurementTime?: string, id?: number, lastSourceName?: string, limit?: number, offset?: number, sort?: string, includePublic?: boolean, manualTracking?: boolean, clientId?: string, upc?: string, effectOrCause?: string, publicEffectOrCause?: string, exactMatch?: boolean, variableCategoryId?: number, includePrivate?: boolean, searchPhrase?: string, synonyms?: string, taggedVariableId?: number, tagVariableId?: number, joinVariableId?: number, parentUserTagVariableId?: number, childUserTagVariableId?: number, ingredientUserTagVariableId?: number, ingredientOfUserTagVariableId?: number, commonOnly?: boolean, userOnly?: boolean, includeTags?: boolean, recalculate?: boolean, variableId?: number, concise?: boolean, refresh?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Variable>> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).getVariables(includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
         * @summary Post or update user tags or ingredients
         * @param {UserTag} body Contains the new user tag data
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserTags(body: UserTag, userId?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommonResponse> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).postUserTags(body, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
         * @summary Update User Settings for a Variable
         * @param {Array<Variable>} userVariables Variable user settings data
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {boolean} [exactMatch] Require exact match
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {number} [variableCategoryId] Ex: 13
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserVariables(userVariables: Array<Variable>, includePrivate?: boolean, clientId?: string, includePublic?: boolean, searchPhrase?: string, exactMatch?: boolean, manualTracking?: boolean, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', variableCategoryId?: number, synonyms?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommonResponse> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).postUserVariables(userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reset user settings for a variable to defaults
         * @summary Reset user settings for a variable to defaults
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserVariableSettings(variableId: UserVariableDelete, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VariablesApiFetchParamCreator(configuration).resetUserVariableSettings(variableId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VariablesApi - factory interface
 * @export
 */
export const VariablesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete previously created user tags or ingredients.
         * @summary Delete user tag or ingredient
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(taggedVariableId?: number, tagVariableId?: number, options?: any) {
            return VariablesApiFp(configuration).deleteUserTag(taggedVariableId, tagVariableId, options)(fetch, basePath);
        },
        /**
         * Users can delete all of their measurements for a variable
         * @summary Delete All Measurements For Variable
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserVariable(variableId: UserVariableDelete, options?: any) {
            return VariablesApiFp(configuration).deleteUserVariable(variableId, options)(fetch, basePath);
        },
        /**
         * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
         * @summary Variable categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableCategories(options?: any) {
            return VariablesApiFp(configuration).getVariableCategories(options)(fetch, basePath);
        },
        /**
         * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
         * @summary Get variables along with related user-specific analysis settings and statistics
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {string} [numberOfRawMeasurements] Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
         * @param {number} [userId] User&#39;s id
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {string} [name] Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood%
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Common variable id
         * @param {string} [lastSourceName] Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [upc] UPC or other barcode scan result
         * @param {string} [effectOrCause] Provided variable is the effect or cause
         * @param {string} [publicEffectOrCause] Ex: 
         * @param {boolean} [exactMatch] Require exact match
         * @param {number} [variableCategoryId] Ex: 13
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [joinVariableId] Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
         * @param {number} [parentUserTagVariableId] Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [childUserTagVariableId] Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [ingredientUserTagVariableId] Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {number} [ingredientOfUserTagVariableId] Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {boolean} [commonOnly] Return only public and aggregated common variable data instead of user-specific variables
         * @param {boolean} [userOnly] Return only user-specific variables and data, excluding common aggregated variable data
         * @param {boolean} [includeTags] Return parent, child, duplicate, and ingredient variables
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {number} [variableId] Ex: 13
         * @param {boolean} [concise] Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
         * @param {boolean} [refresh] Regenerate charts instead of getting from the cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(includeCharts?: boolean, numberOfRawMeasurements?: string, userId?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', name?: string, variableName?: string, updatedAt?: string, sourceName?: string, earliestMeasurementTime?: string, latestMeasurementTime?: string, id?: number, lastSourceName?: string, limit?: number, offset?: number, sort?: string, includePublic?: boolean, manualTracking?: boolean, clientId?: string, upc?: string, effectOrCause?: string, publicEffectOrCause?: string, exactMatch?: boolean, variableCategoryId?: number, includePrivate?: boolean, searchPhrase?: string, synonyms?: string, taggedVariableId?: number, tagVariableId?: number, joinVariableId?: number, parentUserTagVariableId?: number, childUserTagVariableId?: number, ingredientUserTagVariableId?: number, ingredientOfUserTagVariableId?: number, commonOnly?: boolean, userOnly?: boolean, includeTags?: boolean, recalculate?: boolean, variableId?: number, concise?: boolean, refresh?: boolean, options?: any) {
            return VariablesApiFp(configuration).getVariables(includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options)(fetch, basePath);
        },
        /**
         * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
         * @summary Post or update user tags or ingredients
         * @param {UserTag} body Contains the new user tag data
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserTags(body: UserTag, userId?: number, options?: any) {
            return VariablesApiFp(configuration).postUserTags(body, userId, options)(fetch, basePath);
        },
        /**
         * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
         * @summary Update User Settings for a Variable
         * @param {Array<Variable>} userVariables Variable user settings data
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {boolean} [exactMatch] Require exact match
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
         * @param {number} [variableCategoryId] Ex: 13
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserVariables(userVariables: Array<Variable>, includePrivate?: boolean, clientId?: string, includePublic?: boolean, searchPhrase?: string, exactMatch?: boolean, manualTracking?: boolean, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', variableCategoryId?: number, synonyms?: string, options?: any) {
            return VariablesApiFp(configuration).postUserVariables(userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options)(fetch, basePath);
        },
        /**
         * Reset user settings for a variable to defaults
         * @summary Reset user settings for a variable to defaults
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserVariableSettings(variableId: UserVariableDelete, options?: any) {
            return VariablesApiFp(configuration).resetUserVariableSettings(variableId, options)(fetch, basePath);
        },
    };
};

/**
 * VariablesApi - interface
 * @export
 * @interface VariablesApi
 */
export interface VariablesApiInterface {
    /**
     * Delete previously created user tags or ingredients.
     * @summary Delete user tag or ingredient
     * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApiInterface
     */
    deleteUserTag(taggedVariableId?: number, tagVariableId?: number, options?: any): Promise<CommonResponse>;

    /**
     * Users can delete all of their measurements for a variable
     * @summary Delete All Measurements For Variable
     * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApiInterface
     */
    deleteUserVariable(variableId: UserVariableDelete, options?: any): Promise<{}>;

    /**
     * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
     * @summary Variable categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApiInterface
     */
    getVariableCategories(options?: any): Promise<Array<VariableCategory>>;

    /**
     * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
     * @summary Get variables along with related user-specific analysis settings and statistics
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {string} [numberOfRawMeasurements] Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
     * @param {number} [userId] User&#39;s id
     * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
     * @param {string} [name] Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood%
     * @param {string} [variableName] Name of the variable you want measurements for
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
     * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Common variable id
     * @param {string} [lastSourceName] Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {boolean} [includePublic] Include variables the user has no measurements for
     * @param {boolean} [manualTracking] Only include variables tracked manually by the user
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [upc] UPC or other barcode scan result
     * @param {string} [effectOrCause] Provided variable is the effect or cause
     * @param {string} [publicEffectOrCause] Ex: 
     * @param {boolean} [exactMatch] Require exact match
     * @param {number} [variableCategoryId] Ex: 13
     * @param {boolean} [includePrivate] Include user-specific variables in results
     * @param {string} [searchPhrase] Ex: %Body Fat%
     * @param {string} [synonyms] Ex: McDonalds hotcake
     * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {number} [joinVariableId] Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
     * @param {number} [parentUserTagVariableId] Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
     * @param {number} [childUserTagVariableId] Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
     * @param {number} [ingredientUserTagVariableId] Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
     * @param {number} [ingredientOfUserTagVariableId] Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
     * @param {boolean} [commonOnly] Return only public and aggregated common variable data instead of user-specific variables
     * @param {boolean} [userOnly] Return only user-specific variables and data, excluding common aggregated variable data
     * @param {boolean} [includeTags] Return parent, child, duplicate, and ingredient variables
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {number} [variableId] Ex: 13
     * @param {boolean} [concise] Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
     * @param {boolean} [refresh] Regenerate charts instead of getting from the cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApiInterface
     */
    getVariables(includeCharts?: boolean, numberOfRawMeasurements?: string, userId?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', name?: string, variableName?: string, updatedAt?: string, sourceName?: string, earliestMeasurementTime?: string, latestMeasurementTime?: string, id?: number, lastSourceName?: string, limit?: number, offset?: number, sort?: string, includePublic?: boolean, manualTracking?: boolean, clientId?: string, upc?: string, effectOrCause?: string, publicEffectOrCause?: string, exactMatch?: boolean, variableCategoryId?: number, includePrivate?: boolean, searchPhrase?: string, synonyms?: string, taggedVariableId?: number, tagVariableId?: number, joinVariableId?: number, parentUserTagVariableId?: number, childUserTagVariableId?: number, ingredientUserTagVariableId?: number, ingredientOfUserTagVariableId?: number, commonOnly?: boolean, userOnly?: boolean, includeTags?: boolean, recalculate?: boolean, variableId?: number, concise?: boolean, refresh?: boolean, options?: any): Promise<Array<Variable>>;

    /**
     * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
     * @summary Post or update user tags or ingredients
     * @param {UserTag} body Contains the new user tag data
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApiInterface
     */
    postUserTags(body: UserTag, userId?: number, options?: any): Promise<CommonResponse>;

    /**
     * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
     * @summary Update User Settings for a Variable
     * @param {Array<Variable>} userVariables Variable user settings data
     * @param {boolean} [includePrivate] Include user-specific variables in results
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includePublic] Include variables the user has no measurements for
     * @param {string} [searchPhrase] Ex: %Body Fat%
     * @param {boolean} [exactMatch] Require exact match
     * @param {boolean} [manualTracking] Only include variables tracked manually by the user
     * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
     * @param {number} [variableCategoryId] Ex: 13
     * @param {string} [synonyms] Ex: McDonalds hotcake
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApiInterface
     */
    postUserVariables(userVariables: Array<Variable>, includePrivate?: boolean, clientId?: string, includePublic?: boolean, searchPhrase?: string, exactMatch?: boolean, manualTracking?: boolean, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', variableCategoryId?: number, synonyms?: string, options?: any): Promise<CommonResponse>;

    /**
     * Reset user settings for a variable to defaults
     * @summary Reset user settings for a variable to defaults
     * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApiInterface
     */
    resetUserVariableSettings(variableId: UserVariableDelete, options?: any): Promise<{}>;

}

/**
 * VariablesApi - object-oriented interface
 * @export
 * @class VariablesApi
 * @extends {BaseAPI}
 */
export class VariablesApi extends BaseAPI implements VariablesApiInterface {
    /**
     * Delete previously created user tags or ingredients.
     * @summary Delete user tag or ingredient
     * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public deleteUserTag(taggedVariableId?: number, tagVariableId?: number, options?: any) {
        return VariablesApiFp(this.configuration).deleteUserTag(taggedVariableId, tagVariableId, options)(this.fetch, this.basePath);
    }

    /**
     * Users can delete all of their measurements for a variable
     * @summary Delete All Measurements For Variable
     * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public deleteUserVariable(variableId: UserVariableDelete, options?: any) {
        return VariablesApiFp(this.configuration).deleteUserVariable(variableId, options)(this.fetch, this.basePath);
    }

    /**
     * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
     * @summary Variable categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariableCategories(options?: any) {
        return VariablesApiFp(this.configuration).getVariableCategories(options)(this.fetch, this.basePath);
    }

    /**
     * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
     * @summary Get variables along with related user-specific analysis settings and statistics
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {string} [numberOfRawMeasurements] Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
     * @param {number} [userId] User&#39;s id
     * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
     * @param {string} [name] Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood%
     * @param {string} [variableName] Name of the variable you want measurements for
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
     * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Common variable id
     * @param {string} [lastSourceName] Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {boolean} [includePublic] Include variables the user has no measurements for
     * @param {boolean} [manualTracking] Only include variables tracked manually by the user
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [upc] UPC or other barcode scan result
     * @param {string} [effectOrCause] Provided variable is the effect or cause
     * @param {string} [publicEffectOrCause] Ex: 
     * @param {boolean} [exactMatch] Require exact match
     * @param {number} [variableCategoryId] Ex: 13
     * @param {boolean} [includePrivate] Include user-specific variables in results
     * @param {string} [searchPhrase] Ex: %Body Fat%
     * @param {string} [synonyms] Ex: McDonalds hotcake
     * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {number} [joinVariableId] Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
     * @param {number} [parentUserTagVariableId] Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
     * @param {number} [childUserTagVariableId] Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
     * @param {number} [ingredientUserTagVariableId] Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
     * @param {number} [ingredientOfUserTagVariableId] Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
     * @param {boolean} [commonOnly] Return only public and aggregated common variable data instead of user-specific variables
     * @param {boolean} [userOnly] Return only user-specific variables and data, excluding common aggregated variable data
     * @param {boolean} [includeTags] Return parent, child, duplicate, and ingredient variables
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {number} [variableId] Ex: 13
     * @param {boolean} [concise] Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
     * @param {boolean} [refresh] Regenerate charts instead of getting from the cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public getVariables(includeCharts?: boolean, numberOfRawMeasurements?: string, userId?: number, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', name?: string, variableName?: string, updatedAt?: string, sourceName?: string, earliestMeasurementTime?: string, latestMeasurementTime?: string, id?: number, lastSourceName?: string, limit?: number, offset?: number, sort?: string, includePublic?: boolean, manualTracking?: boolean, clientId?: string, upc?: string, effectOrCause?: string, publicEffectOrCause?: string, exactMatch?: boolean, variableCategoryId?: number, includePrivate?: boolean, searchPhrase?: string, synonyms?: string, taggedVariableId?: number, tagVariableId?: number, joinVariableId?: number, parentUserTagVariableId?: number, childUserTagVariableId?: number, ingredientUserTagVariableId?: number, ingredientOfUserTagVariableId?: number, commonOnly?: boolean, userOnly?: boolean, includeTags?: boolean, recalculate?: boolean, variableId?: number, concise?: boolean, refresh?: boolean, options?: any) {
        return VariablesApiFp(this.configuration).getVariables(includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
     * @summary Post or update user tags or ingredients
     * @param {UserTag} body Contains the new user tag data
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public postUserTags(body: UserTag, userId?: number, options?: any) {
        return VariablesApiFp(this.configuration).postUserTags(body, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
     * @summary Update User Settings for a Variable
     * @param {Array<Variable>} userVariables Variable user settings data
     * @param {boolean} [includePrivate] Include user-specific variables in results
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includePublic] Include variables the user has no measurements for
     * @param {string} [searchPhrase] Ex: %Body Fat%
     * @param {boolean} [exactMatch] Require exact match
     * @param {boolean} [manualTracking] Only include variables tracked manually by the user
     * @param {'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals'} [variableCategoryName] Ex: Emotions, Treatments, Symptoms...
     * @param {number} [variableCategoryId] Ex: 13
     * @param {string} [synonyms] Ex: McDonalds hotcake
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public postUserVariables(userVariables: Array<Variable>, includePrivate?: boolean, clientId?: string, includePublic?: boolean, searchPhrase?: string, exactMatch?: boolean, manualTracking?: boolean, variableCategoryName?: 'Activities' | 'Books' | 'Causes of Illness' | 'Cognitive Performance' | 'Conditions' | 'Emotions' | 'Environment' | 'Foods' | 'Location' | 'Miscellaneous' | 'Movies and TV' | 'Music' | 'Nutrients' | 'Payments' | 'Physical Activity' | 'Physique' | 'Sleep' | 'Social Interactions' | 'Software' | 'Symptoms' | 'Treatments' | 'Vital Signs' | 'Goals', variableCategoryId?: number, synonyms?: string, options?: any) {
        return VariablesApiFp(this.configuration).postUserVariables(userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options)(this.fetch, this.basePath);
    }

    /**
     * Reset user settings for a variable to defaults
     * @summary Reset user settings for a variable to defaults
     * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    public resetUserVariableSettings(variableId: UserVariableDelete, options?: any) {
        return VariablesApiFp(this.configuration).resetUserVariableSettings(variableId, options)(this.fetch, this.basePath);
    }

}

/**
 * XprofileApi - fetch parameter creator
 * @export
 */
export const XprofileApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get XprofileData
         * @summary Get XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileData(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/xprofileData`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get XprofileFields
         * @summary Get XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileFields(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/xprofileFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get XprofileGroups
         * @summary Get XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/xprofileGroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post XprofileData
         * @summary Post XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileData(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/xprofileData`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post XprofileFields
         * @summary Post XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileFields(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/xprofileFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post XprofileGroups
         * @summary Post XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v3/xprofileGroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("access_token")
					: configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }

            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * XprofileApi - functional programming interface
 * @export
 */
export const XprofileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get XprofileData
         * @summary Get XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileData(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<XprofileDataResponse>> {
            const localVarFetchArgs = XprofileApiFetchParamCreator(configuration).getXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get XprofileFields
         * @summary Get XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileFields(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<XprofileFieldsResponse>> {
            const localVarFetchArgs = XprofileApiFetchParamCreator(configuration).getXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get XprofileGroups
         * @summary Get XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<XprofileGroupsResponse>> {
            const localVarFetchArgs = XprofileApiFetchParamCreator(configuration).getXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post XprofileData
         * @summary Post XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileData(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<XprofileDataResponse>> {
            const localVarFetchArgs = XprofileApiFetchParamCreator(configuration).postXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post XprofileFields
         * @summary Post XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileFields(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<XprofileFieldsResponse>> {
            const localVarFetchArgs = XprofileApiFetchParamCreator(configuration).postXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post XprofileGroups
         * @summary Post XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<XprofileGroupsResponse>> {
            const localVarFetchArgs = XprofileApiFetchParamCreator(configuration).postXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * XprofileApi - factory interface
 * @export
 */
export const XprofileApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get XprofileData
         * @summary Get XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileData(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return XprofileApiFp(configuration).getXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Get XprofileFields
         * @summary Get XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileFields(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return XprofileApiFp(configuration).getXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Get XprofileGroups
         * @summary Get XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return XprofileApiFp(configuration).getXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post XprofileData
         * @summary Post XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileData(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return XprofileApiFp(configuration).postXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post XprofileFields
         * @summary Post XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileFields(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return XprofileApiFp(configuration).postXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post XprofileGroups
         * @summary Post XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
            return XprofileApiFp(configuration).postXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};

/**
 * XprofileApi - interface
 * @export
 * @interface XprofileApi
 */
export interface XprofileApiInterface {
    /**
     * Get XprofileData
     * @summary Get XprofileData
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApiInterface
     */
    getXprofileData(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<XprofileDataResponse>>;

    /**
     * Get XprofileFields
     * @summary Get XprofileFields
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApiInterface
     */
    getXprofileFields(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<XprofileFieldsResponse>>;

    /**
     * Get XprofileGroups
     * @summary Get XprofileGroups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApiInterface
     */
    getXprofileGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<XprofileGroupsResponse>>;

    /**
     * Post XprofileData
     * @summary Post XprofileData
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApiInterface
     */
    postXprofileData(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<XprofileDataResponse>>;

    /**
     * Post XprofileFields
     * @summary Post XprofileFields
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApiInterface
     */
    postXprofileFields(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<XprofileFieldsResponse>>;

    /**
     * Post XprofileGroups
     * @summary Post XprofileGroups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApiInterface
     */
    postXprofileGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any): Promise<Array<XprofileGroupsResponse>>;

}

/**
 * XprofileApi - object-oriented interface
 * @export
 * @class XprofileApi
 * @extends {BaseAPI}
 */
export class XprofileApi extends BaseAPI implements XprofileApiInterface {
    /**
     * Get XprofileData
     * @summary Get XprofileData
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    public getXprofileData(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return XprofileApiFp(this.configuration).getXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Get XprofileFields
     * @summary Get XprofileFields
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    public getXprofileFields(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return XprofileApiFp(this.configuration).getXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Get XprofileGroups
     * @summary Get XprofileGroups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    public getXprofileGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return XprofileApiFp(this.configuration).getXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post XprofileData
     * @summary Post XprofileData
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    public postXprofileData(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return XprofileApiFp(this.configuration).postXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post XprofileFields
     * @summary Post XprofileFields
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    public postXprofileFields(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return XprofileApiFp(this.configuration).postXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

    /**
     * Post XprofileGroups
     * @summary Post XprofileGroups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    public postXprofileGroups(sort?: string, limit?: number, offset?: number, updatedAt?: string, userId?: number, createdAt?: string, id?: number, clientId?: string, options?: any) {
        return XprofileApiFp(this.configuration).postXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }

}

