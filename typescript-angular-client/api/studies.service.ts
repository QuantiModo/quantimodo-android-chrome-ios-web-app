/**
 * quantimodo
 * We make it easy to retrieve and analyze normalized user data from a wide array of devices and applications. Check out our [docs and sdk's](https://github.com/QuantiModo/docs) or [contact us](https://help.quantimo.do).
 *
 * OpenAPI spec version: 5.8.112511
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { CommonResponse } from '../model/commonResponse';
import { GetStudiesResponse } from '../model/getStudiesResponse';
import { JsonErrorResponse } from '../model/jsonErrorResponse';
import { PostStudyCreateResponse } from '../model/postStudyCreateResponse';
import { PostStudyPublishResponse } from '../model/postStudyPublishResponse';
import { Study } from '../model/study';
import { StudyCreationBody } from '../model/studyCreationBody';
import { StudyJoinResponse } from '../model/studyJoinResponse';
import { Vote } from '../model/vote';
import { VoteDelete } from '../model/voteDelete';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class StudiesService {

    protected basePath = 'https://app.quantimo.do/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Create a Study
     * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
     * @param body Details about the study you want to create
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createStudy(body: StudyCreationBody, clientId?: string, observe?: 'body', reportProgress?: boolean): Observable<PostStudyCreateResponse>;
    public createStudy(body: StudyCreationBody, clientId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PostStudyCreateResponse>>;
    public createStudy(body: StudyCreationBody, clientId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PostStudyCreateResponse>>;
    public createStudy(body: StudyCreationBody, clientId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createStudy.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.apiKeys["access_token"]) {
            queryParameters = queryParameters.set('access_token', this.configuration.apiKeys["access_token"]);
        }

        // authentication (quantimodo_oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PostStudyCreateResponse>(`${this.basePath}/v3/study/create`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete vote
     * Delete previously posted vote
     * @param body The cause and effect variable names for the predictor vote to be deleted.
     * @param userId User&#39;s id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteVote(body: VoteDelete, userId?: number, observe?: 'body', reportProgress?: boolean): Observable<CommonResponse>;
    public deleteVote(body: VoteDelete, userId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CommonResponse>>;
    public deleteVote(body: VoteDelete, userId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CommonResponse>>;
    public deleteVote(body: VoteDelete, userId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling deleteVote.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.apiKeys["access_token"]) {
            queryParameters = queryParameters.set('access_token', this.configuration.apiKeys["access_token"]);
        }

        // authentication (quantimodo_oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.delete<CommonResponse>(`${this.basePath}/v3/votes/delete`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * These are open studies that anyone can join
     * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param includeCharts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param recalculate Recalculate instead of using cached analysis
     * @param studyId Client id for the study you want
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOpenStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe?: 'body', reportProgress?: boolean): Observable<GetStudiesResponse>;
    public getOpenStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetStudiesResponse>>;
    public getOpenStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetStudiesResponse>>;
    public getOpenStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (causeVariableName !== undefined && causeVariableName !== null) {
            queryParameters = queryParameters.set('causeVariableName', <any>causeVariableName);
        }
        if (effectVariableName !== undefined && effectVariableName !== null) {
            queryParameters = queryParameters.set('effectVariableName', <any>effectVariableName);
        }
        if (causeVariableId !== undefined && causeVariableId !== null) {
            queryParameters = queryParameters.set('causeVariableId', <any>causeVariableId);
        }
        if (effectVariableId !== undefined && effectVariableId !== null) {
            queryParameters = queryParameters.set('effectVariableId', <any>effectVariableId);
        }
        if (predictorVariableName !== undefined && predictorVariableName !== null) {
            queryParameters = queryParameters.set('predictorVariableName', <any>predictorVariableName);
        }
        if (outcomeVariableName !== undefined && outcomeVariableName !== null) {
            queryParameters = queryParameters.set('outcomeVariableName', <any>outcomeVariableName);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (includeCharts !== undefined && includeCharts !== null) {
            queryParameters = queryParameters.set('includeCharts', <any>includeCharts);
        }
        if (recalculate !== undefined && recalculate !== null) {
            queryParameters = queryParameters.set('recalculate', <any>recalculate);
        }
        if (studyId !== undefined && studyId !== null) {
            queryParameters = queryParameters.set('studyId', <any>studyId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.apiKeys["access_token"]) {
            queryParameters = queryParameters.set('access_token', this.configuration.apiKeys["access_token"]);
        }

        // authentication (quantimodo_oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetStudiesResponse>(`${this.basePath}/v3/studies/open`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Personal or Population Studies
     * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param includeCharts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param recalculate Recalculate instead of using cached analysis
     * @param studyId Client id for the study you want
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param correlationCoefficient Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param outcomesOfInterest Only include correlations for which the effect is an outcome of interest for the user
     * @param principalInvestigatorUserId These are studies created by a specific principal investigator
     * @param open These are studies that anyone can join
     * @param joined These are studies that you have joined
     * @param created These are studies that you have created
     * @param population These are studies based on the entire population of users that have shared their data
     * @param downvoted These are studies that you have down-voted
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, sort?: string, limit?: number, offset?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, principalInvestigatorUserId?: number, open?: boolean, joined?: boolean, created?: boolean, population?: boolean, downvoted?: boolean, observe?: 'body', reportProgress?: boolean): Observable<GetStudiesResponse>;
    public getStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, sort?: string, limit?: number, offset?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, principalInvestigatorUserId?: number, open?: boolean, joined?: boolean, created?: boolean, population?: boolean, downvoted?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetStudiesResponse>>;
    public getStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, sort?: string, limit?: number, offset?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, principalInvestigatorUserId?: number, open?: boolean, joined?: boolean, created?: boolean, population?: boolean, downvoted?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetStudiesResponse>>;
    public getStudies(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, sort?: string, limit?: number, offset?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, principalInvestigatorUserId?: number, open?: boolean, joined?: boolean, created?: boolean, population?: boolean, downvoted?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
























        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (causeVariableName !== undefined && causeVariableName !== null) {
            queryParameters = queryParameters.set('causeVariableName', <any>causeVariableName);
        }
        if (effectVariableName !== undefined && effectVariableName !== null) {
            queryParameters = queryParameters.set('effectVariableName', <any>effectVariableName);
        }
        if (causeVariableId !== undefined && causeVariableId !== null) {
            queryParameters = queryParameters.set('causeVariableId', <any>causeVariableId);
        }
        if (effectVariableId !== undefined && effectVariableId !== null) {
            queryParameters = queryParameters.set('effectVariableId', <any>effectVariableId);
        }
        if (predictorVariableName !== undefined && predictorVariableName !== null) {
            queryParameters = queryParameters.set('predictorVariableName', <any>predictorVariableName);
        }
        if (outcomeVariableName !== undefined && outcomeVariableName !== null) {
            queryParameters = queryParameters.set('outcomeVariableName', <any>outcomeVariableName);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (includeCharts !== undefined && includeCharts !== null) {
            queryParameters = queryParameters.set('includeCharts', <any>includeCharts);
        }
        if (recalculate !== undefined && recalculate !== null) {
            queryParameters = queryParameters.set('recalculate', <any>recalculate);
        }
        if (studyId !== undefined && studyId !== null) {
            queryParameters = queryParameters.set('studyId', <any>studyId);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (correlationCoefficient !== undefined && correlationCoefficient !== null) {
            queryParameters = queryParameters.set('correlationCoefficient', <any>correlationCoefficient);
        }
        if (updatedAt !== undefined && updatedAt !== null) {
            queryParameters = queryParameters.set('updatedAt', <any>updatedAt);
        }
        if (outcomesOfInterest !== undefined && outcomesOfInterest !== null) {
            queryParameters = queryParameters.set('outcomesOfInterest', <any>outcomesOfInterest);
        }
        if (principalInvestigatorUserId !== undefined && principalInvestigatorUserId !== null) {
            queryParameters = queryParameters.set('principalInvestigatorUserId', <any>principalInvestigatorUserId);
        }
        if (open !== undefined && open !== null) {
            queryParameters = queryParameters.set('open', <any>open);
        }
        if (joined !== undefined && joined !== null) {
            queryParameters = queryParameters.set('joined', <any>joined);
        }
        if (created !== undefined && created !== null) {
            queryParameters = queryParameters.set('created', <any>created);
        }
        if (population !== undefined && population !== null) {
            queryParameters = queryParameters.set('population', <any>population);
        }
        if (downvoted !== undefined && downvoted !== null) {
            queryParameters = queryParameters.set('downvoted', <any>downvoted);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.apiKeys["access_token"]) {
            queryParameters = queryParameters.set('access_token', this.configuration.apiKeys["access_token"]);
        }

        // authentication (quantimodo_oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetStudiesResponse>(`${this.basePath}/v3/studies`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get studies you have created
     * These are studies that you have created.
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param userId User&#39;s id
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStudiesCreated(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, updatedAt?: string, clientId?: string, observe?: 'body', reportProgress?: boolean): Observable<GetStudiesResponse>;
    public getStudiesCreated(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, updatedAt?: string, clientId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetStudiesResponse>>;
    public getStudiesCreated(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, updatedAt?: string, clientId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetStudiesResponse>>;
    public getStudiesCreated(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, updatedAt?: string, clientId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {













        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (causeVariableName !== undefined && causeVariableName !== null) {
            queryParameters = queryParameters.set('causeVariableName', <any>causeVariableName);
        }
        if (effectVariableName !== undefined && effectVariableName !== null) {
            queryParameters = queryParameters.set('effectVariableName', <any>effectVariableName);
        }
        if (causeVariableId !== undefined && causeVariableId !== null) {
            queryParameters = queryParameters.set('causeVariableId', <any>causeVariableId);
        }
        if (effectVariableId !== undefined && effectVariableId !== null) {
            queryParameters = queryParameters.set('effectVariableId', <any>effectVariableId);
        }
        if (predictorVariableName !== undefined && predictorVariableName !== null) {
            queryParameters = queryParameters.set('predictorVariableName', <any>predictorVariableName);
        }
        if (outcomeVariableName !== undefined && outcomeVariableName !== null) {
            queryParameters = queryParameters.set('outcomeVariableName', <any>outcomeVariableName);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }
        if (updatedAt !== undefined && updatedAt !== null) {
            queryParameters = queryParameters.set('updatedAt', <any>updatedAt);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.apiKeys["access_token"]) {
            queryParameters = queryParameters.set('access_token', this.configuration.apiKeys["access_token"]);
        }

        // authentication (quantimodo_oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetStudiesResponse>(`${this.basePath}/v3/studies/created`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Studies You Have Joined
     * These are studies that you are currently sharing your data with.
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param sort Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param limit The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param userId User&#39;s id
     * @param correlationCoefficient Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param updatedAt When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param outcomesOfInterest Only include correlations for which the effect is an outcome of interest for the user
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStudiesJoined(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, observe?: 'body', reportProgress?: boolean): Observable<GetStudiesResponse>;
    public getStudiesJoined(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetStudiesResponse>>;
    public getStudiesJoined(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetStudiesResponse>>;
    public getStudiesJoined(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, sort?: string, limit?: number, offset?: number, userId?: number, correlationCoefficient?: string, updatedAt?: string, outcomesOfInterest?: boolean, clientId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {















        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (causeVariableName !== undefined && causeVariableName !== null) {
            queryParameters = queryParameters.set('causeVariableName', <any>causeVariableName);
        }
        if (effectVariableName !== undefined && effectVariableName !== null) {
            queryParameters = queryParameters.set('effectVariableName', <any>effectVariableName);
        }
        if (causeVariableId !== undefined && causeVariableId !== null) {
            queryParameters = queryParameters.set('causeVariableId', <any>causeVariableId);
        }
        if (effectVariableId !== undefined && effectVariableId !== null) {
            queryParameters = queryParameters.set('effectVariableId', <any>effectVariableId);
        }
        if (predictorVariableName !== undefined && predictorVariableName !== null) {
            queryParameters = queryParameters.set('predictorVariableName', <any>predictorVariableName);
        }
        if (outcomeVariableName !== undefined && outcomeVariableName !== null) {
            queryParameters = queryParameters.set('outcomeVariableName', <any>outcomeVariableName);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }
        if (correlationCoefficient !== undefined && correlationCoefficient !== null) {
            queryParameters = queryParameters.set('correlationCoefficient', <any>correlationCoefficient);
        }
        if (updatedAt !== undefined && updatedAt !== null) {
            queryParameters = queryParameters.set('updatedAt', <any>updatedAt);
        }
        if (outcomesOfInterest !== undefined && outcomesOfInterest !== null) {
            queryParameters = queryParameters.set('outcomesOfInterest', <any>outcomesOfInterest);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.apiKeys["access_token"]) {
            queryParameters = queryParameters.set('access_token', this.configuration.apiKeys["access_token"]);
        }

        // authentication (quantimodo_oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<GetStudiesResponse>(`${this.basePath}/v3/studies/joined`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Study
     * Get Study
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param includeCharts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param recalculate Recalculate instead of using cached analysis
     * @param studyId Client id for the study you want
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe?: 'body', reportProgress?: boolean): Observable<Study>;
    public getStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Study>>;
    public getStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Study>>;
    public getStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (causeVariableName !== undefined && causeVariableName !== null) {
            queryParameters = queryParameters.set('causeVariableName', <any>causeVariableName);
        }
        if (effectVariableName !== undefined && effectVariableName !== null) {
            queryParameters = queryParameters.set('effectVariableName', <any>effectVariableName);
        }
        if (causeVariableId !== undefined && causeVariableId !== null) {
            queryParameters = queryParameters.set('causeVariableId', <any>causeVariableId);
        }
        if (effectVariableId !== undefined && effectVariableId !== null) {
            queryParameters = queryParameters.set('effectVariableId', <any>effectVariableId);
        }
        if (predictorVariableName !== undefined && predictorVariableName !== null) {
            queryParameters = queryParameters.set('predictorVariableName', <any>predictorVariableName);
        }
        if (outcomeVariableName !== undefined && outcomeVariableName !== null) {
            queryParameters = queryParameters.set('outcomeVariableName', <any>outcomeVariableName);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (includeCharts !== undefined && includeCharts !== null) {
            queryParameters = queryParameters.set('includeCharts', <any>includeCharts);
        }
        if (recalculate !== undefined && recalculate !== null) {
            queryParameters = queryParameters.set('recalculate', <any>recalculate);
        }
        if (studyId !== undefined && studyId !== null) {
            queryParameters = queryParameters.set('studyId', <any>studyId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.apiKeys["access_token"]) {
            queryParameters = queryParameters.set('access_token', this.configuration.apiKeys["access_token"]);
        }

        // authentication (quantimodo_oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Study>(`${this.basePath}/v4/study`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Join a Study
     * Anonymously share measurements for specified variables
     * @param studyId Client id for the study you want
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public joinStudy(studyId?: string, causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, observe?: 'body', reportProgress?: boolean): Observable<StudyJoinResponse>;
    public joinStudy(studyId?: string, causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<StudyJoinResponse>>;
    public joinStudy(studyId?: string, causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StudyJoinResponse>>;
    public joinStudy(studyId?: string, causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {










        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (studyId !== undefined && studyId !== null) {
            queryParameters = queryParameters.set('studyId', <any>studyId);
        }
        if (causeVariableName !== undefined && causeVariableName !== null) {
            queryParameters = queryParameters.set('causeVariableName', <any>causeVariableName);
        }
        if (effectVariableName !== undefined && effectVariableName !== null) {
            queryParameters = queryParameters.set('effectVariableName', <any>effectVariableName);
        }
        if (causeVariableId !== undefined && causeVariableId !== null) {
            queryParameters = queryParameters.set('causeVariableId', <any>causeVariableId);
        }
        if (effectVariableId !== undefined && effectVariableId !== null) {
            queryParameters = queryParameters.set('effectVariableId', <any>effectVariableId);
        }
        if (predictorVariableName !== undefined && predictorVariableName !== null) {
            queryParameters = queryParameters.set('predictorVariableName', <any>predictorVariableName);
        }
        if (outcomeVariableName !== undefined && outcomeVariableName !== null) {
            queryParameters = queryParameters.set('outcomeVariableName', <any>outcomeVariableName);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.apiKeys["access_token"]) {
            queryParameters = queryParameters.set('access_token', this.configuration.apiKeys["access_token"]);
        }

        // authentication (quantimodo_oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<StudyJoinResponse>(`${this.basePath}/v3/study/join`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Post or update vote
     * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there&#39;s a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
     * @param body Contains the cause variable, effect variable, and vote value.
     * @param userId User&#39;s id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postVote(body: Vote, userId?: number, observe?: 'body', reportProgress?: boolean): Observable<CommonResponse>;
    public postVote(body: Vote, userId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CommonResponse>>;
    public postVote(body: Vote, userId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CommonResponse>>;
    public postVote(body: Vote, userId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postVote.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.apiKeys["access_token"]) {
            queryParameters = queryParameters.set('access_token', this.configuration.apiKeys["access_token"]);
        }

        // authentication (quantimodo_oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<CommonResponse>(`${this.basePath}/v3/votes`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Publish Your Study
     * Make a study and all related measurements publicly visible by anyone
     * @param causeVariableName Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param effectVariableName Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param causeVariableId Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param effectVariableId Variable id of the outcome variable of interest.  Ex: 1398
     * @param predictorVariableName Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param outcomeVariableName Name of the outcome variable of interest.  Ex: Overall Mood
     * @param userId User&#39;s id
     * @param clientId Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param includeCharts Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param recalculate Recalculate instead of using cached analysis
     * @param studyId Client id for the study you want
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public publishStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe?: 'body', reportProgress?: boolean): Observable<PostStudyPublishResponse>;
    public publishStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PostStudyPublishResponse>>;
    public publishStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PostStudyPublishResponse>>;
    public publishStudy(causeVariableName?: string, effectVariableName?: string, causeVariableId?: number, effectVariableId?: number, predictorVariableName?: string, outcomeVariableName?: string, userId?: number, clientId?: string, includeCharts?: boolean, recalculate?: boolean, studyId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {












        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (causeVariableName !== undefined && causeVariableName !== null) {
            queryParameters = queryParameters.set('causeVariableName', <any>causeVariableName);
        }
        if (effectVariableName !== undefined && effectVariableName !== null) {
            queryParameters = queryParameters.set('effectVariableName', <any>effectVariableName);
        }
        if (causeVariableId !== undefined && causeVariableId !== null) {
            queryParameters = queryParameters.set('causeVariableId', <any>causeVariableId);
        }
        if (effectVariableId !== undefined && effectVariableId !== null) {
            queryParameters = queryParameters.set('effectVariableId', <any>effectVariableId);
        }
        if (predictorVariableName !== undefined && predictorVariableName !== null) {
            queryParameters = queryParameters.set('predictorVariableName', <any>predictorVariableName);
        }
        if (outcomeVariableName !== undefined && outcomeVariableName !== null) {
            queryParameters = queryParameters.set('outcomeVariableName', <any>outcomeVariableName);
        }
        if (userId !== undefined && userId !== null) {
            queryParameters = queryParameters.set('userId', <any>userId);
        }
        if (clientId !== undefined && clientId !== null) {
            queryParameters = queryParameters.set('clientId', <any>clientId);
        }
        if (includeCharts !== undefined && includeCharts !== null) {
            queryParameters = queryParameters.set('includeCharts', <any>includeCharts);
        }
        if (recalculate !== undefined && recalculate !== null) {
            queryParameters = queryParameters.set('recalculate', <any>recalculate);
        }
        if (studyId !== undefined && studyId !== null) {
            queryParameters = queryParameters.set('studyId', <any>studyId);
        }

        let headers = this.defaultHeaders;

        // authentication (access_token) required
        if (this.configuration.apiKeys["access_token"]) {
            queryParameters = queryParameters.set('access_token', this.configuration.apiKeys["access_token"]);
        }

        // authentication (quantimodo_oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<PostStudyPublishResponse>(`${this.basePath}/v3/study/publish`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
